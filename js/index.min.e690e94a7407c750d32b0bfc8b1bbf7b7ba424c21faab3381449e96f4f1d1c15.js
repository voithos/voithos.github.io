(()=>{var gm="128",k$=0,gj=1,op=2,f_=1,os=2,bt=3,cl=0,t=1,bj=2,fZ=1,be=0,bg=1,fY=2,fV=3,fT=4,or=5,bc=100,om=101,ok=102,fL=103,fB=104,oj=200,oi=201,oe=202,od=203,fz=204,fw=205,oc=206,ob=207,n_=208,nW=209,nN=210,nL=0,nH=1,nB=2,cG=3,ns=4,nr=5,nn=6,nm=7,ch=0,nk=1,nj=2,bd=0,ni=1,nh=2,nf=3,ne=4,nd=5,fj=300,de=301,di=302,fi=303,fg=304,dm=306,dp=307,dq=1e3,O=1001,dr=1002,A=1003,fe=1004,eX=1005,I=1006,nc=1007,dD=1008,dI=1009,nb=1010,m$=1011,cp=1012,m_=1013,cx=1014,ac=1015,cw=1016,mZ=1017,mW=1018,mV=1019,bz=1020,mU=1021,av=1022,N=1023,mS=1024,mR=1025,aE=1026,bA=1027,mQ=1028,mP=1029,mK=1030,mI=1031,mG=1032,mF=1033,eO=33776,eN=33777,eM=33778,eK=33779,eJ=35840,eI=35841,eH=35842,eG=35843,mE=36196,eF=37492,eE=37496,mD=37808,mC=37809,kT=37810,mB=37811,mA=37812,mz=37813,my=37814,mx=37815,mu=37816,ms=37817,mr=37818,mo=37819,ml=37820,mk=37821,mj=36492,mi=37840,mg=37841,mf=37842,me=37843,md=37844,mb=37845,l$=37846,l_=37847,lS=37848,lL=37849,lK=37850,lJ=37851,lI=37852,lG=37853,lF=2200,lE=2201,lD=2202,bJ=2300,bH=2301,da=2302,aH=2400,ay=2401,cb=2402,c$=2500,et=2501,lB=0,aF=3e3,cZ=3001,dT=3007,es=3002,lz=3003,er=3004,eq=3005,ep=3006,ly=3200,lx=3201,aS=0,lw=1,cO=7680,lv=519,bl=35044,bZ=35048,en="300 es",aq=class{addEventListener(a,c){this._listeners===void 0&&(this._listeners={});const b=this._listeners;b[a]===void 0&&(b[a]=[]),b[a].indexOf(c)===-1&&b[a].push(c)}hasEventListener(a,c){if(this._listeners===void 0)return!1;const b=this._listeners;return b[a]!==void 0&&b[a].indexOf(c)!==-1}removeEventListener(b,c){if(this._listeners===void 0)return;const d=this._listeners,a=d[b];if(a!==void 0){const b=a.indexOf(c);b!==-1&&a.splice(b,1)}}dispatchEvent(a){if(this._listeners===void 0)return;const c=this._listeners,b=c[a.type];if(b!==void 0){a.target=this;const c=b.slice(0);for(let b=0,d=c.length;b<d;b++)c[b].call(this,a);a.target=null}}},w=[],cB,cL,b,v,aR,aP,le,y,i,ap,ld,B,a,cC,ej,H,Y,bF,dG,aJ,aA,ax,ao,ae,ar,bh,cg,cd,at,kV,eh,cP,cQ,aN,X,cT,bP,ah,cW,bN,cY,aG,e,aC,Q,kS,kR,al,cy,G,eg,ef,bC,kQ,kP,dZ,bb,Z,b$,bf,kN,kL,dX,dW,dV,kK,dU,h,dz,kJ,kI,U,P,_,dF,$,aD,aB,dS,dK,dL,dM,p,kH,dQ,L,cs,d,dt,k,b_,u,d$,ea,kG,s,kF,V,dg,aV,F,bD,q,l,em,aZ,cR,ai,ag,af,cX,c_,db,bL,bQ,ce,bT,bW,bX,dl,ca,K,dC,kC,kB,kA,ak,dk,D,aL,aw,dH,cu,eT,eU,aK,co,cm,e_,ot,kw,ku,kt,ks,kr,kp,ko,kn,km,kl,kk,kj,ki,kh,kg,kf,ke,kd,kc,kb,ka,j$,j_,jZ,jY,jW,jS,jQ,jP,jL,jI,jH,jF,jy,jo,jn,jl,jh,jf,je,jd,iZ,iY,iX,iU,iT,iR,iQ,iO,h_,hZ,hY,hX,hW,hV,hU,hT,hS,hR,hO,hN,hM,hx,hw,hv,gR,go,nC,gp,gq,gr,gs,gt,gu,gv,gw,gx,gy,gz,gA,gB,gC,gD,gE,gF,gG,gH,gI,gJ,gK,gL,gM,gN,gO,gP,gQ,iP,gS,gT,gU,gV,gW,gX,gY,gZ,g_,g$,ha,hb,hc,hd,he,hf,hg,hh,hi,hj,hk,hl,hm,hn,ho,hp,hq,hr,hs,ht,hu,f,c,W,gi,gh,gg,hP,hQ,gf,ge,gd,gc,gb,f$,dn,iV,jg,jj,jk,jC,fF,fE,jJ,jK,fC,bx,jR,cS,jT,jX,fy,fx,cN,aO,o,ct,fs,aT,bs,aU,ba,aM,bv,fl,bM,bo,bU,fh,dj,ff,kq,fd,fc,fb,kv,fa,e$,ky,eZ,eL,cn,bE,kD,bn,ee,eb,dR,dP,ck,dw,dY,gn,cV,kO,d_,ec,dc,bK,cA,kU,kW,kX,kY,kZ,oE,oD,oC,oB,lc,ad,bR,lM,lO,lQ,lR,ey,lT,lU,lV,lW,lX,lY,lZ,m,aa,ma,ez,mc,T,aW,eA,bY,mh,bk,aX,cz,eB,a$,mp,mq,ab,M,mt,eC,mv,mw,J,cc,eD,cf,du,dy,dA,eP,dO,eR,cq,mT,dJ,eS,dN,mX,mY,cv,aQ,S,na,eV,eW,fk,cU,fm,ng,fn,bm,cK,fo,nl,fp,fq,no,np,nq,fr,cH,nt,nu,nv,nw,nx,ny,cr,ov,nD,nE,nF,nG,nI,nJ,nK,cE,nM,cD,nO,nP,nQ,nR,nS,nT,nU,nV,g,nX,nY,nZ,fu,n$,oa,fv,bq,fA,bI,og,oh,aj,bG,dh,ol,on,oo,oz,oq,fP,oy,kx,ow,oF,ou,ox,au,az,oA,lb,la,dE;for(let a=0;a<256;a++)w[a]=(a<16?"0":"")+a.toString(16);cB=Math.PI/180,cL=180/Math.PI;function R(){const a=Math.random()*4294967295|0,b=Math.random()*4294967295|0,c=Math.random()*4294967295|0,d=Math.random()*4294967295|0,e=w[a&255]+w[a>>8&255]+w[a>>16&255]+w[a>>24&255]+"-"+w[b&255]+w[b>>8&255]+"-"+w[b>>16&15|64]+w[b>>24&255]+"-"+w[c&63|128]+w[c>>8&255]+"-"+w[c>>16&255]+w[c>>24&255]+w[d&255]+w[d>>8&255]+w[d>>16&255]+w[d>>24&255];return e.toUpperCase()}function E(a,b,c){return Math.max(b,Math.min(c,a))}function lt(b,a){return(b%a+a)%a}function cJ(b,c,a){return(1-a)*b+a*c}function el(a){return(a&a-1)===0&&a!==0}function lr(a){return Math.pow(2,Math.ceil(Math.log(a)/Math.LN2))}function lf(a){return Math.pow(2,Math.floor(Math.log(a)/Math.LN2))}b=class{constructor(a=0,b=0){this.x=a,this.y=b}get width(){return this.x}set width(a){this.x=a}get height(){return this.y}set height(a){this.y=a}set(a,b){return this.x=a,this.y=b,this}setScalar(a){return this.x=a,this.y=a,this}setX(a){return this.x=a,this}setY(a){return this.y=a,this}setComponent(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;default:throw new Error("index is out of range: "+a)}return this}getComponent(a){switch(a){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+a)}}clone(){return new this.constructor(this.x,this.y)}copy(a){return this.x=a.x,this.y=a.y,this}add(a,b){return b!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(a,b)):(this.x+=a.x,this.y+=a.y,this)}addScalar(a){return this.x+=a,this.y+=a,this}addVectors(a,b){return this.x=a.x+b.x,this.y=a.y+b.y,this}addScaledVector(a,b){return this.x+=a.x*b,this.y+=a.y*b,this}sub(a,b){return b!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(a,b)):(this.x-=a.x,this.y-=a.y,this)}subScalar(a){return this.x-=a,this.y-=a,this}subVectors(a,b){return this.x=a.x-b.x,this.y=a.y-b.y,this}multiply(a){return this.x*=a.x,this.y*=a.y,this}multiplyScalar(a){return this.x*=a,this.y*=a,this}divide(a){return this.x/=a.x,this.y/=a.y,this}divideScalar(a){return this.multiplyScalar(1/a)}applyMatrix3(d){const b=this.x,c=this.y,a=d.elements;return this.x=a[0]*b+a[3]*c+a[6],this.y=a[1]*b+a[4]*c+a[7],this}min(a){return this.x=Math.min(this.x,a.x),this.y=Math.min(this.y,a.y),this}max(a){return this.x=Math.max(this.x,a.x),this.y=Math.max(this.y,a.y),this}clamp(a,b){return this.x=Math.max(a.x,Math.min(b.x,this.x)),this.y=Math.max(a.y,Math.min(b.y,this.y)),this}clampScalar(a,b){return this.x=Math.max(a,Math.min(b,this.x)),this.y=Math.max(a,Math.min(b,this.y)),this}clampLength(b,c){const a=this.length();return this.divideScalar(a||1).multiplyScalar(Math.max(b,Math.min(c,a)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(a){return this.x*a.x+this.y*a.y}cross(a){return this.x*a.y-this.y*a.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){const a=Math.atan2(-this.y,-this.x)+Math.PI;return a}distanceTo(a){return Math.sqrt(this.distanceToSquared(a))}distanceToSquared(a){const b=this.x-a.x,c=this.y-a.y;return b*b+c*c}manhattanDistanceTo(a){return Math.abs(this.x-a.x)+Math.abs(this.y-a.y)}setLength(a){return this.normalize().multiplyScalar(a)}lerp(a,b){return this.x+=(a.x-this.x)*b,this.y+=(a.y-this.y)*b,this}lerpVectors(a,b,c){return this.x=a.x+(b.x-a.x)*c,this.y=a.y+(b.y-a.y)*c,this}equals(a){return a.x===this.x&&a.y===this.y}fromArray(a,b=0){return this.x=a[b],this.y=a[b+1],this}toArray(a=[],b=0){return a[b]=this.x,a[b+1]=this.y,a}fromBufferAttribute(a,b,c){return c!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=a.getX(b),this.y=a.getY(b),this}rotateAround(a,b){const c=Math.cos(b),d=Math.sin(b),e=this.x-a.x,f=this.y-a.y;return this.x=e*c-f*d+a.x,this.y=e*d+f*c+a.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}},b.prototype.isVector2=!0,v=class{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(b,c,d,j,e,f,g,h,i){const a=this.elements;return a[0]=b,a[1]=j,a[2]=g,a[3]=c,a[4]=e,a[5]=h,a[6]=d,a[7]=f,a[8]=i,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(c){const a=this.elements,b=c.elements;return a[0]=b[0],a[1]=b[1],a[2]=b[2],a[3]=b[3],a[4]=b[4],a[5]=b[5],a[6]=b[6],a[7]=b[7],a[8]=b[8],this}extractBasis(a,b,c){return a.setFromMatrix3Column(this,0),b.setFromMatrix3Column(this,1),c.setFromMatrix3Column(this,2),this}setFromMatrix4(b){const a=b.elements;return this.set(a[0],a[4],a[8],a[1],a[5],a[9],a[2],a[6],a[10]),this}multiply(a){return this.multiplyMatrices(this,a)}premultiply(a){return this.multiplyMatrices(a,this)}multiplyMatrices(w,v){const c=w.elements,a=v.elements,b=this.elements,f=c[0],g=c[3],h=c[6],i=c[1],j=c[4],k=c[7],l=c[2],m=c[5],n=c[8],o=a[0],p=a[3],q=a[6],r=a[1],s=a[4],t=a[7],u=a[2],e=a[5],d=a[8];return b[0]=f*o+g*r+h*u,b[3]=f*p+g*s+h*e,b[6]=f*q+g*t+h*d,b[1]=i*o+j*r+k*u,b[4]=i*p+j*s+k*e,b[7]=i*q+j*t+k*d,b[2]=l*o+m*r+n*u,b[5]=l*p+m*s+n*e,b[8]=l*q+m*t+n*d,this}multiplyScalar(a){const b=this.elements;return b[0]*=a,b[3]*=a,b[6]*=a,b[1]*=a,b[4]*=a,b[7]*=a,b[2]*=a,b[5]*=a,b[8]*=a,this}determinant(){const a=this.elements,b=a[0],c=a[1],d=a[2],e=a[3],f=a[4],g=a[5],h=a[6],i=a[7],j=a[8];return b*f*j-b*g*i-c*e*j+c*g*h+d*e*i-d*f*h}invert(){const a=this.elements,e=a[0],c=a[1],d=a[2],f=a[3],g=a[4],h=a[5],k=a[6],j=a[7],i=a[8],l=i*g-h*j,m=h*k-i*f,n=j*f-g*k,o=e*l+c*m+d*n;if(o===0)return this.set(0,0,0,0,0,0,0,0,0);const b=1/o;return a[0]=l*b,a[1]=(d*j-i*c)*b,a[2]=(h*c-d*g)*b,a[3]=m*b,a[4]=(i*e-d*k)*b,a[5]=(d*f-h*e)*b,a[6]=n*b,a[7]=(c*k-j*e)*b,a[8]=(g*e-c*f)*b,this}transpose(){let b;const a=this.elements;return b=a[1],a[1]=a[3],a[3]=b,b=a[2],a[2]=a[6],a[6]=b,b=a[5],a[5]=a[7],a[7]=b,this}getNormalMatrix(a){return this.setFromMatrix4(a).invert().transpose()}transposeIntoArray(a){const b=this.elements;return a[0]=b[0],a[1]=b[3],a[2]=b[6],a[3]=b[1],a[4]=b[4],a[5]=b[7],a[6]=b[2],a[7]=b[5],a[8]=b[8],this}setUvTransform(h,i,f,d,g,e,c){const a=Math.cos(g),b=Math.sin(g);return this.set(f*a,f*b,-f*(a*e+b*c)+e+h,-d*b,d*a,-d*(-b*e+a*c)+c+i,0,0,1),this}scale(b,c){const a=this.elements;return a[0]*=b,a[3]*=b,a[6]*=b,a[1]*=c,a[4]*=c,a[7]*=c,this}rotate(d){const b=Math.cos(d),c=Math.sin(d),a=this.elements,e=a[0],f=a[3],g=a[6],h=a[1],i=a[4],j=a[7];return a[0]=b*e+c*h,a[3]=b*f+c*i,a[6]=b*g+c*j,a[1]=-c*e+b*h,a[4]=-c*f+b*i,a[7]=-c*g+b*j,this}translate(b,c){const a=this.elements;return a[0]+=b*a[2],a[3]+=b*a[5],a[6]+=b*a[8],a[1]+=c*a[2],a[4]+=c*a[5],a[7]+=c*a[8],this}equals(a){const b=this.elements,c=a.elements;for(let a=0;a<9;a++)if(b[a]!==c[a])return!1;return!0}fromArray(a,b=0){for(let c=0;c<9;c++)this.elements[c]=a[c+b];return this}toArray(a=[],b=0){const c=this.elements;return a[b]=c[0],a[b+1]=c[1],a[b+2]=c[2],a[b+3]=c[3],a[b+4]=c[4],a[b+5]=c[5],a[b+6]=c[6],a[b+7]=c[7],a[b+8]=c[8],a}clone(){return(new this.constructor).fromArray(this.elements)}},v.prototype.isMatrix3=!0,aP=class{static getDataURL(a){if(/^data:/i.test(a.src))return a.src;if(typeof HTMLCanvasElement=="undefined")return a.src;let b;if(a instanceof HTMLCanvasElement)b=a;else{aR===void 0&&(aR=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),aR.width=a.width,aR.height=a.height;const c=aR.getContext("2d");a instanceof ImageData?c.putImageData(a,0,0):c.drawImage(a,0,0,a.width,a.height),b=aR}return b.width>2048||b.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",a),b.toDataURL("image/jpeg",.6)):b.toDataURL("image/png")}},le=0,y=class extends aq{constructor(a=y.DEFAULT_IMAGE,c=y.DEFAULT_MAPPING,d=O,e=O,f=I,g=dD,h=N,i=dI,j=1,k=aF){super(),Object.defineProperty(this,"id",{value:le++}),this.uuid=R(),this.name="",this.image=a,this.mipmaps=[],this.mapping=c,this.wrapS=d,this.wrapT=e,this.magFilter=f,this.minFilter=g,this.anisotropy=j,this.format=h,this.internalFormat=null,this.type=i,this.offset=new b(0,0),this.repeat=new b(1,1),this.center=new b(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new v,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=k,this.version=0,this.onUpdate=null}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return(new this.constructor).copy(this)}copy(a){return this.name=a.name,this.image=a.image,this.mipmaps=a.mipmaps.slice(0),this.mapping=a.mapping,this.wrapS=a.wrapS,this.wrapT=a.wrapT,this.magFilter=a.magFilter,this.minFilter=a.minFilter,this.anisotropy=a.anisotropy,this.format=a.format,this.internalFormat=a.internalFormat,this.type=a.type,this.offset.copy(a.offset),this.repeat.copy(a.repeat),this.center.copy(a.center),this.rotation=a.rotation,this.matrixAutoUpdate=a.matrixAutoUpdate,this.matrix.copy(a.matrix),this.generateMipmaps=a.generateMipmaps,this.premultiplyAlpha=a.premultiplyAlpha,this.flipY=a.flipY,this.unpackAlignment=a.unpackAlignment,this.encoding=a.encoding,this}toJSON(a){const b=a===void 0||typeof a=="string";if(!b&&a.textures[this.uuid]!==void 0)return a.textures[this.uuid];const c={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const d=this.image;if(d.uuid===void 0&&(d.uuid=R()),!b&&a.images[d.uuid]===void 0){let b;if(Array.isArray(d)){b=[];for(let a=0,c=d.length;a<c;a++)d[a].isDataTexture?b.push(cF(d[a].image)):b.push(cF(d[a]))}else b=cF(d);a.images[d.uuid]={uuid:d.uuid,url:b}}c.image=d.uuid}return b||(a.textures[this.uuid]=c),c}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(a){if(this.mapping!==fj)return a;if(a.applyMatrix3(this.matrix),a.x<0||a.x>1)switch(this.wrapS){case dq:a.x=a.x-Math.floor(a.x);break;case O:a.x=a.x<0?0:1;break;case dr:Math.abs(Math.floor(a.x)%2)===1?a.x=Math.ceil(a.x)-a.x:a.x=a.x-Math.floor(a.x);break}if(a.y<0||a.y>1)switch(this.wrapT){case dq:a.y=a.y-Math.floor(a.y);break;case O:a.y=a.y<0?0:1;break;case dr:Math.abs(Math.floor(a.y)%2)===1?a.y=Math.ceil(a.y)-a.y:a.y=a.y-Math.floor(a.y);break}return this.flipY&&(a.y=1-a.y),a}set needsUpdate(a){a===!0&&this.version++}},y.DEFAULT_IMAGE=void 0,y.DEFAULT_MAPPING=fj,y.prototype.isTexture=!0;function cF(a){return typeof HTMLImageElement!="undefined"&&a instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&a instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&a instanceof ImageBitmap?aP.getDataURL(a):a.data?{data:Array.prototype.slice.call(a.data),width:a.width,height:a.height,type:a.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}i=class{constructor(a=0,b=0,c=0,d=1){this.x=a,this.y=b,this.z=c,this.w=d}get width(){return this.z}set width(a){this.z=a}get height(){return this.w}set height(a){this.w=a}set(a,b,c,d){return this.x=a,this.y=b,this.z=c,this.w=d,this}setScalar(a){return this.x=a,this.y=a,this.z=a,this.w=a,this}setX(a){return this.x=a,this}setY(a){return this.y=a,this}setZ(a){return this.z=a,this}setW(a){return this.w=a,this}setComponent(b,a){switch(b){case 0:this.x=a;break;case 1:this.y=a;break;case 2:this.z=a;break;case 3:this.w=a;break;default:throw new Error("index is out of range: "+b)}return this}getComponent(a){switch(a){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+a)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(a){return this.x=a.x,this.y=a.y,this.z=a.z,this.w=a.w!==void 0?a.w:1,this}add(a,b){return b!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(a,b)):(this.x+=a.x,this.y+=a.y,this.z+=a.z,this.w+=a.w,this)}addScalar(a){return this.x+=a,this.y+=a,this.z+=a,this.w+=a,this}addVectors(a,b){return this.x=a.x+b.x,this.y=a.y+b.y,this.z=a.z+b.z,this.w=a.w+b.w,this}addScaledVector(a,b){return this.x+=a.x*b,this.y+=a.y*b,this.z+=a.z*b,this.w+=a.w*b,this}sub(a,b){return b!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(a,b)):(this.x-=a.x,this.y-=a.y,this.z-=a.z,this.w-=a.w,this)}subScalar(a){return this.x-=a,this.y-=a,this.z-=a,this.w-=a,this}subVectors(a,b){return this.x=a.x-b.x,this.y=a.y-b.y,this.z=a.z-b.z,this.w=a.w-b.w,this}multiply(a){return this.x*=a.x,this.y*=a.y,this.z*=a.z,this.w*=a.w,this}multiplyScalar(a){return this.x*=a,this.y*=a,this.z*=a,this.w*=a,this}applyMatrix4(f){const b=this.x,c=this.y,d=this.z,e=this.w,a=f.elements;return this.x=a[0]*b+a[4]*c+a[8]*d+a[12]*e,this.y=a[1]*b+a[5]*c+a[9]*d+a[13]*e,this.z=a[2]*b+a[6]*c+a[10]*d+a[14]*e,this.w=a[3]*b+a[7]*c+a[11]*d+a[15]*e,this}divideScalar(a){return this.multiplyScalar(1/a)}setAxisAngleFromQuaternion(a){this.w=2*Math.acos(a.w);const b=Math.sqrt(1-a.w*a.w);return b<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=a.x/b,this.y=a.y/b,this.z=a.z/b),this}setAxisAngleFromRotationMatrix(r){let q,b,c,d;const f=.01,m=.1,a=r.elements,o=a[0],j=a[4],k=a[8],e=a[1],n=a[5],i=a[9],g=a[2],h=a[6],p=a[10];if(Math.abs(j-e)<f&&Math.abs(k-g)<f&&Math.abs(i-h)<f){if(Math.abs(j+e)<m&&Math.abs(k+g)<m&&Math.abs(i+h)<m&&Math.abs(o+n+p-3)<m)return this.set(1,0,0,0),this;q=Math.PI;const a=(o+1)/2,l=(n+1)/2,r=(p+1)/2,s=(j+e)/4,t=(k+g)/4,u=(i+h)/4;return a>l&&a>r?a<f?(b=0,c=.707106781,d=.707106781):(b=Math.sqrt(a),c=s/b,d=t/b):l>r?l<f?(b=.707106781,c=0,d=.707106781):(c=Math.sqrt(l),b=s/c,d=u/c):r<f?(b=.707106781,c=.707106781,d=0):(d=Math.sqrt(r),b=t/d,c=u/d),this.set(b,c,d,q),this}let l=Math.sqrt((h-i)*(h-i)+(k-g)*(k-g)+(e-j)*(e-j));return Math.abs(l)<.001&&(l=1),this.x=(h-i)/l,this.y=(k-g)/l,this.z=(e-j)/l,this.w=Math.acos((o+n+p-1)/2),this}min(a){return this.x=Math.min(this.x,a.x),this.y=Math.min(this.y,a.y),this.z=Math.min(this.z,a.z),this.w=Math.min(this.w,a.w),this}max(a){return this.x=Math.max(this.x,a.x),this.y=Math.max(this.y,a.y),this.z=Math.max(this.z,a.z),this.w=Math.max(this.w,a.w),this}clamp(a,b){return this.x=Math.max(a.x,Math.min(b.x,this.x)),this.y=Math.max(a.y,Math.min(b.y,this.y)),this.z=Math.max(a.z,Math.min(b.z,this.z)),this.w=Math.max(a.w,Math.min(b.w,this.w)),this}clampScalar(a,b){return this.x=Math.max(a,Math.min(b,this.x)),this.y=Math.max(a,Math.min(b,this.y)),this.z=Math.max(a,Math.min(b,this.z)),this.w=Math.max(a,Math.min(b,this.w)),this}clampLength(b,c){const a=this.length();return this.divideScalar(a||1).multiplyScalar(Math.max(b,Math.min(c,a)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(a){return this.x*a.x+this.y*a.y+this.z*a.z+this.w*a.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(a){return this.normalize().multiplyScalar(a)}lerp(a,b){return this.x+=(a.x-this.x)*b,this.y+=(a.y-this.y)*b,this.z+=(a.z-this.z)*b,this.w+=(a.w-this.w)*b,this}lerpVectors(a,b,c){return this.x=a.x+(b.x-a.x)*c,this.y=a.y+(b.y-a.y)*c,this.z=a.z+(b.z-a.z)*c,this.w=a.w+(b.w-a.w)*c,this}equals(a){return a.x===this.x&&a.y===this.y&&a.z===this.z&&a.w===this.w}fromArray(a,b=0){return this.x=a[b],this.y=a[b+1],this.z=a[b+2],this.w=a[b+3],this}toArray(a=[],b=0){return a[b]=this.x,a[b+1]=this.y,a[b+2]=this.z,a[b+3]=this.w,a}fromBufferAttribute(a,b,c){return c!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=a.getX(b),this.y=a.getY(b),this.z=a.getZ(b),this.w=a.getW(b),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}},i.prototype.isVector4=!0,ap=class extends aq{constructor(b,c,a){super(),this.width=b,this.height=c,this.depth=1,this.scissor=new i(0,0,b,c),this.scissorTest=!1,this.viewport=new i(0,0,b,c),a=a||{},this.texture=new y(void 0,a.mapping,a.wrapS,a.wrapT,a.magFilter,a.minFilter,a.format,a.type,a.anisotropy,a.encoding),this.texture.image={},this.texture.image.width=b,this.texture.image.height=c,this.texture.image.depth=1,this.texture.generateMipmaps=a.generateMipmaps!==void 0&&a.generateMipmaps,this.texture.minFilter=a.minFilter!==void 0?a.minFilter:I,this.depthBuffer=a.depthBuffer===void 0||a.depthBuffer,this.stencilBuffer=a.stencilBuffer!==void 0&&a.stencilBuffer,this.depthTexture=a.depthTexture!==void 0?a.depthTexture:null}setTexture(a){a.image={width:this.width,height:this.height,depth:this.depth},this.texture=a}setSize(a,b,c=1){(this.width!==a||this.height!==b||this.depth!==c)&&(this.width=a,this.height=b,this.depth=c,this.texture.image.width=a,this.texture.image.height=b,this.texture.image.depth=c,this.dispose()),this.viewport.set(0,0,a,b),this.scissor.set(0,0,a,b)}clone(){return(new this.constructor).copy(this)}copy(a){return this.width=a.width,this.height=a.height,this.depth=a.depth,this.viewport.copy(a.viewport),this.texture=a.texture.clone(),this.depthBuffer=a.depthBuffer,this.stencilBuffer=a.stencilBuffer,this.depthTexture=a.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}},ap.prototype.isWebGLRenderTarget=!0,ld=class extends ap{constructor(a,b,c){super(a,b,c),this.samples=4}copy(a){return super.copy.call(this,a),this.samples=a.samples,this}},ld.prototype.isWebGLMultisampleRenderTarget=!0,B=class{constructor(a=0,b=0,c=0,d=1){this._x=a,this._y=b,this._z=c,this._w=d}static slerp(a,b,c,d){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),c.slerpQuaternions(a,b,d)}static slerpFlat(a,b,k,j,i,h,g){let f=k[j+0],e=k[j+1],d=k[j+2],c=k[j+3];const l=i[h+0],m=i[h+1],n=i[h+2],o=i[h+3];if(g===0){a[b+0]=f,a[b+1]=e,a[b+2]=d,a[b+3]=c;return}if(g===1){a[b+0]=l,a[b+1]=m,a[b+2]=n,a[b+3]=o;return}if(c!==o||f!==l||e!==m||d!==n){let a=1-g;const b=f*l+e*m+d*n+c*o,i=b>=0?1:-1,j=1-b*b;if(j>Number.EPSILON){const c=Math.sqrt(j),d=Math.atan2(c,b*i);a=Math.sin(a*d)/c,g=Math.sin(g*d)/c}const h=g*i;if(f=f*a+l*h,e=e*a+m*h,d=d*a+n*h,c=c*a+o*h,a===1-g){const a=1/Math.sqrt(f*f+e*e+d*d+c*c);f*=a,e*=a,d*=a,c*=a}}a[b]=f,a[b+1]=e,a[b+2]=d,a[b+3]=c}static multiplyQuaternionsFlat(a,h,c,d,e,f){const g=c[d],b=c[d+1],i=c[d+2],j=c[d+3],k=e[f],l=e[f+1],m=e[f+2],n=e[f+3];return a[h]=g*n+j*k+b*m-i*l,a[h+1]=b*n+j*l+i*k-g*m,a[h+2]=i*n+j*m+g*l-b*k,a[h+3]=j*n-g*k-b*l-i*m,a}get x(){return this._x}set x(a){this._x=a,this._onChangeCallback()}get y(){return this._y}set y(a){this._y=a,this._onChangeCallback()}get z(){return this._z}set z(a){this._z=a,this._onChangeCallback()}get w(){return this._w}set w(a){this._w=a,this._onChangeCallback()}set(a,b,c,d){return this._x=a,this._y=b,this._z=c,this._w=d,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(a){return this._x=a.x,this._y=a.y,this._z=a.z,this._w=a.w,this._onChangeCallback(),this}setFromEuler(g,n){if(!(g&&g.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const m=g._x,l=g._y,k=g._z,j=g._order,h=Math.cos,i=Math.sin,f=h(m/2),e=h(l/2),d=h(k/2),c=i(m/2),b=i(l/2),a=i(k/2);switch(j){case"XYZ":this._x=c*e*d+f*b*a,this._y=f*b*d-c*e*a,this._z=f*e*a+c*b*d,this._w=f*e*d-c*b*a;break;case"YXZ":this._x=c*e*d+f*b*a,this._y=f*b*d-c*e*a,this._z=f*e*a-c*b*d,this._w=f*e*d+c*b*a;break;case"ZXY":this._x=c*e*d-f*b*a,this._y=f*b*d+c*e*a,this._z=f*e*a+c*b*d,this._w=f*e*d-c*b*a;break;case"ZYX":this._x=c*e*d-f*b*a,this._y=f*b*d+c*e*a,this._z=f*e*a-c*b*d,this._w=f*e*d+c*b*a;break;case"YZX":this._x=c*e*d+f*b*a,this._y=f*b*d+c*e*a,this._z=f*e*a-c*b*d,this._w=f*e*d-c*b*a;break;case"XZY":this._x=c*e*d-f*b*a,this._y=f*b*d-c*e*a,this._z=f*e*a+c*b*d,this._w=f*e*d+c*b*a;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+j)}return n!==!1&&this._onChangeCallback(),this}setFromAxisAngle(a,d){const c=d/2,b=Math.sin(c);return this._x=a.x*b,this._y=a.y*b,this._z=a.z*b,this._w=Math.cos(c),this._onChangeCallback(),this}setFromRotationMatrix(l){const a=l.elements,c=a[0],e=a[4],j=a[8],f=a[1],b=a[5],g=a[9],h=a[2],i=a[6],d=a[10],k=c+b+d;if(k>0){const a=.5/Math.sqrt(k+1);this._w=.25/a,this._x=(i-g)*a,this._y=(j-h)*a,this._z=(f-e)*a}else if(c>b&&c>d){const a=2*Math.sqrt(1+c-b-d);this._w=(i-g)/a,this._x=.25*a,this._y=(e+f)/a,this._z=(j+h)/a}else if(b>d){const a=2*Math.sqrt(1+b-c-d);this._w=(j-h)/a,this._x=(e+f)/a,this._y=.25*a,this._z=(g+i)/a}else{const a=2*Math.sqrt(1+d-c-b);this._w=(f-e)/a,this._x=(j+h)/a,this._y=(g+i)/a,this._z=.25*a}return this._onChangeCallback(),this}setFromUnitVectors(a,b){let c=a.dot(b)+1;return c<Number.EPSILON?(c=0,Math.abs(a.x)>Math.abs(a.z)?(this._x=-a.y,this._y=a.x,this._z=0,this._w=c):(this._x=0,this._y=-a.z,this._z=a.y,this._w=c)):(this._x=a.y*b.z-a.z*b.y,this._y=a.z*b.x-a.x*b.z,this._z=a.x*b.y-a.y*b.x,this._w=c),this.normalize()}angleTo(a){return 2*Math.acos(Math.abs(E(this.dot(a),-1,1)))}rotateTowards(a,c){const b=this.angleTo(a);if(b===0)return this;const d=Math.min(1,c/b);return this.slerp(a,d),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(a){return this._x*a._x+this._y*a._y+this._z*a._z+this._w*a._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let a=this.length();return a===0?(this._x=0,this._y=0,this._z=0,this._w=1):(a=1/a,this._x=this._x*a,this._y=this._y*a,this._z=this._z*a,this._w=this._w*a),this._onChangeCallback(),this}multiply(a,b){return b!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(a,b)):this.multiplyQuaternions(this,a)}premultiply(a){return this.multiplyQuaternions(a,this)}multiplyQuaternions(a,b){const c=a._x,d=a._y,e=a._z,f=a._w,g=b._x,h=b._y,i=b._z,j=b._w;return this._x=c*j+f*g+d*i-e*h,this._y=d*j+f*h+e*g-c*i,this._z=e*j+f*i+c*h-d*g,this._w=f*j-c*g-d*h-e*i,this._onChangeCallback(),this}slerp(a,b){if(b===0)return this;if(b===1)return this.copy(a);const d=this._x,e=this._y,f=this._z,g=this._w;let c=g*a._w+d*a._x+e*a._y+f*a._z;if(c<0?(this._w=-a._w,this._x=-a._x,this._y=-a._y,this._z=-a._z,c=-c):this.copy(a),c>=1)return this._w=g,this._x=d,this._y=e,this._z=f,this;const k=1-c*c;if(k<=Number.EPSILON){const a=1-b;return this._w=a*g+b*this._w,this._x=a*d+b*this._x,this._y=a*e+b*this._y,this._z=a*f+b*this._z,this.normalize(),this._onChangeCallback(),this}const j=Math.sqrt(k),l=Math.atan2(j,c),h=Math.sin((1-b)*l)/j,i=Math.sin(b*l)/j;return this._w=g*h+this._w*i,this._x=d*h+this._x*i,this._y=e*h+this._y*i,this._z=f*h+this._z*i,this._onChangeCallback(),this}slerpQuaternions(a,b,c){this.copy(a).slerp(b,c)}equals(a){return a._x===this._x&&a._y===this._y&&a._z===this._z&&a._w===this._w}fromArray(a,b=0){return this._x=a[b],this._y=a[b+1],this._z=a[b+2],this._w=a[b+3],this._onChangeCallback(),this}toArray(a=[],b=0){return a[b]=this._x,a[b+1]=this._y,a[b+2]=this._z,a[b+3]=this._w,a}fromBufferAttribute(a,b){return this._x=a.getX(b),this._y=a.getY(b),this._z=a.getZ(b),this._w=a.getW(b),this}_onChange(a){return this._onChangeCallback=a,this}_onChangeCallback(){}},B.prototype.isQuaternion=!0,a=class{constructor(a=0,b=0,c=0){this.x=a,this.y=b,this.z=c}set(b,c,a){return a===void 0&&(a=this.z),this.x=b,this.y=c,this.z=a,this}setScalar(a){return this.x=a,this.y=a,this.z=a,this}setX(a){return this.x=a,this}setY(a){return this.y=a,this}setZ(a){return this.z=a,this}setComponent(b,a){switch(b){case 0:this.x=a;break;case 1:this.y=a;break;case 2:this.z=a;break;default:throw new Error("index is out of range: "+b)}return this}getComponent(a){switch(a){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+a)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(a){return this.x=a.x,this.y=a.y,this.z=a.z,this}add(a,b){return b!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(a,b)):(this.x+=a.x,this.y+=a.y,this.z+=a.z,this)}addScalar(a){return this.x+=a,this.y+=a,this.z+=a,this}addVectors(a,b){return this.x=a.x+b.x,this.y=a.y+b.y,this.z=a.z+b.z,this}addScaledVector(a,b){return this.x+=a.x*b,this.y+=a.y*b,this.z+=a.z*b,this}sub(a,b){return b!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(a,b)):(this.x-=a.x,this.y-=a.y,this.z-=a.z,this)}subScalar(a){return this.x-=a,this.y-=a,this.z-=a,this}subVectors(a,b){return this.x=a.x-b.x,this.y=a.y-b.y,this.z=a.z-b.z,this}multiply(a,b){return b!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(a,b)):(this.x*=a.x,this.y*=a.y,this.z*=a.z,this)}multiplyScalar(a){return this.x*=a,this.y*=a,this.z*=a,this}multiplyVectors(a,b){return this.x=a.x*b.x,this.y=a.y*b.y,this.z=a.z*b.z,this}applyEuler(a){return a&&a.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(ej.setFromEuler(a))}applyAxisAngle(a,b){return this.applyQuaternion(ej.setFromAxisAngle(a,b))}applyMatrix3(e){const b=this.x,c=this.y,d=this.z,a=e.elements;return this.x=a[0]*b+a[3]*c+a[6]*d,this.y=a[1]*b+a[4]*c+a[7]*d,this.z=a[2]*b+a[5]*c+a[8]*d,this}applyNormalMatrix(a){return this.applyMatrix3(a).normalize()}applyMatrix4(f){const b=this.x,c=this.y,d=this.z,a=f.elements,e=1/(a[3]*b+a[7]*c+a[11]*d+a[15]);return this.x=(a[0]*b+a[4]*c+a[8]*d+a[12])*e,this.y=(a[1]*b+a[5]*c+a[9]*d+a[13])*e,this.z=(a[2]*b+a[6]*c+a[10]*d+a[14])*e,this}applyQuaternion(g){const h=this.x,e=this.y,f=this.z,c=g.x,d=g.y,a=g.z,b=g.w,i=b*h+d*f-a*e,j=b*e+a*h-c*f,k=b*f+c*e-d*h,l=-c*h-d*e-a*f;return this.x=i*b+l*-c+j*-a-k*-d,this.y=j*b+l*-d+k*-c-i*-a,this.z=k*b+l*-a+i*-d-j*-c,this}project(a){return this.applyMatrix4(a.matrixWorldInverse).applyMatrix4(a.projectionMatrix)}unproject(a){return this.applyMatrix4(a.projectionMatrixInverse).applyMatrix4(a.matrixWorld)}transformDirection(e){const b=this.x,c=this.y,d=this.z,a=e.elements;return this.x=a[0]*b+a[4]*c+a[8]*d,this.y=a[1]*b+a[5]*c+a[9]*d,this.z=a[2]*b+a[6]*c+a[10]*d,this.normalize()}divide(a){return this.x/=a.x,this.y/=a.y,this.z/=a.z,this}divideScalar(a){return this.multiplyScalar(1/a)}min(a){return this.x=Math.min(this.x,a.x),this.y=Math.min(this.y,a.y),this.z=Math.min(this.z,a.z),this}max(a){return this.x=Math.max(this.x,a.x),this.y=Math.max(this.y,a.y),this.z=Math.max(this.z,a.z),this}clamp(a,b){return this.x=Math.max(a.x,Math.min(b.x,this.x)),this.y=Math.max(a.y,Math.min(b.y,this.y)),this.z=Math.max(a.z,Math.min(b.z,this.z)),this}clampScalar(a,b){return this.x=Math.max(a,Math.min(b,this.x)),this.y=Math.max(a,Math.min(b,this.y)),this.z=Math.max(a,Math.min(b,this.z)),this}clampLength(b,c){const a=this.length();return this.divideScalar(a||1).multiplyScalar(Math.max(b,Math.min(c,a)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(a){return this.x*a.x+this.y*a.y+this.z*a.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(a){return this.normalize().multiplyScalar(a)}lerp(a,b){return this.x+=(a.x-this.x)*b,this.y+=(a.y-this.y)*b,this.z+=(a.z-this.z)*b,this}lerpVectors(a,b,c){return this.x=a.x+(b.x-a.x)*c,this.y=a.y+(b.y-a.y)*c,this.z=a.z+(b.z-a.z)*c,this}cross(a,b){return b!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(a,b)):this.crossVectors(this,a)}crossVectors(a,b){const c=a.x,d=a.y,e=a.z,f=b.x,g=b.y,h=b.z;return this.x=d*h-e*g,this.y=e*f-c*h,this.z=c*g-d*f,this}projectOnVector(a){const b=a.lengthSq();if(b===0)return this.set(0,0,0);const c=a.dot(this)/b;return this.copy(a).multiplyScalar(c)}projectOnPlane(a){return cC.copy(this).projectOnVector(a),this.sub(cC)}reflect(a){return this.sub(cC.copy(a).multiplyScalar(2*this.dot(a)))}angleTo(a){const b=Math.sqrt(this.lengthSq()*a.lengthSq());if(b===0)return Math.PI/2;const c=this.dot(a)/b;return Math.acos(E(c,-1,1))}distanceTo(a){return Math.sqrt(this.distanceToSquared(a))}distanceToSquared(a){const b=this.x-a.x,c=this.y-a.y,d=this.z-a.z;return b*b+c*c+d*d}manhattanDistanceTo(a){return Math.abs(this.x-a.x)+Math.abs(this.y-a.y)+Math.abs(this.z-a.z)}setFromSpherical(a){return this.setFromSphericalCoords(a.radius,a.phi,a.theta)}setFromSphericalCoords(a,b,c){const d=Math.sin(b)*a;return this.x=d*Math.sin(c),this.y=Math.cos(b)*a,this.z=d*Math.cos(c),this}setFromCylindrical(a){return this.setFromCylindricalCoords(a.radius,a.theta,a.y)}setFromCylindricalCoords(a,b,c){return this.x=a*Math.sin(b),this.y=c,this.z=a*Math.cos(b),this}setFromMatrixPosition(b){const a=b.elements;return this.x=a[12],this.y=a[13],this.z=a[14],this}setFromMatrixScale(a){const b=this.setFromMatrixColumn(a,0).length(),c=this.setFromMatrixColumn(a,1).length(),d=this.setFromMatrixColumn(a,2).length();return this.x=b,this.y=c,this.z=d,this}setFromMatrixColumn(a,b){return this.fromArray(a.elements,b*4)}setFromMatrix3Column(a,b){return this.fromArray(a.elements,b*3)}equals(a){return a.x===this.x&&a.y===this.y&&a.z===this.z}fromArray(a,b=0){return this.x=a[b],this.y=a[b+1],this.z=a[b+2],this}toArray(a=[],b=0){return a[b]=this.x,a[b+1]=this.y,a[b+2]=this.z,a}fromBufferAttribute(a,b,c){return c!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=a.getX(b),this.y=a.getY(b),this.z=a.getZ(b),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}},a.prototype.isVector3=!0,cC=new a,ej=new B,H=class{constructor(b=new a(1/0,1/0,1/0),c=new a(-(1/0),-(1/0),-(1/0))){this.min=b,this.max=c}set(a,b){return this.min.copy(a),this.max.copy(b),this}setFromArray(a){let b=1/0,c=1/0,d=1/0,e=-(1/0),f=-(1/0),g=-(1/0);for(let h=0,l=a.length;h<l;h+=3){const i=a[h],j=a[h+1],k=a[h+2];i<b&&(b=i),j<c&&(c=j),k<d&&(d=k),i>e&&(e=i),j>f&&(f=j),k>g&&(g=k)}return this.min.set(b,c,d),this.max.set(e,f,g),this}setFromBufferAttribute(a){let b=1/0,c=1/0,d=1/0,e=-(1/0),f=-(1/0),g=-(1/0);for(let h=0,l=a.count;h<l;h++){const i=a.getX(h),j=a.getY(h),k=a.getZ(h);i<b&&(b=i),j<c&&(c=j),k<d&&(d=k),i>e&&(e=i),j>f&&(f=j),k>g&&(g=k)}return this.min.set(b,c,d),this.max.set(e,f,g),this}setFromPoints(a){this.makeEmpty();for(let b=0,c=a.length;b<c;b++)this.expandByPoint(a[b]);return this}setFromCenterAndSize(a,c){const b=bF.copy(c).multiplyScalar(.5);return this.min.copy(a).sub(b),this.max.copy(a).add(b),this}setFromObject(a){return this.makeEmpty(),this.expandByObject(a)}clone(){return(new this.constructor).copy(this)}copy(a){return this.min.copy(a.min),this.max.copy(a.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-(1/0),this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(b){return b===void 0&&(console.warn("THREE.Box3: .getCenter() target is now required"),b=new a),this.isEmpty()?b.set(0,0,0):b.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(b){return b===void 0&&(console.warn("THREE.Box3: .getSize() target is now required"),b=new a),this.isEmpty()?b.set(0,0,0):b.subVectors(this.max,this.min)}expandByPoint(a){return this.min.min(a),this.max.max(a),this}expandByVector(a){return this.min.sub(a),this.max.add(a),this}expandByScalar(a){return this.min.addScalar(-a),this.max.addScalar(a),this}expandByObject(a){a.updateWorldMatrix(!1,!1);const b=a.geometry;b!==void 0&&(b.boundingBox===null&&b.computeBoundingBox(),dG.copy(b.boundingBox),dG.applyMatrix4(a.matrixWorld),this.union(dG));const c=a.children;for(let a=0,b=c.length;a<b;a++)this.expandByObject(c[a]);return this}containsPoint(a){return!(a.x<this.min.x||a.x>this.max.x||a.y<this.min.y||a.y>this.max.y||a.z<this.min.z||a.z>this.max.z)}containsBox(a){return this.min.x<=a.min.x&&a.max.x<=this.max.x&&this.min.y<=a.min.y&&a.max.y<=this.max.y&&this.min.z<=a.min.z&&a.max.z<=this.max.z}getParameter(b,c){return c===void 0&&(console.warn("THREE.Box3: .getParameter() target is now required"),c=new a),c.set((b.x-this.min.x)/(this.max.x-this.min.x),(b.y-this.min.y)/(this.max.y-this.min.y),(b.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(a){return!(a.max.x<this.min.x||a.min.x>this.max.x||a.max.y<this.min.y||a.min.y>this.max.y||a.max.z<this.min.z||a.min.z>this.max.z)}intersectsSphere(a){return this.clampPoint(a.center,bF),bF.distanceToSquared(a.center)<=a.radius*a.radius}intersectsPlane(a){let b,c;return a.normal.x>0?(b=a.normal.x*this.min.x,c=a.normal.x*this.max.x):(b=a.normal.x*this.max.x,c=a.normal.x*this.min.x),a.normal.y>0?(b+=a.normal.y*this.min.y,c+=a.normal.y*this.max.y):(b+=a.normal.y*this.max.y,c+=a.normal.y*this.min.y),a.normal.z>0?(b+=a.normal.z*this.min.z,c+=a.normal.z*this.max.z):(b+=a.normal.z*this.max.z,c+=a.normal.z*this.min.z),b<=-a.constant&&c>=-a.constant}intersectsTriangle(b){if(this.isEmpty())return!1;this.getCenter(bh),cg.subVectors(this.max,bh),aJ.subVectors(b.a,bh),aA.subVectors(b.b,bh),ax.subVectors(b.c,bh),ao.subVectors(aA,aJ),ae.subVectors(ax,aA),ar.subVectors(aJ,ax);let a=[0,-ao.z,ao.y,0,-ae.z,ae.y,0,-ar.z,ar.y,ao.z,0,-ao.x,ae.z,0,-ae.x,ar.z,0,-ar.x,-ao.y,ao.x,0,-ae.y,ae.x,0,-ar.y,ar.x,0];return!!cM(a,aJ,aA,ax,cg)&&(!(a=[1,0,0,0,1,0,0,0,1],!cM(a,aJ,aA,ax,cg))&&(cd.crossVectors(ao,ae),a=[cd.x,cd.y,cd.z],cM(a,aJ,aA,ax,cg)))}clampPoint(c,b){return b===void 0&&(console.warn("THREE.Box3: .clampPoint() target is now required"),b=new a),b.copy(c).clamp(this.min,this.max)}distanceToPoint(a){const b=bF.copy(a).clamp(this.min,this.max);return b.sub(a).length()}getBoundingSphere(a){return a===void 0&&console.error("THREE.Box3: .getBoundingSphere() target is now required"),this.getCenter(a.center),a.radius=this.getSize(bF).length()*.5,a}intersect(a){return this.min.max(a.min),this.max.min(a.max),this.isEmpty()&&this.makeEmpty(),this}union(a){return this.min.min(a.min),this.max.max(a.max),this}applyMatrix4(a){return this.isEmpty()?this:(Y[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(a),Y[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(a),Y[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(a),Y[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(a),Y[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(a),Y[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(a),Y[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(a),Y[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(a),this.setFromPoints(Y),this)}translate(a){return this.min.add(a),this.max.add(a),this}equals(a){return a.min.equals(this.min)&&a.max.equals(this.max)}},H.prototype.isBox3=!0,Y=[new a,new a,new a,new a,new a,new a,new a,new a],bF=new a,dG=new H,aJ=new a,aA=new a,ax=new a,ao=new a,ae=new a,ar=new a,bh=new a,cg=new a,cd=new a,at=new a;function cM(b,c,d,e,a){for(let f=0,j=b.length-3;f<=j;f+=3){at.fromArray(b,f);const k=a.x*Math.abs(at.x)+a.y*Math.abs(at.y)+a.z*Math.abs(at.z),g=c.dot(at),h=d.dot(at),i=e.dot(at);if(Math.max(-Math.max(g,h,i),Math.min(g,h,i))>k)return!1}return!0}kV=new H,eh=new a,cP=new a,cQ=new a,aN=class{constructor(b=new a,c=-1){this.center=b,this.radius=c}set(a,b){return this.center.copy(a),this.radius=b,this}setFromPoints(a,d){const b=this.center;d!==void 0?b.copy(d):kV.setFromPoints(a).getCenter(b);let c=0;for(let d=0,e=a.length;d<e;d++)c=Math.max(c,b.distanceToSquared(a[d]));return this.radius=Math.sqrt(c),this}copy(a){return this.center.copy(a.center),this.radius=a.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(a){return a.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(a){return a.distanceTo(this.center)-this.radius}intersectsSphere(a){const b=this.radius+a.radius;return a.center.distanceToSquared(this.center)<=b*b}intersectsBox(a){return a.intersectsSphere(this)}intersectsPlane(a){return Math.abs(a.distanceToPoint(this.center))<=this.radius}clampPoint(c,b){const d=this.center.distanceToSquared(c);return b===void 0&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),b=new a),b.copy(c),d>this.radius*this.radius&&(b.sub(this.center).normalize(),b.multiplyScalar(this.radius).add(this.center)),b}getBoundingBox(a){return a===void 0&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),a=new H),this.isEmpty()?(a.makeEmpty(),a):(a.set(this.center,this.center),a.expandByScalar(this.radius),a)}applyMatrix4(a){return this.center.applyMatrix4(a),this.radius=this.radius*a.getMaxScaleOnAxis(),this}translate(a){return this.center.add(a),this}expandByPoint(b){cQ.subVectors(b,this.center);const a=cQ.lengthSq();if(a>this.radius*this.radius){const b=Math.sqrt(a),c=(b-this.radius)*.5;this.center.add(cQ.multiplyScalar(c/b)),this.radius+=c}return this}union(a){return cP.subVectors(a.center,this.center).normalize().multiplyScalar(a.radius),this.expandByPoint(eh.copy(a.center).add(cP)),this.expandByPoint(eh.copy(a.center).sub(cP)),this}equals(a){return a.center.equals(this.center)&&a.radius===this.radius}clone(){return(new this.constructor).copy(this)}},X=new a,cT=new a,bP=new a,ah=new a,cW=new a,bN=new a,cY=new a,aG=class{constructor(b=new a,c=new a(0,0,-1)){this.origin=b,this.direction=c}set(a,b){return this.origin.copy(a),this.direction.copy(b),this}copy(a){return this.origin.copy(a.origin),this.direction.copy(a.direction),this}at(c,b){return b===void 0&&(console.warn("THREE.Ray: .at() target is now required"),b=new a),b.copy(this.direction).multiplyScalar(c).add(this.origin)}lookAt(a){return this.direction.copy(a).sub(this.origin).normalize(),this}recast(a){return this.origin.copy(this.at(a,X)),this}closestPointToPoint(d,b){b===void 0&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),b=new a),b.subVectors(d,this.origin);const c=b.dot(this.direction);return c<0?b.copy(this.origin):b.copy(this.direction).multiplyScalar(c).add(this.origin)}distanceToPoint(a){return Math.sqrt(this.distanceSqToPoint(a))}distanceSqToPoint(a){const b=X.subVectors(a,this.origin).dot(this.direction);return b<0?this.origin.distanceToSquared(a):(X.copy(this.direction).multiplyScalar(b).add(this.origin),X.distanceToSquared(a))}distanceSqToSegment(l,k,n,m){cT.copy(l).add(k).multiplyScalar(.5),bP.copy(k).sub(l).normalize(),ah.copy(this.origin).sub(cT);const c=l.distanceTo(k)*.5,e=-this.direction.dot(bP),f=ah.dot(this.direction),d=-ah.dot(bP),h=ah.lengthSq(),j=Math.abs(1-e*e);let b,a,g,i;if(j>0)if(b=e*d-f,a=e*f-d,i=c*j,b>=0)if(a>=-i)if(a<=i){const c=1/j;b*=c,a*=c,g=b*(b+e*a+2*f)+a*(e*b+a+2*d)+h}else a=c,b=Math.max(0,-(e*a+f)),g=-b*b+a*(a+2*d)+h;else a=-c,b=Math.max(0,-(e*a+f)),g=-b*b+a*(a+2*d)+h;else a<=-i?(b=Math.max(0,-(-e*c+f)),a=b>0?-c:Math.min(Math.max(-c,-d),c),g=-b*b+a*(a+2*d)+h):a<=i?(b=0,a=Math.min(Math.max(-c,-d),c),g=a*(a+2*d)+h):(b=Math.max(0,-(e*c+f)),a=b>0?c:Math.min(Math.max(-c,-d),c),g=-b*b+a*(a+2*d)+h);else a=e>0?-c:c,b=Math.max(0,-(e*a+f)),g=-b*b+a*(a+2*d)+h;return n&&n.copy(this.direction).multiplyScalar(b).add(this.origin),m&&m.copy(bP).multiplyScalar(a).add(cT),g}intersectSphere(b,d){X.subVectors(b.center,this.origin);const a=X.dot(this.direction),e=X.dot(X)-a*a,f=b.radius*b.radius;if(e>f)return null;const g=Math.sqrt(f-e),c=a-g,h=a+g;return c<0&&h<0?null:c<0?this.at(h,d):this.at(c,d)}intersectsSphere(a){return this.distanceSqToPoint(a.center)<=a.radius*a.radius}distanceToPlane(a){const b=a.normal.dot(this.direction);if(b===0)return a.distanceToPoint(this.origin)===0?0:null;const c=-(this.origin.dot(a.normal)+a.constant)/b;return c>=0?c:null}intersectPlane(b,c){const a=this.distanceToPlane(b);return a===null?null:this.at(a,c)}intersectsPlane(a){const b=a.distanceToPoint(this.origin);if(b===0)return!0;const c=a.normal.dot(this.direction);return c*b<0}intersectBox(c,l){let a,b,f,k,g,e;const h=1/this.direction.x,i=1/this.direction.y,j=1/this.direction.z,d=this.origin;return h>=0?(a=(c.min.x-d.x)*h,b=(c.max.x-d.x)*h):(a=(c.max.x-d.x)*h,b=(c.min.x-d.x)*h),i>=0?(f=(c.min.y-d.y)*i,k=(c.max.y-d.y)*i):(f=(c.max.y-d.y)*i,k=(c.min.y-d.y)*i),a>k||f>b?null:((f>a||a!==a)&&(a=f),(k<b||b!==b)&&(b=k),j>=0?(g=(c.min.z-d.z)*j,e=(c.max.z-d.z)*j):(g=(c.max.z-d.z)*j,e=(c.min.z-d.z)*j),a>e||g>b)?null:((g>a||a!==a)&&(a=g),(e<b||b!==b)&&(b=e),b<0)?null:this.at(a>=0?a:b,l)}intersectsBox(a){return this.intersectBox(a,X)!==null}intersectTriangle(c,h,i,j,g){cW.subVectors(h,c),bN.subVectors(i,c),cY.crossVectors(cW,bN);let a=this.direction.dot(cY),b;if(a>0){if(j)return null;b=1}else if(a<0)b=-1,a=-a;else return null;ah.subVectors(this.origin,c);const d=b*this.direction.dot(bN.crossVectors(ah,bN));if(d<0)return null;const e=b*this.direction.dot(cW.cross(ah));if(e<0)return null;if(d+e>a)return null;const f=-b*ah.dot(cY);return f<0?null:this.at(f/a,g)}applyMatrix4(a){return this.origin.applyMatrix4(a),this.direction.transformDirection(a),this}equals(a){return a.origin.equals(this.origin)&&a.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}},e=class{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(q,i,c,d,e,f,g,h,b,j,k,l,m,n,o,p){const a=this.elements;return a[0]=q,a[4]=i,a[8]=c,a[12]=d,a[1]=e,a[5]=f,a[9]=g,a[13]=h,a[2]=b,a[6]=j,a[10]=k,a[14]=l,a[3]=m,a[7]=n,a[11]=o,a[15]=p,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new e).fromArray(this.elements)}copy(c){const a=this.elements,b=c.elements;return a[0]=b[0],a[1]=b[1],a[2]=b[2],a[3]=b[3],a[4]=b[4],a[5]=b[5],a[6]=b[6],a[7]=b[7],a[8]=b[8],a[9]=b[9],a[10]=b[10],a[11]=b[11],a[12]=b[12],a[13]=b[13],a[14]=b[14],a[15]=b[15],this}copyPosition(c){const a=this.elements,b=c.elements;return a[12]=b[12],a[13]=b[13],a[14]=b[14],this}setFromMatrix3(b){const a=b.elements;return this.set(a[0],a[3],a[6],0,a[1],a[4],a[7],0,a[2],a[5],a[8],0,0,0,0,1),this}extractBasis(a,b,c){return a.setFromMatrixColumn(this,0),b.setFromMatrixColumn(this,1),c.setFromMatrixColumn(this,2),this}makeBasis(a,b,c){return this.set(a.x,b.x,c.x,0,a.y,b.y,c.y,0,a.z,b.z,c.z,0,0,0,0,1),this}extractRotation(c){const a=this.elements,b=c.elements,d=1/aC.setFromMatrixColumn(c,0).length(),e=1/aC.setFromMatrixColumn(c,1).length(),f=1/aC.setFromMatrixColumn(c,2).length();return a[0]=b[0]*d,a[1]=b[1]*d,a[2]=b[2]*d,a[3]=0,a[4]=b[4]*e,a[5]=b[5]*e,a[6]=b[6]*e,a[7]=0,a[8]=b[8]*f,a[9]=b[9]*f,a[10]=b[10]*f,a[11]=0,a[12]=0,a[13]=0,a[14]=0,a[15]=1,this}makeRotationFromEuler(h){h&&h.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const a=this.elements,i=h.x,j=h.y,k=h.z,f=Math.cos(i),b=Math.sin(i),g=Math.cos(j),c=Math.sin(j),e=Math.cos(k),d=Math.sin(k);if(h.order==="XYZ"){const h=f*e,i=f*d,j=b*e,k=b*d;a[0]=g*e,a[4]=-g*d,a[8]=c,a[1]=i+j*c,a[5]=h-k*c,a[9]=-b*g,a[2]=k-h*c,a[6]=j+i*c,a[10]=f*g}else if(h.order==="YXZ"){const h=g*e,i=g*d,j=c*e,k=c*d;a[0]=h+k*b,a[4]=j*b-i,a[8]=f*c,a[1]=f*d,a[5]=f*e,a[9]=-b,a[2]=i*b-j,a[6]=k+h*b,a[10]=f*g}else if(h.order==="ZXY"){const h=g*e,i=g*d,j=c*e,k=c*d;a[0]=h-k*b,a[4]=-f*d,a[8]=j+i*b,a[1]=i+j*b,a[5]=f*e,a[9]=k-h*b,a[2]=-f*c,a[6]=b,a[10]=f*g}else if(h.order==="ZYX"){const h=f*e,i=f*d,j=b*e,k=b*d;a[0]=g*e,a[4]=j*c-i,a[8]=h*c+k,a[1]=g*d,a[5]=k*c+h,a[9]=i*c-j,a[2]=-c,a[6]=b*g,a[10]=f*g}else if(h.order==="YZX"){const h=f*g,i=f*c,j=b*g,k=b*c;a[0]=g*e,a[4]=k-h*d,a[8]=j*d+i,a[1]=d,a[5]=f*e,a[9]=-b*e,a[2]=-c*e,a[6]=i*d+j,a[10]=h-k*d}else if(h.order==="XZY"){const h=f*g,i=f*c,j=b*g,k=b*c;a[0]=g*e,a[4]=-d,a[8]=c*e,a[1]=h*d+k,a[5]=f*e,a[9]=i*d-j,a[2]=j*d-i,a[6]=b*e,a[10]=k*d+h}return a[3]=0,a[7]=0,a[11]=0,a[12]=0,a[13]=0,a[14]=0,a[15]=1,this}makeRotationFromQuaternion(a){return this.compose(kS,a,kR)}lookAt(c,d,b){const a=this.elements;return G.subVectors(c,d),G.lengthSq()===0&&(G.z=1),G.normalize(),al.crossVectors(b,G),al.lengthSq()===0&&(Math.abs(b.z)===1?G.x+=1e-4:G.z+=1e-4,G.normalize(),al.crossVectors(b,G)),al.normalize(),cy.crossVectors(G,al),a[0]=al.x,a[4]=cy.x,a[8]=G.x,a[1]=al.y,a[5]=cy.y,a[9]=G.y,a[2]=al.z,a[6]=cy.z,a[10]=G.z,this}multiply(a,b){return b!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(a,b)):this.multiplyMatrices(this,a)}premultiply(a){return this.multiplyMatrices(a,this)}multiplyMatrices(K,J){const c=K.elements,a=J.elements,b=this.elements,f=c[0],g=c[4],h=c[8],i=c[12],j=c[1],k=c[5],l=c[9],m=c[13],n=c[2],o=c[6],p=c[10],q=c[14],r=c[3],s=c[7],t=c[11],u=c[15],v=a[0],w=a[4],x=a[8],y=a[12],z=a[1],A=a[5],B=a[9],C=a[13],D=a[2],E=a[6],F=a[10],G=a[14],H=a[3],I=a[7],e=a[11],d=a[15];return b[0]=f*v+g*z+h*D+i*H,b[4]=f*w+g*A+h*E+i*I,b[8]=f*x+g*B+h*F+i*e,b[12]=f*y+g*C+h*G+i*d,b[1]=j*v+k*z+l*D+m*H,b[5]=j*w+k*A+l*E+m*I,b[9]=j*x+k*B+l*F+m*e,b[13]=j*y+k*C+l*G+m*d,b[2]=n*v+o*z+p*D+q*H,b[6]=n*w+o*A+p*E+q*I,b[10]=n*x+o*B+p*F+q*e,b[14]=n*y+o*C+p*G+q*d,b[3]=r*v+s*z+t*D+u*H,b[7]=r*w+s*A+t*E+u*I,b[11]=r*x+s*B+t*F+u*e,b[15]=r*y+s*C+t*G+u*d,this}multiplyScalar(a){const b=this.elements;return b[0]*=a,b[4]*=a,b[8]*=a,b[12]*=a,b[1]*=a,b[5]*=a,b[9]*=a,b[13]*=a,b[2]*=a,b[6]*=a,b[10]*=a,b[14]*=a,b[3]*=a,b[7]*=a,b[11]*=a,b[15]*=a,this}determinant(){const a=this.elements,i=a[0],c=a[4],d=a[8],e=a[12],f=a[1],g=a[5],h=a[9],b=a[13],j=a[2],k=a[6],l=a[10],m=a[14],n=a[3],o=a[7],p=a[11],q=a[15];return n*(+e*h*k-d*b*k-e*g*l+c*b*l+d*g*m-c*h*m)+o*(+i*h*m-i*b*l+e*f*l-d*f*m+d*b*j-e*h*j)+p*(+i*b*k-i*g*m-e*f*k+c*f*m+e*g*j-c*b*j)+q*(-d*g*j-i*h*k+i*g*l+d*f*k-c*f*l+c*h*j)}transpose(){const a=this.elements;let b;return b=a[1],a[1]=a[4],a[4]=b,b=a[2],a[2]=a[8],a[8]=b,b=a[6],a[6]=a[9],a[9]=b,b=a[3],a[3]=a[12],a[12]=b,b=a[7],a[7]=a[13],a[13]=b,b=a[11],a[11]=a[14],a[14]=b,this}setPosition(b,c,d){const a=this.elements;return b.isVector3?(a[12]=b.x,a[13]=b.y,a[14]=b.z):(a[12]=b,a[13]=c,a[14]=d),this}invert(){const a=this.elements,b=a[0],c=a[1],d=a[2],e=a[3],l=a[4],g=a[5],h=a[6],i=a[7],j=a[8],k=a[9],q=a[10],m=a[11],n=a[12],o=a[13],p=a[14],f=a[15],s=k*p*i-o*q*i+o*h*m-g*p*m-k*h*f+g*q*f,t=n*q*i-j*p*i-n*h*m+l*p*m+j*h*f-l*q*f,u=j*o*i-n*k*i+n*g*m-l*o*m-j*g*f+l*k*f,v=n*k*h-j*o*h-n*g*q+l*o*q+j*g*p-l*k*p,w=b*s+c*t+d*u+e*v;if(w===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const r=1/w;return a[0]=s*r,a[1]=(o*q*e-k*p*e-o*d*m+c*p*m+k*d*f-c*q*f)*r,a[2]=(g*p*e-o*h*e+o*d*i-c*p*i-g*d*f+c*h*f)*r,a[3]=(k*h*e-g*q*e-k*d*i+c*q*i+g*d*m-c*h*m)*r,a[4]=t*r,a[5]=(j*p*e-n*q*e+n*d*m-b*p*m-j*d*f+b*q*f)*r,a[6]=(n*h*e-l*p*e-n*d*i+b*p*i+l*d*f-b*h*f)*r,a[7]=(l*q*e-j*h*e+j*d*i-b*q*i-l*d*m+b*h*m)*r,a[8]=u*r,a[9]=(n*k*e-j*o*e-n*c*m+b*o*m+j*c*f-b*k*f)*r,a[10]=(l*o*e-n*g*e+n*c*i-b*o*i-l*c*f+b*g*f)*r,a[11]=(j*g*e-l*k*e-j*c*i+b*k*i+l*c*m-b*g*m)*r,a[12]=v*r,a[13]=(j*o*d-n*k*d+n*c*q-b*o*q-j*c*p+b*k*p)*r,a[14]=(n*g*d-l*o*d-n*c*h+b*o*h+l*c*p-b*g*p)*r,a[15]=(l*k*d-j*g*d+j*c*h-b*k*h-l*c*q+b*g*q)*r,this}scale(e){const a=this.elements,b=e.x,c=e.y,d=e.z;return a[0]*=b,a[4]*=c,a[8]*=d,a[1]*=b,a[5]*=c,a[9]*=d,a[2]*=b,a[6]*=c,a[10]*=d,a[3]*=b,a[7]*=c,a[11]*=d,this}getMaxScaleOnAxis(){const a=this.elements,b=a[0]*a[0]+a[1]*a[1]+a[2]*a[2],c=a[4]*a[4]+a[5]*a[5]+a[6]*a[6],d=a[8]*a[8]+a[9]*a[9]+a[10]*a[10];return Math.sqrt(Math.max(b,c,d))}makeTranslation(a,b,c){return this.set(1,0,0,a,0,1,0,b,0,0,1,c,0,0,0,1),this}makeRotationX(a){const b=Math.cos(a),c=Math.sin(a);return this.set(1,0,0,0,0,b,-c,0,0,c,b,0,0,0,0,1),this}makeRotationY(a){const b=Math.cos(a),c=Math.sin(a);return this.set(b,0,c,0,0,1,0,0,-c,0,b,0,0,0,0,1),this}makeRotationZ(a){const b=Math.cos(a),c=Math.sin(a);return this.set(b,-c,0,0,c,b,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(h,j){const f=Math.cos(j),c=Math.sin(j),g=1-f,e=h.x,b=h.y,a=h.z,d=g*e,i=g*b;return this.set(d*e+f,d*b-c*a,d*a+c*b,0,d*b+c*a,i*b+f,i*a-c*e,0,d*a-c*b,i*a+c*e,g*a*a+f,0,0,0,0,1),this}makeScale(a,b,c){return this.set(a,0,0,0,0,b,0,0,0,0,c,0,0,0,0,1),this}makeShear(a,b,c){return this.set(1,b,c,0,a,1,c,0,a,b,1,0,0,0,0,1),this}compose(l,c,g){const a=this.elements,b=c._x,d=c._y,h=c._z,i=c._w,v=b+b,k=d+d,e=h+h,w=b*v,u=b*k,n=b*e,o=d*k,p=d*e,q=h*e,r=i*v,s=i*k,t=i*e,f=g.x,j=g.y,m=g.z;return a[0]=(1-(o+q))*f,a[1]=(u+t)*f,a[2]=(n-s)*f,a[3]=0,a[4]=(u-t)*j,a[5]=(1-(w+q))*j,a[6]=(p+r)*j,a[7]=0,a[8]=(n+s)*m,a[9]=(p-r)*m,a[10]=(1-(w+o))*m,a[11]=0,a[12]=l.x,a[13]=l.y,a[14]=l.z,a[15]=1,this}decompose(c,j,d){const a=this.elements;let b=aC.set(a[0],a[1],a[2]).length();const h=aC.set(a[4],a[5],a[6]).length(),i=aC.set(a[8],a[9],a[10]).length(),k=this.determinant();k<0&&(b=-b),c.x=a[12],c.y=a[13],c.z=a[14],Q.copy(this);const e=1/b,f=1/h,g=1/i;return Q.elements[0]*=e,Q.elements[1]*=e,Q.elements[2]*=e,Q.elements[4]*=f,Q.elements[5]*=f,Q.elements[6]*=f,Q.elements[8]*=g,Q.elements[9]*=g,Q.elements[10]*=g,j.setFromRotationMatrix(Q),d.x=b,d.y=h,d.z=i,this}makePerspective(g,d,e,f,b,c){c===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const a=this.elements,h=2*b/(d-g),i=2*b/(e-f),j=(d+g)/(d-g),k=(e+f)/(e-f),l=-(c+b)/(c-b),m=-2*c*b/(c-b);return a[0]=h,a[4]=0,a[8]=j,a[12]=0,a[1]=0,a[5]=i,a[9]=k,a[13]=0,a[2]=0,a[6]=0,a[10]=l,a[14]=m,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(b,g,c,d,e,f){const a=this.elements,h=1/(g-b),i=1/(c-d),j=1/(f-e),k=(g+b)*h,l=(c+d)*i,m=(f+e)*j;return a[0]=2*h,a[4]=0,a[8]=0,a[12]=-k,a[1]=0,a[5]=2*i,a[9]=0,a[13]=-l,a[2]=0,a[6]=0,a[10]=-2*j,a[14]=-m,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(a){const b=this.elements,c=a.elements;for(let a=0;a<16;a++)if(b[a]!==c[a])return!1;return!0}fromArray(a,b=0){for(let c=0;c<16;c++)this.elements[c]=a[c+b];return this}toArray(a=[],b=0){const c=this.elements;return a[b]=c[0],a[b+1]=c[1],a[b+2]=c[2],a[b+3]=c[3],a[b+4]=c[4],a[b+5]=c[5],a[b+6]=c[6],a[b+7]=c[7],a[b+8]=c[8],a[b+9]=c[9],a[b+10]=c[10],a[b+11]=c[11],a[b+12]=c[12],a[b+13]=c[13],a[b+14]=c[14],a[b+15]=c[15],a}},e.prototype.isMatrix4=!0,aC=new a,Q=new e,kS=new a(0,0,0),kR=new a(1,1,1),al=new a,cy=new a,G=new a,eg=new e,ef=new B,bC=class{constructor(a=0,b=0,c=0,d=bC.DefaultOrder){this._x=a,this._y=b,this._z=c,this._order=d}get x(){return this._x}set x(a){this._x=a,this._onChangeCallback()}get y(){return this._y}set y(a){this._y=a,this._onChangeCallback()}get z(){return this._z}set z(a){this._z=a,this._onChangeCallback()}get order(){return this._order}set order(a){this._order=a,this._onChangeCallback()}set(a,b,c,d){return this._x=a,this._y=b,this._z=c,this._order=d||this._order,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(a){return this._x=a._x,this._y=a._y,this._z=a._z,this._order=a._order,this._onChangeCallback(),this}setFromRotationMatrix(m,i,l){const a=m.elements,b=a[0],f=a[4],e=a[8],h=a[1],c=a[5],j=a[9],k=a[2],g=a[6],d=a[10];switch(i=i||this._order,i){case"XYZ":this._y=Math.asin(E(e,-1,1)),Math.abs(e)<.9999999?(this._x=Math.atan2(-j,d),this._z=Math.atan2(-f,b)):(this._x=Math.atan2(g,c),this._z=0);break;case"YXZ":this._x=Math.asin(-E(j,-1,1)),Math.abs(j)<.9999999?(this._y=Math.atan2(e,d),this._z=Math.atan2(h,c)):(this._y=Math.atan2(-k,b),this._z=0);break;case"ZXY":this._x=Math.asin(E(g,-1,1)),Math.abs(g)<.9999999?(this._y=Math.atan2(-k,d),this._z=Math.atan2(-f,c)):(this._y=0,this._z=Math.atan2(h,b));break;case"ZYX":this._y=Math.asin(-E(k,-1,1)),Math.abs(k)<.9999999?(this._x=Math.atan2(g,d),this._z=Math.atan2(h,b)):(this._x=0,this._z=Math.atan2(-f,c));break;case"YZX":this._z=Math.asin(E(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(-j,c),this._y=Math.atan2(-k,b)):(this._x=0,this._y=Math.atan2(e,d));break;case"XZY":this._z=Math.asin(-E(f,-1,1)),Math.abs(f)<.9999999?(this._x=Math.atan2(g,c),this._y=Math.atan2(e,b)):(this._x=Math.atan2(-j,d),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+i)}return this._order=i,l!==!1&&this._onChangeCallback(),this}setFromQuaternion(a,b,c){return eg.makeRotationFromQuaternion(a),this.setFromRotationMatrix(eg,b,c)}setFromVector3(a,b){return this.set(a.x,a.y,a.z,b||this._order)}reorder(a){return ef.setFromEuler(this),this.setFromQuaternion(ef,a)}equals(a){return a._x===this._x&&a._y===this._y&&a._z===this._z&&a._order===this._order}fromArray(a){return this._x=a[0],this._y=a[1],this._z=a[2],a[3]!==void 0&&(this._order=a[3]),this._onChangeCallback(),this}toArray(a=[],b=0){return a[b]=this._x,a[b+1]=this._y,a[b+2]=this._z,a[b+3]=this._order,a}toVector3(b){return b?b.set(this._x,this._y,this._z):new a(this._x,this._y,this._z)}_onChange(a){return this._onChangeCallback=a,this}_onChangeCallback(){}},bC.prototype.isEuler=!0,bC.DefaultOrder="XYZ",bC.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"],kQ=class{constructor(){this.mask=1|0}set(a){this.mask=1<<a|0}enable(a){this.mask|=1<<a|0}enableAll(){this.mask=4294967295|0}toggle(a){this.mask^=1<<a|0}disable(a){this.mask&=~(1<<a|0)}disableAll(){this.mask=0}test(a){return(this.mask&a.mask)!==0}},kP=0,dZ=new a,bb=new B,Z=new e,b$=new a,bf=new a,kN=new a,kL=new B,dX=new a(1,0,0),dW=new a(0,1,0),dV=new a(0,0,1),kK={type:"added"},dU={type:"removed"},h=class extends aq{constructor(){super(),Object.defineProperty(this,"id",{value:kP++}),this.uuid=R(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=h.DefaultUp.clone();const d=new a,b=new bC,c=new B,f=new a(1,1,1);function g(){c.setFromEuler(b,!1)}function i(){b.setFromQuaternion(c,void 0,!1)}b._onChange(g),c._onChange(i),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:d},rotation:{configurable:!0,enumerable:!0,value:b},quaternion:{configurable:!0,enumerable:!0,value:c},scale:{configurable:!0,enumerable:!0,value:f},modelViewMatrix:{value:new e},normalMatrix:{value:new v}}),this.matrix=new e,this.matrixWorld=new e,this.matrixAutoUpdate=h.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new kQ,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(a){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(a),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(a){return this.quaternion.premultiply(a),this}setRotationFromAxisAngle(a,b){this.quaternion.setFromAxisAngle(a,b)}setRotationFromEuler(a){this.quaternion.setFromEuler(a,!0)}setRotationFromMatrix(a){this.quaternion.setFromRotationMatrix(a)}setRotationFromQuaternion(a){this.quaternion.copy(a)}rotateOnAxis(a,b){return bb.setFromAxisAngle(a,b),this.quaternion.multiply(bb),this}rotateOnWorldAxis(a,b){return bb.setFromAxisAngle(a,b),this.quaternion.premultiply(bb),this}rotateX(a){return this.rotateOnAxis(dX,a)}rotateY(a){return this.rotateOnAxis(dW,a)}rotateZ(a){return this.rotateOnAxis(dV,a)}translateOnAxis(a,b){return dZ.copy(a).applyQuaternion(this.quaternion),this.position.add(dZ.multiplyScalar(b)),this}translateX(a){return this.translateOnAxis(dX,a)}translateY(a){return this.translateOnAxis(dW,a)}translateZ(a){return this.translateOnAxis(dV,a)}localToWorld(a){return a.applyMatrix4(this.matrixWorld)}worldToLocal(a){return a.applyMatrix4(Z.copy(this.matrixWorld).invert())}lookAt(a,c,d){a.isVector3?b$.copy(a):b$.set(a,c,d);const b=this.parent;this.updateWorldMatrix(!0,!1),bf.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Z.lookAt(bf,b$,this.up):Z.lookAt(b$,bf,this.up),this.quaternion.setFromRotationMatrix(Z),b&&(Z.extractRotation(b.matrixWorld),bb.setFromRotationMatrix(Z),this.quaternion.premultiply(bb.invert()))}add(a){if(arguments.length>1){for(let a=0;a<arguments.length;a++)this.add(arguments[a]);return this}return a===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",a),this):(a&&a.isObject3D?(a.parent!==null&&a.parent.remove(a),a.parent=this,this.children.push(a),a.dispatchEvent(kK)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",a),this)}remove(a){if(arguments.length>1){for(let a=0;a<arguments.length;a++)this.remove(arguments[a]);return this}const b=this.children.indexOf(a);return b!==-1&&(a.parent=null,this.children.splice(b,1),a.dispatchEvent(dU)),this}clear(){for(let a=0;a<this.children.length;a++){const b=this.children[a];b.parent=null,b.dispatchEvent(dU)}return this.children.length=0,this}attach(a){return this.updateWorldMatrix(!0,!1),Z.copy(this.matrixWorld).invert(),a.parent!==null&&(a.parent.updateWorldMatrix(!0,!1),Z.multiply(a.parent.matrixWorld)),a.applyMatrix4(Z),this.add(a),a.updateWorldMatrix(!1,!0),this}getObjectById(a){return this.getObjectByProperty("id",a)}getObjectByName(a){return this.getObjectByProperty("name",a)}getObjectByProperty(a,b){if(this[a]===b)return this;for(let c=0,e=this.children.length;c<e;c++){const f=this.children[c],d=f.getObjectByProperty(a,b);if(d!==void 0)return d}}getWorldPosition(b){return b===void 0&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),b=new a),this.updateWorldMatrix(!0,!1),b.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(a){return a===void 0&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),a=new B),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(bf,a,kN),a}getWorldScale(b){return b===void 0&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),b=new a),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(bf,kL,b),b}getWorldDirection(b){b===void 0&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),b=new a),this.updateWorldMatrix(!0,!1);const c=this.matrixWorld.elements;return b.set(c[8],c[9],c[10]).normalize()}raycast(){}traverse(a){a(this);const b=this.children;for(let c=0,d=b.length;c<d;c++)b[c].traverse(a)}traverseVisible(a){if(this.visible===!1)return;a(this);const b=this.children;for(let c=0,d=b.length;c<d;c++)b[c].traverseVisible(a)}traverseAncestors(b){const a=this.parent;a!==null&&(b(a),a.traverseAncestors(b))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(a){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||a)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,a=!0);const b=this.children;for(let c=0,d=b.length;c<d;c++)b[c].updateMatrixWorld(a)}updateWorldMatrix(b,c){const a=this.parent;if(b===!0&&a!==null&&a.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),c===!0){const a=this.children;for(let b=0,c=a.length;b<c;b++)a[b].updateWorldMatrix(!1,!0)}}toJSON(b){const f=b===void 0||typeof b=="string",c={};f&&(b={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},c.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const a={};a.uuid=this.uuid,a.type=this.type,this.name!==""&&(a.name=this.name),this.castShadow===!0&&(a.castShadow=!0),this.receiveShadow===!0&&(a.receiveShadow=!0),this.visible===!1&&(a.visible=!1),this.frustumCulled===!1&&(a.frustumCulled=!1),this.renderOrder!==0&&(a.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(a.userData=this.userData),a.layers=this.layers.mask,a.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(a.matrixAutoUpdate=!1),this.isInstancedMesh&&(a.type="InstancedMesh",a.count=this.count,a.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(a.instanceColor=this.instanceColor.toJSON()));function d(c,a){return c[a.uuid]===void 0&&(c[a.uuid]=a.toJSON(b)),a.uuid}if(this.isMesh||this.isLine||this.isPoints){a.geometry=d(b.geometries,this.geometry);const c=this.geometry.parameters;if(c!==void 0&&c.shapes!==void 0){const a=c.shapes;if(Array.isArray(a))for(let c=0,e=a.length;c<e;c++){const f=a[c];d(b.shapes,f)}else d(b.shapes,a)}}if(this.isSkinnedMesh&&(a.bindMode=this.bindMode,a.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(d(b.skeletons,this.skeleton),a.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const c=[];for(let a=0,e=this.material.length;a<e;a++)c.push(d(b.materials,this.material[a]));a.material=c}else a.material=d(b.materials,this.material);if(this.children.length>0){a.children=[];for(let c=0;c<this.children.length;c++)a.children.push(this.children[c].toJSON(b).object)}if(this.animations.length>0){a.animations=[];for(let c=0;c<this.animations.length;c++){const e=this.animations[c];a.animations.push(d(b.animations,e))}}if(f){const a=e(b.geometries),d=e(b.materials),f=e(b.textures),g=e(b.images),h=e(b.shapes),i=e(b.skeletons),j=e(b.animations);a.length>0&&(c.geometries=a),d.length>0&&(c.materials=d),f.length>0&&(c.textures=f),g.length>0&&(c.images=g),h.length>0&&(c.shapes=h),i.length>0&&(c.skeletons=i),j.length>0&&(c.animations=j)}return c.object=a,c;function e(a){const b=[];for(const d in a){const c=a[d];delete c.metadata,b.push(c)}return b}}clone(a){return(new this.constructor).copy(this,a)}copy(a,b=!0){if(this.name=a.name,this.up.copy(a.up),this.position.copy(a.position),this.rotation.order=a.rotation.order,this.quaternion.copy(a.quaternion),this.scale.copy(a.scale),this.matrix.copy(a.matrix),this.matrixWorld.copy(a.matrixWorld),this.matrixAutoUpdate=a.matrixAutoUpdate,this.matrixWorldNeedsUpdate=a.matrixWorldNeedsUpdate,this.layers.mask=a.layers.mask,this.visible=a.visible,this.castShadow=a.castShadow,this.receiveShadow=a.receiveShadow,this.frustumCulled=a.frustumCulled,this.renderOrder=a.renderOrder,this.userData=JSON.parse(JSON.stringify(a.userData)),b===!0)for(let b=0;b<a.children.length;b++){const c=a.children[b];this.add(c.clone())}return this}},h.DefaultUp=new a(0,1,0),h.DefaultMatrixAutoUpdate=!0,h.prototype.isObject3D=!0,dz=new a,kJ=new a,kI=new v,U=class{constructor(b=new a(1,0,0),c=0){this.normal=b,this.constant=c}set(a,b){return this.normal.copy(a),this.constant=b,this}setComponents(a,b,c,d){return this.normal.set(a,b,c),this.constant=d,this}setFromNormalAndCoplanarPoint(a,b){return this.normal.copy(a),this.constant=-b.dot(this.normal),this}setFromCoplanarPoints(a,b,c){const d=dz.subVectors(c,b).cross(kJ.subVectors(a,b)).normalize();return this.setFromNormalAndCoplanarPoint(d,a),this}copy(a){return this.normal.copy(a.normal),this.constant=a.constant,this}normalize(){const a=1/this.normal.length();return this.normal.multiplyScalar(a),this.constant*=a,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(a){return this.normal.dot(a)+this.constant}distanceToSphere(a){return this.distanceToPoint(a.center)-a.radius}projectPoint(c,b){return b===void 0&&(console.warn("THREE.Plane: .projectPoint() target is now required"),b=new a),b.copy(this.normal).multiplyScalar(-this.distanceToPoint(c)).add(c)}intersectLine(b,c){c===void 0&&(console.warn("THREE.Plane: .intersectLine() target is now required"),c=new a);const e=b.delta(dz),f=this.normal.dot(e);if(f===0)return this.distanceToPoint(b.start)===0?c.copy(b.start):null;const d=-(b.start.dot(this.normal)+this.constant)/f;return d<0||d>1?null:c.copy(e).multiplyScalar(d).add(b.start)}intersectsLine(a){const b=this.distanceToPoint(a.start),c=this.distanceToPoint(a.end);return b<0&&c>0||c<0&&b>0}intersectsBox(a){return a.intersectsPlane(this)}intersectsSphere(a){return a.intersectsPlane(this)}coplanarPoint(b){return b===void 0&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),b=new a),b.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(a,b){const c=b||kI.getNormalMatrix(a),d=this.coplanarPoint(dz).applyMatrix4(a),e=this.normal.applyMatrix3(c).normalize();return this.constant=-d.dot(e),this}translate(a){return this.constant-=a.dot(this.normal),this}equals(a){return a.normal.equals(this.normal)&&a.constant===this.constant}clone(){return(new this.constructor).copy(this)}},U.prototype.isPlane=!0,P=new a,_=new a,dF=new a,$=new a,aD=new a,aB=new a,dS=new a,dK=new a,dL=new a,dM=new a,p=class{constructor(b=new a,c=new a,d=new a){this.a=b,this.b=c,this.c=d}static getNormal(e,c,f,b){b===void 0&&(console.warn("THREE.Triangle: .getNormal() target is now required"),b=new a),b.subVectors(f,c),P.subVectors(e,c),b.cross(P);const d=b.lengthSq();return d>0?b.multiplyScalar(1/Math.sqrt(d)):b.set(0,0,0)}static getBarycoord(o,d,n,m,b){P.subVectors(m,d),_.subVectors(n,d),dF.subVectors(o,d);const g=P.dot(P),c=P.dot(_),i=P.dot(dF),j=_.dot(_),k=_.dot(dF),l=g*j-c*c;if(b===void 0&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),b=new a),l===0)return b.set(-2,-1,-1);const f=1/l,h=(j*i-c*k)*f,e=(g*k-c*i)*f;return b.set(1-h-e,e,h)}static containsPoint(a,b,c,d){return this.getBarycoord(a,b,c,d,$),$.x>=0&&$.y>=0&&$.x+$.y<=1}static getUV(b,h,c,d,e,f,g,a){return this.getBarycoord(b,h,c,d,$),a.set(0,0),a.addScaledVector(e,$.x),a.addScaledVector(f,$.y),a.addScaledVector(g,$.z),a}static isFrontFacing(b,a,c,d){return P.subVectors(c,a),_.subVectors(b,a),P.cross(_).dot(d)<0}set(a,b,c){return this.a.copy(a),this.b.copy(b),this.c.copy(c),this}setFromPointsAndIndices(a,b,c,d){return this.a.copy(a[b]),this.b.copy(a[c]),this.c.copy(a[d]),this}clone(){return(new this.constructor).copy(this)}copy(a){return this.a.copy(a.a),this.b.copy(a.b),this.c.copy(a.c),this}getArea(){return P.subVectors(this.c,this.b),_.subVectors(this.a,this.b),P.cross(_).length()*.5}getMidpoint(b){return b===void 0&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),b=new a),b.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(a){return p.getNormal(this.a,this.b,this.c,a)}getPlane(a){return a===void 0&&(console.warn("THREE.Triangle: .getPlane() target is now required"),a=new U),a.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(a,b){return p.getBarycoord(a,this.a,this.b,this.c,b)}getUV(a,b,c,d,e){return p.getUV(a,this.a,this.b,this.c,b,c,d,e)}containsPoint(a){return p.containsPoint(a,this.a,this.b,this.c)}isFrontFacing(a){return p.isFrontFacing(this.a,this.b,this.c,a)}intersectsBox(a){return a.intersectsTriangle(this)}closestPointToPoint(n,b){b===void 0&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),b=new a);const e=this.a,k=this.b,l=this.c;let m,f;aD.subVectors(k,e),aB.subVectors(l,e),dK.subVectors(n,e);const h=aD.dot(dK),i=aB.dot(dK);if(h<=0&&i<=0)return b.copy(e);dL.subVectors(n,k);const c=aD.dot(dL),g=aB.dot(dL);if(c>=0&&g<=c)return b.copy(k);const o=h*g-c*i;if(o<=0&&h>=0&&c<=0)return m=h/(h-c),b.copy(e).addScaledVector(aD,m);dM.subVectors(n,l);const j=aD.dot(dM),d=aB.dot(dM);if(d>=0&&j<=d)return b.copy(l);const p=j*i-h*d;if(p<=0&&i>=0&&d<=0)return f=i/(i-d),b.copy(e).addScaledVector(aB,f);const q=c*d-j*g;if(q<=0&&g-c>=0&&j-d>=0)return dS.subVectors(l,k),f=(g-c)/(g-c+(j-d)),b.copy(k).addScaledVector(dS,f);const r=1/(q+p+o);return m=p*r,f=o*r,b.copy(e).addScaledVector(aD,m).addScaledVector(aB,f)}equals(a){return a.a.equals(this.a)&&a.b.equals(this.b)&&a.c.equals(this.c)}},kH=0;function r(){Object.defineProperty(this,"id",{value:kH++}),this.uuid=R(),this.name="",this.type="Material",this.fog=!0,this.blending=bg,this.side=cl,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=fz,this.blendDst=fw,this.blendEquation=bc,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=cG,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=lv,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=cO,this.stencilZFail=cO,this.stencilZPass=cO,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0}r.prototype=Object.assign(Object.create(aq.prototype),{constructor:r,isMaterial:!0,onBuild:function(){},onBeforeCompile:function(){},customProgramCacheKey:function(){return this.onBeforeCompile.toString()},setValues:function(a){if(a===void 0)return;for(const d in a){const b=a[d];if(b===void 0){console.warn("THREE.Material: '"+d+"' parameter is undefined.");continue}if(d==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=b===fZ;continue}const c=this[d];if(c===void 0){console.warn("THREE."+this.type+": '"+d+"' is not a property of this material.");continue}c&&c.isColor?c.set(b):c&&c.isVector3&&b&&b.isVector3?c.copy(b):this[d]=b}},toJSON:function(b){const c=b===void 0||typeof b=="string";c&&(b={textures:{},images:{}});const a={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};a.uuid=this.uuid,a.type=this.type,this.name!==""&&(a.name=this.name),this.color&&this.color.isColor&&(a.color=this.color.getHex()),this.roughness!==void 0&&(a.roughness=this.roughness),this.metalness!==void 0&&(a.metalness=this.metalness),this.sheen&&this.sheen.isColor&&(a.sheen=this.sheen.getHex()),this.emissive&&this.emissive.isColor&&(a.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(a.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(a.specular=this.specular.getHex()),this.shininess!==void 0&&(a.shininess=this.shininess),this.clearcoat!==void 0&&(a.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(a.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(a.clearcoatMap=this.clearcoatMap.toJSON(b).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(a.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(b).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(a.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(b).uuid,a.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(a.map=this.map.toJSON(b).uuid),this.matcap&&this.matcap.isTexture&&(a.matcap=this.matcap.toJSON(b).uuid),this.alphaMap&&this.alphaMap.isTexture&&(a.alphaMap=this.alphaMap.toJSON(b).uuid),this.lightMap&&this.lightMap.isTexture&&(a.lightMap=this.lightMap.toJSON(b).uuid,a.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(a.aoMap=this.aoMap.toJSON(b).uuid,a.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(a.bumpMap=this.bumpMap.toJSON(b).uuid,a.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(a.normalMap=this.normalMap.toJSON(b).uuid,a.normalMapType=this.normalMapType,a.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(a.displacementMap=this.displacementMap.toJSON(b).uuid,a.displacementScale=this.displacementScale,a.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(a.roughnessMap=this.roughnessMap.toJSON(b).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(a.metalnessMap=this.metalnessMap.toJSON(b).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(a.emissiveMap=this.emissiveMap.toJSON(b).uuid),this.specularMap&&this.specularMap.isTexture&&(a.specularMap=this.specularMap.toJSON(b).uuid),this.envMap&&this.envMap.isTexture&&(a.envMap=this.envMap.toJSON(b).uuid,this.combine!==void 0&&(a.combine=this.combine)),this.envMapIntensity!==void 0&&(a.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(a.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(a.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(a.gradientMap=this.gradientMap.toJSON(b).uuid),this.size!==void 0&&(a.size=this.size),this.shadowSide!==null&&(a.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(a.sizeAttenuation=this.sizeAttenuation),this.blending!==bg&&(a.blending=this.blending),this.side!==cl&&(a.side=this.side),this.vertexColors&&(a.vertexColors=!0),this.opacity<1&&(a.opacity=this.opacity),this.transparent===!0&&(a.transparent=this.transparent),a.depthFunc=this.depthFunc,a.depthTest=this.depthTest,a.depthWrite=this.depthWrite,a.colorWrite=this.colorWrite,a.stencilWrite=this.stencilWrite,a.stencilWriteMask=this.stencilWriteMask,a.stencilFunc=this.stencilFunc,a.stencilRef=this.stencilRef,a.stencilFuncMask=this.stencilFuncMask,a.stencilFail=this.stencilFail,a.stencilZFail=this.stencilZFail,a.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(a.rotation=this.rotation),this.polygonOffset===!0&&(a.polygonOffset=!0),this.polygonOffsetFactor!==0&&(a.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(a.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(a.linewidth=this.linewidth),this.dashSize!==void 0&&(a.dashSize=this.dashSize),this.gapSize!==void 0&&(a.gapSize=this.gapSize),this.scale!==void 0&&(a.scale=this.scale),this.dithering===!0&&(a.dithering=!0),this.alphaTest>0&&(a.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(a.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(a.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(a.wireframe=this.wireframe),this.wireframeLinewidth>1&&(a.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(a.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(a.wireframeLinejoin=this.wireframeLinejoin),this.morphTargets===!0&&(a.morphTargets=!0),this.morphNormals===!0&&(a.morphNormals=!0),this.skinning===!0&&(a.skinning=!0),this.flatShading===!0&&(a.flatShading=this.flatShading),this.visible===!1&&(a.visible=!1),this.toneMapped===!1&&(a.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(a.userData=this.userData);function d(a){const b=[];for(const d in a){const c=a[d];delete c.metadata,b.push(c)}return b}if(c){const c=d(b.textures),e=d(b.images);c.length>0&&(a.textures=c),e.length>0&&(a.images=e)}return a},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.name=a.name,this.fog=a.fog,this.blending=a.blending,this.side=a.side,this.vertexColors=a.vertexColors,this.opacity=a.opacity,this.transparent=a.transparent,this.blendSrc=a.blendSrc,this.blendDst=a.blendDst,this.blendEquation=a.blendEquation,this.blendSrcAlpha=a.blendSrcAlpha,this.blendDstAlpha=a.blendDstAlpha,this.blendEquationAlpha=a.blendEquationAlpha,this.depthFunc=a.depthFunc,this.depthTest=a.depthTest,this.depthWrite=a.depthWrite,this.stencilWriteMask=a.stencilWriteMask,this.stencilFunc=a.stencilFunc,this.stencilRef=a.stencilRef,this.stencilFuncMask=a.stencilFuncMask,this.stencilFail=a.stencilFail,this.stencilZFail=a.stencilZFail,this.stencilZPass=a.stencilZPass,this.stencilWrite=a.stencilWrite;const b=a.clippingPlanes;let c=null;if(b!==null){const a=b.length;c=new Array(a);for(let d=0;d!==a;++d)c[d]=b[d].clone()}return this.clippingPlanes=c,this.clipIntersection=a.clipIntersection,this.clipShadows=a.clipShadows,this.shadowSide=a.shadowSide,this.colorWrite=a.colorWrite,this.precision=a.precision,this.polygonOffset=a.polygonOffset,this.polygonOffsetFactor=a.polygonOffsetFactor,this.polygonOffsetUnits=a.polygonOffsetUnits,this.dithering=a.dithering,this.alphaTest=a.alphaTest,this.alphaToCoverage=a.alphaToCoverage,this.premultipliedAlpha=a.premultipliedAlpha,this.visible=a.visible,this.toneMapped=a.toneMapped,this.userData=JSON.parse(JSON.stringify(a.userData)),this},dispose:function(){this.dispatchEvent({type:"dispose"})}}),Object.defineProperty(r.prototype,"needsUpdate",{set:function(a){a===!0&&this.version++}}),dQ={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},L={h:0,s:0,l:0},cs={h:0,s:0,l:0};function dB(b,c,a){return a<0&&(a+=1),a>1&&(a-=1),a<1/6?b+(c-b)*6*a:a<1/2?c:a<2/3?b+(c-b)*6*(2/3-a):b}function dx(a){return a<.04045?a*.0773993808:Math.pow(a*.9478672986+.0521327014,2.4)}function dv(a){return a<.0031308?a*12.92:1.055*Math.pow(a,.41666)-.055}d=class{constructor(a,b,c){return b===void 0&&c===void 0?this.set(a):this.setRGB(a,b,c)}set(a){return a&&a.isColor?this.copy(a):typeof a=="number"?this.setHex(a):typeof a=="string"&&this.setStyle(a),this}setScalar(a){return this.r=a,this.g=a,this.b=a,this}setHex(a){return a=Math.floor(a),this.r=(a>>16&255)/255,this.g=(a>>8&255)/255,this.b=(a&255)/255,this}setRGB(a,b,c){return this.r=a,this.g=b,this.b=c,this}setHSL(c,b,a){if(c=lt(c,1),b=E(b,0,1),a=E(a,0,1),b===0)this.r=this.g=this.b=a;else{const d=a<=.5?a*(1+b):a+b-a*b,e=2*a-d;this.r=dB(e,d,c+1/3),this.g=dB(e,d,c),this.b=dB(e,d,c-1/3)}return this}setStyle(a){function c(b){if(b===void 0)return;parseFloat(b)<1&&console.warn("THREE.Color: Alpha component of "+a+" will be ignored.")}let b;if(b=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(a)){let a;const e=b[1],d=b[2];switch(e){case"rgb":case"rgba":if(a=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(d))return this.r=Math.min(255,parseInt(a[1],10))/255,this.g=Math.min(255,parseInt(a[2],10))/255,this.b=Math.min(255,parseInt(a[3],10))/255,c(a[4]),this;if(a=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(d))return this.r=Math.min(100,parseInt(a[1],10))/100,this.g=Math.min(100,parseInt(a[2],10))/100,this.b=Math.min(100,parseInt(a[3],10))/100,c(a[4]),this;break;case"hsl":case"hsla":if(a=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(d)){const b=parseFloat(a[1])/360,d=parseInt(a[2],10)/100,e=parseInt(a[3],10)/100;return c(a[4]),this.setHSL(b,d,e)}break}}else if(b=/^\#([A-Fa-f\d]+)$/.exec(a)){const a=b[1],c=a.length;if(c===3)return this.r=parseInt(a.charAt(0)+a.charAt(0),16)/255,this.g=parseInt(a.charAt(1)+a.charAt(1),16)/255,this.b=parseInt(a.charAt(2)+a.charAt(2),16)/255,this;if(c===6)return this.r=parseInt(a.charAt(0)+a.charAt(1),16)/255,this.g=parseInt(a.charAt(2)+a.charAt(3),16)/255,this.b=parseInt(a.charAt(4)+a.charAt(5),16)/255,this}return a&&a.length>0?this.setColorName(a):this}setColorName(a){const b=dQ[a.toLowerCase()];return b!==void 0?this.setHex(b):console.warn("THREE.Color: Unknown color "+a),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(a){return this.r=a.r,this.g=a.g,this.b=a.b,this}copyGammaToLinear(a,b=2){return this.r=Math.pow(a.r,b),this.g=Math.pow(a.g,b),this.b=Math.pow(a.b,b),this}copyLinearToGamma(a,c=2){const b=c>0?1/c:1;return this.r=Math.pow(a.r,b),this.g=Math.pow(a.g,b),this.b=Math.pow(a.b,b),this}convertGammaToLinear(a){return this.copyGammaToLinear(this,a),this}convertLinearToGamma(a){return this.copyLinearToGamma(this,a),this}copySRGBToLinear(a){return this.r=dx(a.r),this.g=dx(a.g),this.b=dx(a.b),this}copyLinearToSRGB(a){return this.r=dv(a.r),this.g=dv(a.g),this.b=dv(a.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(a){a===void 0&&(console.warn("THREE.Color: .getHSL() target is now required"),a={h:0,s:0,l:0});const f=this.r,b=this.g,c=this.b,d=Math.max(f,b,c),g=Math.min(f,b,c);let e,h;const i=(g+d)/2;if(g===d)e=0,h=0;else{const a=d-g;switch(h=i<=.5?a/(d+g):a/(2-d-g),d){case f:e=(b-c)/a+(b<c?6:0);break;case b:e=(c-f)/a+2;break;case c:e=(f-b)/a+4;break}e/=6}return a.h=e,a.s=h,a.l=i,a}getStyle(){return"rgb("+(this.r*255|0)+","+(this.g*255|0)+","+(this.b*255|0)+")"}offsetHSL(a,b,c){return this.getHSL(L),L.h+=a,L.s+=b,L.l+=c,this.setHSL(L.h,L.s,L.l),this}add(a){return this.r+=a.r,this.g+=a.g,this.b+=a.b,this}addColors(a,b){return this.r=a.r+b.r,this.g=a.g+b.g,this.b=a.b+b.b,this}addScalar(a){return this.r+=a,this.g+=a,this.b+=a,this}sub(a){return this.r=Math.max(0,this.r-a.r),this.g=Math.max(0,this.g-a.g),this.b=Math.max(0,this.b-a.b),this}multiply(a){return this.r*=a.r,this.g*=a.g,this.b*=a.b,this}multiplyScalar(a){return this.r*=a,this.g*=a,this.b*=a,this}lerp(a,b){return this.r+=(a.r-this.r)*b,this.g+=(a.g-this.g)*b,this.b+=(a.b-this.b)*b,this}lerpColors(a,b,c){return this.r=a.r+(b.r-a.r)*c,this.g=a.g+(b.g-a.g)*c,this.b=a.b+(b.b-a.b)*c,this}lerpHSL(b,a){this.getHSL(L),b.getHSL(cs);const c=cJ(L.h,cs.h,a),d=cJ(L.s,cs.s,a),e=cJ(L.l,cs.l,a);return this.setHSL(c,d,e),this}equals(a){return a.r===this.r&&a.g===this.g&&a.b===this.b}fromArray(a,b=0){return this.r=a[b],this.g=a[b+1],this.b=a[b+2],this}toArray(a=[],b=0){return a[b]=this.r,a[b+1]=this.g,a[b+2]=this.b,a}fromBufferAttribute(a,b){return this.r=a.getX(b),this.g=a.getY(b),this.b=a.getZ(b),a.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}},d.NAMES=dQ,d.prototype.isColor=!0,d.prototype.r=1,d.prototype.g=1,d.prototype.b=1,dt=class extends r{constructor(a){super(),this.type="MeshBasicMaterial",this.color=new d(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=ch,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.setValues(a)}copy(a){return super.copy(a),this.color.copy(a.color),this.map=a.map,this.lightMap=a.lightMap,this.lightMapIntensity=a.lightMapIntensity,this.aoMap=a.aoMap,this.aoMapIntensity=a.aoMapIntensity,this.specularMap=a.specularMap,this.alphaMap=a.alphaMap,this.envMap=a.envMap,this.combine=a.combine,this.reflectivity=a.reflectivity,this.refractionRatio=a.refractionRatio,this.wireframe=a.wireframe,this.wireframeLinewidth=a.wireframeLinewidth,this.wireframeLinecap=a.wireframeLinecap,this.wireframeLinejoin=a.wireframeLinejoin,this.skinning=a.skinning,this.morphTargets=a.morphTargets,this}},dt.prototype.isMeshBasicMaterial=!0,k=new a,b_=new b,u=class{constructor(a,b,c){if(Array.isArray(a))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=a,this.itemSize=b,this.count=a!==void 0?a.length/b:0,this.normalized=c===!0,this.usage=bl,this.updateRange={offset:0,count:-1},this.version=0,this.onUploadCallback=function(){}}set needsUpdate(a){a===!0&&this.version++}setUsage(a){return this.usage=a,this}copy(a){return this.name=a.name,this.array=new a.array.constructor(a.array),this.itemSize=a.itemSize,this.count=a.count,this.normalized=a.normalized,this.usage=a.usage,this}copyAt(a,b,c){a*=this.itemSize,c*=b.itemSize;for(let d=0,e=this.itemSize;d<e;d++)this.array[a+d]=b.array[c+d];return this}copyArray(a){return this.array.set(a),this}copyColorsArray(c){const a=this.array;let b=0;for(let f=0,g=c.length;f<g;f++){let e=c[f];e===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",f),e=new d),a[b++]=e.r,a[b++]=e.g,a[b++]=e.b}return this}copyVector2sArray(a){const c=this.array;let d=0;for(let e=0,g=a.length;e<g;e++){let f=a[e];f===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",e),f=new b),c[d++]=f.x,c[d++]=f.y}return this}copyVector3sArray(d){const b=this.array;let c=0;for(let f=0,g=d.length;f<g;f++){let e=d[f];e===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",f),e=new a),b[c++]=e.x,b[c++]=e.y,b[c++]=e.z}return this}copyVector4sArray(c){const a=this.array;let b=0;for(let e=0,f=c.length;e<f;e++){let d=c[e];d===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",e),d=new i),a[b++]=d.x,a[b++]=d.y,a[b++]=d.z,a[b++]=d.w}return this}applyMatrix3(a){if(this.itemSize===2)for(let b=0,c=this.count;b<c;b++)b_.fromBufferAttribute(this,b),b_.applyMatrix3(a),this.setXY(b,b_.x,b_.y);else if(this.itemSize===3)for(let b=0,c=this.count;b<c;b++)k.fromBufferAttribute(this,b),k.applyMatrix3(a),this.setXYZ(b,k.x,k.y,k.z);return this}applyMatrix4(a){for(let b=0,c=this.count;b<c;b++)k.x=this.getX(b),k.y=this.getY(b),k.z=this.getZ(b),k.applyMatrix4(a),this.setXYZ(b,k.x,k.y,k.z);return this}applyNormalMatrix(a){for(let b=0,c=this.count;b<c;b++)k.x=this.getX(b),k.y=this.getY(b),k.z=this.getZ(b),k.applyNormalMatrix(a),this.setXYZ(b,k.x,k.y,k.z);return this}transformDirection(a){for(let b=0,c=this.count;b<c;b++)k.x=this.getX(b),k.y=this.getY(b),k.z=this.getZ(b),k.transformDirection(a),this.setXYZ(b,k.x,k.y,k.z);return this}set(a,b=0){return this.array.set(a,b),this}getX(a){return this.array[a*this.itemSize]}setX(a,b){return this.array[a*this.itemSize]=b,this}getY(a){return this.array[a*this.itemSize+1]}setY(a,b){return this.array[a*this.itemSize+1]=b,this}getZ(a){return this.array[a*this.itemSize+2]}setZ(a,b){return this.array[a*this.itemSize+2]=b,this}getW(a){return this.array[a*this.itemSize+3]}setW(a,b){return this.array[a*this.itemSize+3]=b,this}setXY(a,b,c){return a*=this.itemSize,this.array[a+0]=b,this.array[a+1]=c,this}setXYZ(a,b,c,d){return a*=this.itemSize,this.array[a+0]=b,this.array[a+1]=c,this.array[a+2]=d,this}setXYZW(a,b,c,d,e){return a*=this.itemSize,this.array[a+0]=b,this.array[a+1]=c,this.array[a+2]=d,this.array[a+3]=e,this}onUpload(a){return this.onUploadCallback=a,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const a={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return this.name!==""&&(a.name=this.name),this.usage!==bl&&(a.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(a.updateRange=this.updateRange),a}},u.prototype.isBufferAttribute=!0,d$=class extends u{constructor(a,b,c){super(new Uint16Array(a),b,c)}},ea=class extends u{constructor(a,b,c){super(new Uint32Array(a),b,c)}},kG=class extends u{constructor(a,b,c){super(new Uint16Array(a),b,c)}},kG.prototype.isFloat16BufferAttribute=!0,s=class extends u{constructor(a,b,c){super(new Float32Array(a),b,c)}};function ed(a){if(a.length===0)return-(1/0);let b=a[0];for(let c=1,d=a.length;c<d;++c)a[c]>b&&(b=a[c]);return b}kF=0,V=new e,dg=new h,aV=new a,F=new H,bD=new H,q=new a,l=class extends aq{constructor(){super(),Object.defineProperty(this,"id",{value:kF++}),this.uuid=R(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(a){return Array.isArray(a)?this.index=new(ed(a)>65535?ea:d$)(a,1):this.index=a,this}getAttribute(a){return this.attributes[a]}setAttribute(a,b){return this.attributes[a]=b,this}deleteAttribute(a){return delete this.attributes[a],this}hasAttribute(a){return this.attributes[a]!==void 0}addGroup(a,b,c=0){this.groups.push({start:a,count:b,materialIndex:c})}clearGroups(){this.groups=[]}setDrawRange(a,b){this.drawRange.start=a,this.drawRange.count=b}applyMatrix4(a){const b=this.attributes.position;b!==void 0&&(b.applyMatrix4(a),b.needsUpdate=!0);const c=this.attributes.normal;if(c!==void 0){const b=(new v).getNormalMatrix(a);c.applyNormalMatrix(b),c.needsUpdate=!0}const d=this.attributes.tangent;return d!==void 0&&(d.transformDirection(a),d.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}rotateX(a){return V.makeRotationX(a),this.applyMatrix4(V),this}rotateY(a){return V.makeRotationY(a),this.applyMatrix4(V),this}rotateZ(a){return V.makeRotationZ(a),this.applyMatrix4(V),this}translate(a,b,c){return V.makeTranslation(a,b,c),this.applyMatrix4(V),this}scale(a,b,c){return V.makeScale(a,b,c),this.applyMatrix4(V),this}lookAt(a){return dg.lookAt(a),dg.updateMatrix(),this.applyMatrix4(dg.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(aV).negate(),this.translate(aV.x,aV.y,aV.z),this}setFromPoints(a){const b=[];for(let c=0,e=a.length;c<e;c++){const d=a[c];b.push(d.x,d.y,d.z||0)}return this.setAttribute("position",new s(b,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new H);const b=this.attributes.position,c=this.morphAttributes.position;if(b&&b.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new a(-(1/0),-(1/0),-(1/0)),new a(1/0,1/0,1/0));return}if(b!==void 0){if(this.boundingBox.setFromBufferAttribute(b),c)for(let a=0,b=c.length;a<b;a++){const d=c[a];F.setFromBufferAttribute(d),this.morphTargetsRelative?(q.addVectors(this.boundingBox.min,F.min),this.boundingBox.expandByPoint(q),q.addVectors(this.boundingBox.max,F.max),this.boundingBox.expandByPoint(q)):(this.boundingBox.expandByPoint(F.min),this.boundingBox.expandByPoint(F.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new aN);const b=this.attributes.position,c=this.morphAttributes.position;if(b&&b.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new a,1/0);return}if(b){const d=this.boundingSphere.center;if(F.setFromBufferAttribute(b),c)for(let a=0,b=c.length;a<b;a++){const d=c[a];bD.setFromBufferAttribute(d),this.morphTargetsRelative?(q.addVectors(F.min,bD.min),F.expandByPoint(q),q.addVectors(F.max,bD.max),F.expandByPoint(q)):(F.expandByPoint(bD.min),F.expandByPoint(bD.max))}F.getCenter(d);let a=0;for(let c=0,e=b.count;c<e;c++)q.fromBufferAttribute(b,c),a=Math.max(a,d.distanceToSquared(q));if(c)for(let e=0,g=c.length;e<g;e++){const f=c[e],h=this.morphTargetsRelative;for(let c=0,e=f.count;c<e;c++)q.fromBufferAttribute(f,c),h&&(aV.fromBufferAttribute(b,c),q.add(aV)),a=Math.max(a,d.distanceToSquared(q))}this.boundingSphere.radius=Math.sqrt(a),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeFaceNormals(){}computeTangents(){const z=this.index,c=this.attributes;if(z===null||c.position===void 0||c.normal===void 0||c.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const d=z.array,l=c.position.array,B=c.normal.array,s=c.uv.array,w=l.length/3;c.tangent===void 0&&this.setAttribute("tangent",new u(new Float32Array(4*w),4));const k=c.tangent.array,h=[],j=[];for(let b=0;b<w;b++)h[b]=new a,j[b]=new a;const t=new a,n=new a,o=new a,r=new b,f=new b,e=new b,m=new a,q=new a;function A(a,b,c){t.fromArray(l,a*3),n.fromArray(l,b*3),o.fromArray(l,c*3),r.fromArray(s,a*2),f.fromArray(s,b*2),e.fromArray(s,c*2),n.sub(t),o.sub(t),f.sub(r),e.sub(r);const d=1/(f.x*e.y-e.x*f.y);if(!isFinite(d))return;m.copy(n).multiplyScalar(e.y).addScaledVector(o,-f.y).multiplyScalar(d),q.copy(o).multiplyScalar(f.x).addScaledVector(n,-e.x).multiplyScalar(d),h[a].add(m),h[b].add(m),h[c].add(m),j[a].add(q),j[b].add(q),j[c].add(q)}let g=this.groups;g.length===0&&(g=[{start:0,count:d.length}]);for(let a=0,e=g.length;a<e;++a){const b=g[a],c=b.start,f=b.count;for(let a=c,b=c+f;a<b;a+=3)A(d[a+0],d[a+1],d[a+2])}const i=new a,x=new a,p=new a,y=new a;function v(a){p.fromArray(B,a*3),y.copy(p);const b=h[a];i.copy(b),i.sub(p.multiplyScalar(p.dot(b))).normalize(),x.crossVectors(y,b);const c=x.dot(j[a]),d=c<0?-1:1;k[a*4]=i.x,k[a*4+1]=i.y,k[a*4+2]=i.z,k[a*4+3]=d}for(let a=0,e=g.length;a<e;++a){const b=g[a],c=b.start,f=b.count;for(let a=c,b=c+f;a<b;a+=3)v(d[a+0]),v(d[a+1]),v(d[a+2])}}computeVertexNormals(){const c=this.index,b=this.getAttribute("position");if(b!==void 0){let e=this.getAttribute("normal");if(e===void 0)e=new u(new Float32Array(b.count*3),3),this.setAttribute("normal",e);else for(let a=0,b=e.count;a<b;a++)e.setXYZ(a,0,0,0);const k=new a,f=new a,j=new a,g=new a,h=new a,i=new a,d=new a,l=new a;if(c)for(let a=0,p=c.count;a<p;a+=3){const m=c.getX(a+0),n=c.getX(a+1),o=c.getX(a+2);k.fromBufferAttribute(b,m),f.fromBufferAttribute(b,n),j.fromBufferAttribute(b,o),d.subVectors(j,f),l.subVectors(k,f),d.cross(l),g.fromBufferAttribute(e,m),h.fromBufferAttribute(e,n),i.fromBufferAttribute(e,o),g.add(d),h.add(d),i.add(d),e.setXYZ(m,g.x,g.y,g.z),e.setXYZ(n,h.x,h.y,h.z),e.setXYZ(o,i.x,i.y,i.z)}else for(let a=0,c=b.count;a<c;a+=3)k.fromBufferAttribute(b,a+0),f.fromBufferAttribute(b,a+1),j.fromBufferAttribute(b,a+2),d.subVectors(j,f),l.subVectors(k,f),d.cross(l),e.setXYZ(a+0,d.x,d.y,d.z),e.setXYZ(a+1,d.x,d.y,d.z),e.setXYZ(a+2,d.x,d.y,d.z);this.normalizeNormals(),e.needsUpdate=!0}}merge(a,b){if(!(a&&a.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",a);return}b===void 0&&(b=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const c=this.attributes;for(const d in c){if(a.attributes[d]===void 0)continue;const i=c[d],e=i.array,f=a.attributes[d],g=f.array,h=f.itemSize*b,j=Math.min(g.length,e.length-h);for(let a=0,b=h;a<j;a++,b++)e[b]=g[a]}return this}normalizeNormals(){const a=this.attributes.normal;for(let b=0,c=a.count;b<c;b++)q.fromBufferAttribute(a,b),q.normalize(),a.setXYZ(b,q.x,q.y,q.z)}toNonIndexed(){function b(b,c){const d=b.array,a=b.itemSize,g=b.normalized,e=new d.constructor(c.length*a);let f=0,h=0;for(let b=0,g=c.length;b<g;b++){f=c[b]*a;for(let b=0;b<a;b++)e[h++]=d[f++]}return new u(e,a,g)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const a=new l,c=this.index.array,d=this.attributes;for(const e in d){const f=d[e],g=b(f,c);a.setAttribute(e,g)}const e=this.morphAttributes;for(const d in e){const f=[],g=e[d];for(let a=0,d=g.length;a<d;a++){const e=g[a],h=b(e,c);f.push(h)}a.morphAttributes[d]=f}a.morphTargetsRelative=this.morphTargetsRelative;const f=this.groups;for(let b=0,d=f.length;b<d;b++){const c=f[b];a.addGroup(c.start,c.count,c.materialIndex)}return a}toJSON(){const a={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(a.uuid=this.uuid,a.type=this.type,this.name!==""&&(a.name=this.name),Object.keys(this.userData).length>0&&(a.userData=this.userData),this.parameters!==void 0){const b=this.parameters;for(const c in b)b[c]!==void 0&&(a[c]=b[c]);return a}a.data={attributes:{}};const b=this.index;b!==null&&(a.data.index={type:b.array.constructor.name,array:Array.prototype.slice.call(b.array)});const d=this.attributes;for(const b in d){const c=d[b];a.data.attributes[b]=c.toJSON(a.data)}const e={};let f=!1;for(const c in this.morphAttributes){const d=this.morphAttributes[c],b=[];for(let c=0,e=d.length;c<e;c++){const f=d[c];b.push(f.toJSON(a.data))}b.length>0&&(e[c]=b,f=!0)}f&&(a.data.morphAttributes=e,a.data.morphTargetsRelative=this.morphTargetsRelative);const g=this.groups;g.length>0&&(a.data.groups=JSON.parse(JSON.stringify(g)));const c=this.boundingSphere;return c!==null&&(a.data.boundingSphere={center:c.center.toArray(),radius:c.radius}),a}clone(){return(new l).copy(this)}copy(a){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const b={};this.name=a.name;const c=a.index;c!==null&&this.setIndex(c.clone(b));const d=a.attributes;for(const a in d){const c=d[a];this.setAttribute(a,c.clone(b))}const e=a.morphAttributes;for(const a in e){const c=[],d=e[a];for(let a=0,e=d.length;a<e;a++)c.push(d[a].clone(b));this.morphAttributes[a]=c}this.morphTargetsRelative=a.morphTargetsRelative;const f=a.groups;for(let a=0,c=f.length;a<c;a++){const b=f[a];this.addGroup(b.start,b.count,b.materialIndex)}const g=a.boundingBox;g!==null&&(this.boundingBox=g.clone());const h=a.boundingSphere;return h!==null&&(this.boundingSphere=h.clone()),this.drawRange.start=a.drawRange.start,this.drawRange.count=a.drawRange.count,this.userData=a.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}},l.prototype.isBufferGeometry=!0,em=new e,aZ=new aG,cR=new aN,ai=new a,ag=new a,af=new a,cX=new a,c_=new a,db=new a,bL=new a,bQ=new a,ce=new a,bT=new b,bW=new b,bX=new b,dl=new a,ca=new a,K=class extends h{constructor(a=new l,b=new dt){super(),this.type="Mesh",this.geometry=a,this.material=b,this.updateMorphTargets()}copy(a){return super.copy(a),a.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=a.morphTargetInfluences.slice()),a.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},a.morphTargetDictionary)),this.material=a.material,this.geometry=a.geometry,this}updateMorphTargets(){const a=this.geometry;if(a.isBufferGeometry){{const b=a.morphAttributes,c=Object.keys(b);if(c.length>0){const a=b[c[0]];if(a!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let b=0,c=a.length;b<c;b++){const d=a[b].name||String(b);this.morphTargetInfluences.push(0),this.morphTargetDictionary[d]=b}}}}}else{const b=a.morphTargets;b!==void 0&&b.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(d,e){const b=this.geometry,c=this.material,f=this.matrixWorld;if(c===void 0)return;if(b.boundingSphere===null&&b.computeBoundingSphere(),cR.copy(b.boundingSphere),cR.applyMatrix4(f),d.ray.intersectsSphere(cR)===!1)return;if(em.copy(f).invert(),aZ.copy(d.ray).applyMatrix4(em),b.boundingBox!==null)if(aZ.intersectsBox(b.boundingBox)===!1)return;let a;if(b.isBufferGeometry){{const g=b.index,h=b.attributes.position,i=b.morphAttributes.position,j=b.morphTargetsRelative,k=b.attributes.uv,l=b.attributes.uv2,m=b.groups,f=b.drawRange;if(g!==null){if(Array.isArray(c)){for(let n=0,o=m.length;n<o;n++){const b=m[n],p=c[b.materialIndex],q=Math.max(b.start,f.start),r=Math.min(b.start+b.count,f.start+f.count);for(let c=q,f=r;c<f;c+=3){const m=g.getX(c),n=g.getX(c+1),o=g.getX(c+2);a=cj(this,p,d,aZ,h,i,j,k,l,m,n,o),a&&(a.faceIndex=Math.floor(c/3),a.face.materialIndex=b.materialIndex,e.push(a))}}}else{const b=Math.max(0,f.start),m=Math.min(g.count,f.start+f.count);for(let f=b,n=m;f<n;f+=3){const o=g.getX(f),p=g.getX(f+1),q=g.getX(f+2);a=cj(this,c,d,aZ,h,i,j,k,l,o,p,q),a&&(a.faceIndex=Math.floor(f/3),e.push(a))}}}else if(h!==void 0)if(Array.isArray(c)){for(let g=0,n=m.length;g<n;g++){const b=m[g],o=c[b.materialIndex],p=Math.max(b.start,f.start),q=Math.min(b.start+b.count,f.start+f.count);for(let c=p,f=q;c<f;c+=3){const g=c,m=c+1,n=c+2;a=cj(this,o,d,aZ,h,i,j,k,l,g,m,n),a&&(a.faceIndex=Math.floor(c/3),a.face.materialIndex=b.materialIndex,e.push(a))}}}else{const b=Math.max(0,f.start),g=Math.min(h.count,f.start+f.count);for(let f=b,m=g;f<m;f+=3){const n=f,o=f+1,p=f+2;a=cj(this,c,d,aZ,h,i,j,k,l,n,o,p),a&&(a.faceIndex=Math.floor(f/3),e.push(a))}}}}else b.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}},K.prototype.isMesh=!0;function kE(e,i,b,j,f,g,h,a){let d;if(i.side===t?d=j.intersectTriangle(h,g,f,!0,a):d=j.intersectTriangle(f,g,h,i.side!==bj,a),d===null)return null;ca.copy(a),ca.applyMatrix4(e.matrixWorld);const c=b.ray.origin.distanceTo(ca);return c<b.near||c>b.far?null:{distance:c,point:ca.clone(),object:e}}function cj(c,k,o,n,l,j,q,h,i,f,e,d){ai.fromBufferAttribute(l,f),ag.fromBufferAttribute(l,e),af.fromBufferAttribute(l,d);const m=c.morphTargetInfluences;if(k.morphTargets&&j&&m){bL.set(0,0,0),bQ.set(0,0,0),ce.set(0,0,0);for(let b=0,g=j.length;b<g;b++){const a=m[b],c=j[b];if(a===0)continue;cX.fromBufferAttribute(c,f),c_.fromBufferAttribute(c,e),db.fromBufferAttribute(c,d),q?(bL.addScaledVector(cX,a),bQ.addScaledVector(c_,a),ce.addScaledVector(db,a)):(bL.addScaledVector(cX.sub(ai),a),bQ.addScaledVector(c_.sub(ag),a),ce.addScaledVector(db.sub(af),a))}ai.add(bL),ag.add(bQ),af.add(ce)}c.isSkinnedMesh&&k.skinning&&(c.boneTransform(f,ai),c.boneTransform(e,ag),c.boneTransform(d,af));const g=kE(c,k,o,n,ai,ag,af,dl);if(g){h&&(bT.fromBufferAttribute(h,f),bW.fromBufferAttribute(h,e),bX.fromBufferAttribute(h,d),g.uv=p.getUV(dl,ai,ag,af,bT,bW,bX,new b)),i&&(bT.fromBufferAttribute(i,f),bW.fromBufferAttribute(i,e),bX.fromBufferAttribute(i,d),g.uv2=p.getUV(dl,ai,ag,af,bT,bW,bX,new b));const c={a:f,b:e,c:d,normal:new a,materialIndex:0};p.getNormal(ai,ag,af,c.normal),g.face=c}return g}dC=class extends l{constructor(b=1,c=1,d=1,e=1,f=1,g=1){super(),this.type="BoxGeometry",this.parameters={width:b,height:c,depth:d,widthSegments:e,heightSegments:f,depthSegments:g};const o=this;e=Math.floor(e),f=Math.floor(f),g=Math.floor(g);const j=[],l=[],m=[],k=[];let i=0,n=0;h("z","y","x",-1,-1,d,c,b,g,f,0),h("z","y","x",1,-1,d,c,-b,g,f,1),h("x","z","y",1,1,b,d,c,e,g,2),h("x","z","y",1,-1,b,d,-c,e,g,3),h("x","y","z",1,-1,b,c,d,e,f,4),h("x","y","z",-1,-1,b,c,-d,e,f,5),this.setIndex(j),this.setAttribute("position",new s(l,3)),this.setAttribute("normal",new s(m,3)),this.setAttribute("uv",new s(k,2));function h(t,g,r,B,A,h,p,q,d,e,C){const y=h/d,u=p/e,v=h/2,w=p/2,x=q/2,c=d+1,z=e+1;let s=0,f=0;const b=new a;for(let a=0;a<z;a++){const f=a*u-w;for(let h=0;h<c;h++){const i=h*y-v;b[t]=i*B,b[g]=f*A,b[r]=x,l.push(b.x,b.y,b.z),b[t]=0,b[g]=0,b[r]=q>0?1:-1,m.push(b.x,b.y,b.z),k.push(h/d),k.push(1-a/e),s+=1}}for(let a=0;a<e;a++)for(let b=0;b<d;b++){const h=i+b+c*a,e=i+b+c*(a+1),k=i+(b+1)+c*(a+1),g=i+(b+1)+c*a;j.push(h,e,g),j.push(e,k,g),f+=6}o.addGroup(n,f,C),n+=f,i+=s}}};function aI(b){const a={};for(const c in b){a[c]={};for(const e in b[c]){const d=b[c][e];d&&(d.isColor||d.isMatrix3||d.isMatrix4||d.isVector2||d.isVector3||d.isVector4||d.isTexture||d.isQuaternion)?a[c][e]=d.clone():Array.isArray(d)?a[c][e]=d.slice():a[c][e]=d}}return a}function x(a){const b={};for(let c=0;c<a.length;c++){const d=aI(a[c]);for(const a in d)b[a]=d[a]}return b}kC={clone:aI,merge:x},kB="void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",kA="void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",ak=class extends r{constructor(a){super(),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=kB,this.fragmentShader=kA,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,a!==void 0&&(a.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(a))}copy(a){return super.copy(a),this.fragmentShader=a.fragmentShader,this.vertexShader=a.vertexShader,this.uniforms=aI(a.uniforms),this.defines=Object.assign({},a.defines),this.wireframe=a.wireframe,this.wireframeLinewidth=a.wireframeLinewidth,this.lights=a.lights,this.clipping=a.clipping,this.skinning=a.skinning,this.morphTargets=a.morphTargets,this.morphNormals=a.morphNormals,this.extensions=Object.assign({},a.extensions),this.glslVersion=a.glslVersion,this}toJSON(c){const a=super.toJSON(c);a.glslVersion=this.glslVersion,a.uniforms={};for(const d in this.uniforms){const e=this.uniforms[d],b=e.value;b&&b.isTexture?a.uniforms[d]={type:"t",value:b.toJSON(c).uuid}:b&&b.isColor?a.uniforms[d]={type:"c",value:b.getHex()}:b&&b.isVector2?a.uniforms[d]={type:"v2",value:b.toArray()}:b&&b.isVector3?a.uniforms[d]={type:"v3",value:b.toArray()}:b&&b.isVector4?a.uniforms[d]={type:"v4",value:b.toArray()}:b&&b.isMatrix3?a.uniforms[d]={type:"m3",value:b.toArray()}:b&&b.isMatrix4?a.uniforms[d]={type:"m4",value:b.toArray()}:a.uniforms[d]={value:b}}Object.keys(this.defines).length>0&&(a.defines=this.defines),a.vertexShader=this.vertexShader,a.fragmentShader=this.fragmentShader;const b={};for(const a in this.extensions)this.extensions[a]===!0&&(b[a]=!0);return Object.keys(b).length>0&&(a.extensions=b),a}},ak.prototype.isShaderMaterial=!0,dk=class extends h{constructor(){super(),this.type="Camera",this.matrixWorldInverse=new e,this.projectionMatrix=new e,this.projectionMatrixInverse=new e}copy(a,b){return super.copy(a,b),this.matrixWorldInverse.copy(a.matrixWorldInverse),this.projectionMatrix.copy(a.projectionMatrix),this.projectionMatrixInverse.copy(a.projectionMatrixInverse),this}getWorldDirection(b){b===void 0&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),b=new a),this.updateWorldMatrix(!0,!1);const c=this.matrixWorld.elements;return b.set(-c[8],-c[9],-c[10]).normalize()}updateMatrixWorld(a){super.updateMatrixWorld(a),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(a,b){super.updateWorldMatrix(a,b),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}},dk.prototype.isCamera=!0,D=class extends dk{constructor(a=50,b=1,c=.1,d=2e3){super(),this.type="PerspectiveCamera",this.fov=a,this.zoom=1,this.near=c,this.far=d,this.focus=10,this.aspect=b,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(a,b){return super.copy(a,b),this.fov=a.fov,this.zoom=a.zoom,this.near=a.near,this.far=a.far,this.focus=a.focus,this.aspect=a.aspect,this.view=a.view===null?null:Object.assign({},a.view),this.filmGauge=a.filmGauge,this.filmOffset=a.filmOffset,this}setFocalLength(a){const b=.5*this.getFilmHeight()/a;this.fov=cL*2*Math.atan(b),this.updateProjectionMatrix()}getFocalLength(){const a=Math.tan(cB*.5*this.fov);return.5*this.getFilmHeight()/a}getEffectiveFOV(){return cL*2*Math.atan(Math.tan(cB*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(a,b,c,d,e,f){this.aspect=a/b,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=a,this.view.fullHeight=b,this.view.offsetX=c,this.view.offsetY=d,this.view.width=e,this.view.height=f,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const f=this.near;let b=f*Math.tan(cB*.5*this.fov)/this.zoom,c=2*b,d=this.aspect*c,e=-.5*d;const a=this.view;if(this.view!==null&&this.view.enabled){const f=a.fullWidth,g=a.fullHeight;e+=a.offsetX*d/f,b-=a.offsetY*c/g,d*=a.width/f,c*=a.height/g}const g=this.filmOffset;g!==0&&(e+=f*g/this.getFilmWidth()),this.projectionMatrix.makePerspective(e,e+d,b,b-c,f,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(b){const a=super.toJSON(b);return a.object.fov=this.fov,a.object.zoom=this.zoom,a.object.near=this.near,a.object.far=this.far,a.object.focus=this.focus,a.object.aspect=this.aspect,this.view!==null&&(a.object.view=Object.assign({},this.view)),a.object.filmGauge=this.filmGauge,a.object.filmOffset=this.filmOffset,a}},D.prototype.isPerspectiveCamera=!0,aL=90,aw=1,dH=class extends h{constructor(b,c,j){if(super(),this.type="CubeCamera",j.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=j;const e=new D(aL,aw,b,c);e.layers=this.layers,e.up.set(0,-1,0),e.lookAt(new a(1,0,0)),this.add(e);const f=new D(aL,aw,b,c);f.layers=this.layers,f.up.set(0,-1,0),f.lookAt(new a(-1,0,0)),this.add(f);const g=new D(aL,aw,b,c);g.layers=this.layers,g.up.set(0,0,1),g.lookAt(new a(0,1,0)),this.add(g);const h=new D(aL,aw,b,c);h.layers=this.layers,h.up.set(0,0,-1),h.lookAt(new a(0,-1,0)),this.add(h);const i=new D(aL,aw,b,c);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new a(0,0,1)),this.add(i);const d=new D(aL,aw,b,c);d.layers=this.layers,d.up.set(0,-1,0),d.lookAt(new a(0,0,-1)),this.add(d)}update(a,c){this.parent===null&&this.updateMatrixWorld();const b=this.renderTarget,[d,e,f,g,h,i]=this.children,j=a.xr.enabled,k=a.getRenderTarget();a.xr.enabled=!1;const l=b.texture.generateMipmaps;b.texture.generateMipmaps=!1,a.setRenderTarget(b,0),a.render(c,d),a.setRenderTarget(b,1),a.render(c,e),a.setRenderTarget(b,2),a.render(c,f),a.setRenderTarget(b,3),a.render(c,g),a.setRenderTarget(b,4),a.render(c,h),b.texture.generateMipmaps=l,a.setRenderTarget(b,5),a.render(c,i),a.setRenderTarget(k),a.xr.enabled=j}},cu=class extends y{constructor(a,b,d,e,f,g,c,h,i,j){a=a!==void 0?a:[],b=b!==void 0?b:de,c=c!==void 0?c:av,super(a,b,d,e,f,g,c,h,i,j),this._needsFlipEnvMap=!0,this.flipY=!1}get images(){return this.image}set images(a){this.image=a}},cu.prototype.isCubeTexture=!0,eT=class extends ap{constructor(b,a,c){Number.isInteger(a)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),a=c),super(b,b,a),a=a||{},this.texture=new cu(void 0,a.mapping,a.wrapS,a.wrapT,a.magFilter,a.minFilter,a.format,a.type,a.anisotropy,a.encoding),this.texture.generateMipmaps=a.generateMipmaps!==void 0&&a.generateMipmaps,this.texture.minFilter=a.minFilter!==void 0?a.minFilter:I,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(e,a){this.texture.type=a.type,this.texture.format=N,this.texture.encoding=a.encoding,this.texture.generateMipmaps=a.generateMipmaps,this.texture.minFilter=a.minFilter,this.texture.magFilter=a.magFilter;const b={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},f=new dC(5,5,5),d=new ak({name:"CubemapFromEquirect",uniforms:aI(b.uniforms),vertexShader:b.vertexShader,fragmentShader:b.fragmentShader,side:t,blending:be});d.uniforms.tEquirect.value=a;const c=new K(f,d),g=a.minFilter;a.minFilter===dD&&(a.minFilter=I);const h=new dH(1,10,this);return h.update(e,c),a.minFilter=g,c.geometry.dispose(),c.material.dispose(),this}clear(a,b,c,d){const e=a.getRenderTarget();for(let e=0;e<6;e++)a.setRenderTarget(this,e),a.clear(b,c,d);a.setRenderTarget(e)}},eT.prototype.isWebGLCubeRenderTarget=!0,eU=class extends y{constructor(c,d,i,j,e,f,g,h,a,b,k,l){super(null,f,g,h,a,b,j,e,k,l),this.image={data:c||null,width:d||1,height:i||1},this.magFilter=a!==void 0?a:A,this.minFilter=b!==void 0?b:A,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}},eU.prototype.isDataTexture=!0,aK=new aN,co=new a,cm=class{constructor(a=new U,b=new U,c=new U,d=new U,e=new U,f=new U){this.planes=[a,b,c,d,e,f]}set(g,b,c,d,e,f){const a=this.planes;return a[0].copy(g),a[1].copy(b),a[2].copy(c),a[3].copy(d),a[4].copy(e),a[5].copy(f),this}copy(a){const b=this.planes;for(let c=0;c<6;c++)b[c].copy(a.planes[c]);return this}setFromProjectionMatrix(s){const c=this.planes,a=s.elements,o=a[0],k=a[1],j=a[2],b=a[3],h=a[4],i=a[5],g=a[6],e=a[7],l=a[8],m=a[9],n=a[10],d=a[11],p=a[12],q=a[13],r=a[14],f=a[15];return c[0].setComponents(b-o,e-h,d-l,f-p).normalize(),c[1].setComponents(b+o,e+h,d+l,f+p).normalize(),c[2].setComponents(b+k,e+i,d+m,f+q).normalize(),c[3].setComponents(b-k,e-i,d-m,f-q).normalize(),c[4].setComponents(b-j,e-g,d-n,f-r).normalize(),c[5].setComponents(b+j,e+g,d+n,f+r).normalize(),this}intersectsObject(b){const a=b.geometry;return a.boundingSphere===null&&a.computeBoundingSphere(),aK.copy(a.boundingSphere).applyMatrix4(b.matrixWorld),this.intersectsSphere(aK)}intersectsSprite(a){return aK.center.set(0,0,0),aK.radius=.7071067811865476,aK.applyMatrix4(a.matrixWorld),this.intersectsSphere(aK)}intersectsSphere(a){const b=this.planes,c=a.center,d=-a.radius;for(let a=0;a<6;a++){const e=b[a].distanceToPoint(c);if(e<d)return!1}return!0}intersectsBox(a){const b=this.planes;for(let d=0;d<6;d++){const c=b[d];if(co.x=c.normal.x>0?a.max.x:a.min.x,co.y=c.normal.y>0?a.max.y:a.min.y,co.z=c.normal.z>0?a.max.z:a.min.z,c.distanceToPoint(co)<0)return!1}return!0}containsPoint(a){const b=this.planes;for(let c=0;c<6;c++)if(b[c].distanceToPoint(a)<0)return!1;return!0}clone(){return(new this.constructor).copy(this)}};function eY(){let a=null,b=!1,c=null,d=null;function e(b,f){c(b,f),d=a.requestAnimationFrame(e)}return{start:function(){if(b===!0)return;if(c===null)return;d=a.requestAnimationFrame(e),b=!0},stop:function(){a.cancelAnimationFrame(d),b=!1},setAnimationLoop:function(a){c=a},setContext:function(b){a=b}}}function kz(a,d){const c=d.isWebGL2,b=new WeakMap;function e(e,f){const b=e.array,h=e.usage,g=a.createBuffer();a.bindBuffer(f,g),a.bufferData(f,b,h),e.onUploadCallback();let d=5126;return b instanceof Float32Array?d=5126:b instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):b instanceof Uint16Array?e.isFloat16BufferAttribute?c?d=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):d=5123:b instanceof Int16Array?d=5122:b instanceof Uint32Array?d=5125:b instanceof Int32Array?d=5124:b instanceof Int8Array?d=5120:b instanceof Uint8Array&&(d=5121),{buffer:g,type:d,bytesPerElement:b.BYTES_PER_ELEMENT,version:e.version}}function f(g,f,e){const d=f.array,b=f.updateRange;a.bindBuffer(e,g),b.count===-1?a.bufferSubData(e,0,d):(c?a.bufferSubData(e,b.offset*d.BYTES_PER_ELEMENT,d,b.offset,b.count):a.bufferSubData(e,b.offset*d.BYTES_PER_ELEMENT,d.subarray(b.offset,b.offset+b.count)),b.count=-1)}function g(a){return a.isInterleavedBufferAttribute&&(a=a.data),b.get(a)}function h(c){c.isInterleavedBufferAttribute&&(c=c.data);const d=b.get(c);d&&(a.deleteBuffer(d.buffer),b.delete(c))}function i(a,d){if(a.isGLBufferAttribute){const c=b.get(a);(!c||c.version<a.version)&&b.set(a,{buffer:a.buffer,type:a.type,bytesPerElement:a.elementSize,version:a.version});return}a.isInterleavedBufferAttribute&&(a=a.data);const c=b.get(a);c===void 0?b.set(a,e(a,d)):c.version<a.version&&(f(c.buffer,a,d),c.version=a.version)}return{get:g,remove:h,update:i}}e_=class extends l{constructor(f=1,d=1,h=1,j=1){super(),this.type="PlaneGeometry",this.parameters={width:f,height:d,widthSegments:h,heightSegments:j};const o=f/2,n=d/2,b=Math.floor(h),c=Math.floor(j),a=b+1,p=c+1,l=f/b,m=d/c,e=[],i=[],k=[],g=[];for(let d=0;d<p;d++){const e=d*m-n;for(let f=0;f<a;f++){const h=f*l-o;i.push(h,-e,0),k.push(0,0,1),g.push(f/b),g.push(1-d/c)}}for(let d=0;d<c;d++)for(let c=0;c<b;c++){const h=c+a*d,f=c+a*(d+1),i=c+1+a*(d+1),g=c+1+a*d;e.push(h,f,g),e.push(f,i,g)}this.setIndex(e),this.setAttribute("position",new s(i,3)),this.setAttribute("normal",new s(k,3)),this.setAttribute("uv",new s(g,2))}},ot="#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",kw="#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",ku="#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif",kt="#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif",ks="#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif",kr="vec3 transformed = vec3( position );",kp="vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif",ko="vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	return vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n#else\n	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n	}\n	return 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n	return Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + viewDir );\n	float dotNL = saturate( dot( normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	return specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	vec3 FssEss = F * brdf.x + brdf.y;\n	float Ess = brdf.x + brdf.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n	float invAlpha = 1.0 / roughness;\n	float cos2h = NoH * NoH;\n	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n	vec3 N = geometry.normal;\n	vec3 V = geometry.viewDir;\n	vec3 H = normalize( V + L );\n	float dotNH = saturate( dot( N, H ) );\n	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",kn="#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif",km="#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif",kl="#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",kk="#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif",kj="#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif",ki="#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif",kh="#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif",kg="#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif",kf="#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif",ke="#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}",kd="#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif",kc="vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif",kb="#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif",ka="#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",j$="#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif",j_="#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif",jZ="gl_FragColor = linearToOutputTexel( gl_FragColor );",jY="\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}",jW="#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifndef ENVMAP_TYPE_CUBE_UV\n		envColor = envMapTexelToLinear( envColor );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif",jS="#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif",jQ="#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif",jP="#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif",jL="#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif",jI="#ifdef USE_FOG\n	fogDepth = - mvPosition.z;\n#endif",jH="#ifdef USE_FOG\n	varying float fogDepth;\n#endif",jF="#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",jy="#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float fogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif",jo="#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}",jn="#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",jl="#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif",jh="vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif",jf="uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( angleCos > spotLight.coneCos ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif",je="#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float sigma = PI * roughness * roughness / ( 1.0 + roughness );\n		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n		#else\n			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif",jd="ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",iZ="varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)",iY="BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",iX="varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)",iU="PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheen;\n#endif",iT="struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float specularRoughness;\n	vec3 specularColor;\n#ifdef CLEARCOAT\n	float clearcoat;\n	float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	vec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifdef CLEARCOAT\n		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = ccDotNL * directLight.color;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			ccIrradiance *= PI;\n		#endif\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n			material.specularRoughness,\n			directLight.direction,\n			geometry,\n			material.sheenColor\n		);\n	#else\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n	#endif\n	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef CLEARCOAT\n		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n		float ccDotNL = ccDotNV;\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	float clearcoatInv = 1.0 - clearcoatDHR;\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",iR="\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif",iQ="#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n	#ifdef CLEARCOAT\n		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n	#endif\n#endif",iO="#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",h_="#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",hZ="#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif",hY="#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif",hX="#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif",hW="#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif",hV="#ifdef USE_MAP\n	uniform sampler2D map;\n#endif",hU="#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",hT="#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",hS="float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif",hR="#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif",hO="#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",hN="#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifndef USE_MORPHNORMALS\n		uniform float morphTargetInfluences[ 8 ];\n	#else\n		uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif",hM="#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n	transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n	transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n	transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n		transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n		transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n		transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n		transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n	#endif\n#endif",hx="float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;",hw="#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",hv="#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif",gR="#ifdef CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif",go="#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif",nC="#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif",gp="vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",gq="#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif",gr="vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",gs="#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",gt="#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif",gu="float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif",gv="#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif",gw="#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif",gx="#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif",gy="#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif",gz="float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}",gA="#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",gB="#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif",gC="#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",gD="#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif",gE="float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif",gF="#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif",gG="#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",gH="#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",gI="#ifdef USE_TRANSMISSIONMAP\n	totalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",gJ="#ifdef USE_TRANSMISSIONMAP\n	uniform sampler2D transmissionMap;\n#endif",gK="#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif",gL="#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif",gM="#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",gN="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif",gO="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif",gP="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",gQ="#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif",iP="uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",gS="varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}",gT="#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",gU="varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}",gV="#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}",gW="#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}",gX="#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}",gY="#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}",gZ="uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",g_="varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}",g$="uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",ha="uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}",hb="uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n	\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",hc="#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}",hd="uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",he="#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",hf="#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",hg="#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#ifndef FLAT_SHADED\n		vNormal = normalize( transformedNormal );\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}",hh="#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",hi="#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",hj="#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",hk="#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",hl="#define STANDARD\n#ifdef PHYSICAL\n	#define REFLECTIVITY\n	#define CLEARCOAT\n	#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n	uniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n	uniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#ifdef TRANSMISSION\n		float totalTransmission = transmission;\n	#endif\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <transmissionmap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#ifdef TRANSMISSION\n		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n	#endif\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",hm="#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",hn="#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",ho="#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}",hp="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",hq="uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}",hr="uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}",hs="#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",ht="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}",hu="uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}",f={alphamap_fragment:ot,alphamap_pars_fragment:kw,alphatest_fragment:ku,aomap_fragment:kt,aomap_pars_fragment:ks,begin_vertex:kr,beginnormal_vertex:kp,bsdfs:ko,bumpmap_pars_fragment:kn,clipping_planes_fragment:km,clipping_planes_pars_fragment:kl,clipping_planes_pars_vertex:kk,clipping_planes_vertex:kj,color_fragment:ki,color_pars_fragment:kh,color_pars_vertex:kg,color_vertex:kf,common:ke,cube_uv_reflection_fragment:kd,defaultnormal_vertex:kc,displacementmap_pars_vertex:kb,displacementmap_vertex:ka,emissivemap_fragment:j$,emissivemap_pars_fragment:j_,encodings_fragment:jZ,encodings_pars_fragment:jY,envmap_fragment:jW,envmap_common_pars_fragment:jS,envmap_pars_fragment:jQ,envmap_pars_vertex:jP,envmap_physical_pars_fragment:je,envmap_vertex:jL,fog_vertex:jI,fog_pars_vertex:jH,fog_fragment:jF,fog_pars_fragment:jy,gradientmap_pars_fragment:jo,lightmap_fragment:jn,lightmap_pars_fragment:jl,lights_lambert_vertex:jh,lights_pars_begin:jf,lights_toon_fragment:jd,lights_toon_pars_fragment:iZ,lights_phong_fragment:iY,lights_phong_pars_fragment:iX,lights_physical_fragment:iU,lights_physical_pars_fragment:iT,lights_fragment_begin:iR,lights_fragment_maps:iQ,lights_fragment_end:iO,logdepthbuf_fragment:h_,logdepthbuf_pars_fragment:hZ,logdepthbuf_pars_vertex:hY,logdepthbuf_vertex:hX,map_fragment:hW,map_pars_fragment:hV,map_particle_fragment:hU,map_particle_pars_fragment:hT,metalnessmap_fragment:hS,metalnessmap_pars_fragment:hR,morphnormal_vertex:hO,morphtarget_pars_vertex:hN,morphtarget_vertex:hM,normal_fragment_begin:hx,normal_fragment_maps:hw,normalmap_pars_fragment:hv,clearcoat_normal_fragment_begin:gR,clearcoat_normal_fragment_maps:go,clearcoat_pars_fragment:nC,packing:gp,premultiplied_alpha_fragment:gq,project_vertex:gr,dithering_fragment:gs,dithering_pars_fragment:gt,roughnessmap_fragment:gu,roughnessmap_pars_fragment:gv,shadowmap_pars_fragment:gw,shadowmap_pars_vertex:gx,shadowmap_vertex:gy,shadowmask_pars_fragment:gz,skinbase_vertex:gA,skinning_pars_vertex:gB,skinning_vertex:gC,skinnormal_vertex:gD,specularmap_fragment:gE,specularmap_pars_fragment:gF,tonemapping_fragment:gG,tonemapping_pars_fragment:gH,transmissionmap_fragment:gI,transmissionmap_pars_fragment:gJ,uv_pars_fragment:gK,uv_pars_vertex:gL,uv_vertex:gM,uv2_pars_fragment:gN,uv2_pars_vertex:gO,uv2_vertex:gP,worldpos_vertex:gQ,background_frag:iP,background_vert:gS,cube_frag:gT,cube_vert:gU,depth_frag:gV,depth_vert:gW,distanceRGBA_frag:gX,distanceRGBA_vert:gY,equirect_frag:gZ,equirect_vert:g_,linedashed_frag:g$,linedashed_vert:ha,meshbasic_frag:hb,meshbasic_vert:hc,meshlambert_frag:hd,meshlambert_vert:he,meshmatcap_frag:hf,meshmatcap_vert:hg,meshtoon_frag:hh,meshtoon_vert:hi,meshphong_frag:hj,meshphong_vert:hk,meshphysical_frag:hl,meshphysical_vert:hm,normal_frag:hn,normal_vert:ho,points_frag:hp,points_vert:hq,shadow_frag:hr,shadow_vert:hs,sprite_frag:ht,sprite_vert:hu},c={common:{diffuse:{value:new d(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new v},uv2Transform:{value:new v},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new b(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new d(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new d(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new v}},sprite:{diffuse:{value:new d(15658734)},opacity:{value:1},center:{value:new b(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new v}}},W={basic:{uniforms:x([c.common,c.specularmap,c.envmap,c.aomap,c.lightmap,c.fog]),vertexShader:f.meshbasic_vert,fragmentShader:f.meshbasic_frag},lambert:{uniforms:x([c.common,c.specularmap,c.envmap,c.aomap,c.lightmap,c.emissivemap,c.fog,c.lights,{emissive:{value:new d(0)}}]),vertexShader:f.meshlambert_vert,fragmentShader:f.meshlambert_frag},phong:{uniforms:x([c.common,c.specularmap,c.envmap,c.aomap,c.lightmap,c.emissivemap,c.bumpmap,c.normalmap,c.displacementmap,c.fog,c.lights,{emissive:{value:new d(0)},specular:{value:new d(1118481)},shininess:{value:30}}]),vertexShader:f.meshphong_vert,fragmentShader:f.meshphong_frag},standard:{uniforms:x([c.common,c.envmap,c.aomap,c.lightmap,c.emissivemap,c.bumpmap,c.normalmap,c.displacementmap,c.roughnessmap,c.metalnessmap,c.fog,c.lights,{emissive:{value:new d(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:f.meshphysical_vert,fragmentShader:f.meshphysical_frag},toon:{uniforms:x([c.common,c.aomap,c.lightmap,c.emissivemap,c.bumpmap,c.normalmap,c.displacementmap,c.gradientmap,c.fog,c.lights,{emissive:{value:new d(0)}}]),vertexShader:f.meshtoon_vert,fragmentShader:f.meshtoon_frag},matcap:{uniforms:x([c.common,c.bumpmap,c.normalmap,c.displacementmap,c.fog,{matcap:{value:null}}]),vertexShader:f.meshmatcap_vert,fragmentShader:f.meshmatcap_frag},points:{uniforms:x([c.points,c.fog]),vertexShader:f.points_vert,fragmentShader:f.points_frag},dashed:{uniforms:x([c.common,c.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:f.linedashed_vert,fragmentShader:f.linedashed_frag},depth:{uniforms:x([c.common,c.displacementmap]),vertexShader:f.depth_vert,fragmentShader:f.depth_frag},normal:{uniforms:x([c.common,c.bumpmap,c.normalmap,c.displacementmap,{opacity:{value:1}}]),vertexShader:f.normal_vert,fragmentShader:f.normal_frag},sprite:{uniforms:x([c.sprite,c.fog]),vertexShader:f.sprite_vert,fragmentShader:f.sprite_frag},background:{uniforms:{uvTransform:{value:new v},t2D:{value:null}},vertexShader:f.background_vert,fragmentShader:f.background_frag},cube:{uniforms:x([c.envmap,{opacity:{value:1}}]),vertexShader:f.cube_vert,fragmentShader:f.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:f.equirect_vert,fragmentShader:f.equirect_frag},distanceRGBA:{uniforms:x([c.common,c.displacementmap,{referencePosition:{value:new a},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:f.distanceRGBA_vert,fragmentShader:f.distanceRGBA_frag},shadow:{uniforms:x([c.lights,c.fog,{color:{value:new d(0)},opacity:{value:1}}]),vertexShader:f.shadow_vert,fragmentShader:f.shadow_frag}},W.physical={uniforms:x([W.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new b(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new d(0)},transmission:{value:0},transmissionMap:{value:null}}]),vertexShader:f.meshphysical_vert,fragmentShader:f.meshphysical_frag};function hy(c,l,o,k,m){const f=new d(0);let e=0,b,a,g=null,h=0,j=null;function n(m,n,r,o){let d=n.isScene===!0?n.background:null;d&&d.isTexture&&(d=l.get(d));const p=c.xr,q=p.getSession&&p.getSession();q&&q.environmentBlendMode==="additive"&&(d=null),d===null?i(f,e):d&&d.isColor&&(i(d,1),o=!0),(c.autoClear||o)&&c.clear(c.autoClearColor,c.autoClearDepth,c.autoClearStencil),d&&(d.isCubeTexture||d.mapping===dm)?(a===void 0&&(a=new K(new dC(1,1,1),new ak({name:"BackgroundCubeMaterial",uniforms:aI(W.cube.uniforms),vertexShader:W.cube.vertexShader,fragmentShader:W.cube.fragmentShader,side:t,depthTest:!1,depthWrite:!1,fog:!1})),a.geometry.deleteAttribute("normal"),a.geometry.deleteAttribute("uv"),a.onBeforeRender=function(b,c,a){this.matrixWorld.copyPosition(a.matrixWorld)},Object.defineProperty(a.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),k.update(a)),a.material.uniforms.envMap.value=d,a.material.uniforms.flipEnvMap.value=d.isCubeTexture&&d._needsFlipEnvMap?-1:1,(g!==d||h!==d.version||j!==c.toneMapping)&&(a.material.needsUpdate=!0,g=d,h=d.version,j=c.toneMapping),m.unshift(a,a.geometry,a.material,0,0,null)):d&&d.isTexture&&(b===void 0&&(b=new K(new e_(2,2),new ak({name:"BackgroundMaterial",uniforms:aI(W.background.uniforms),vertexShader:W.background.vertexShader,fragmentShader:W.background.fragmentShader,side:cl,depthTest:!1,depthWrite:!1,fog:!1})),b.geometry.deleteAttribute("normal"),Object.defineProperty(b.material,"map",{get:function(){return this.uniforms.t2D.value}}),k.update(b)),b.material.uniforms.t2D.value=d,d.matrixAutoUpdate===!0&&d.updateMatrix(),b.material.uniforms.uvTransform.value.copy(d.matrix),(g!==d||h!==d.version||j!==c.toneMapping)&&(b.material.needsUpdate=!0,g=d,h=d.version,j=c.toneMapping),m.unshift(b,b.geometry,b.material,0,0,null))}function i(a,b){o.buffers.color.setClear(a.r,a.g,a.b,b,m)}return{getClearColor:function(){return f},setClearColor:function(a,b=1){f.set(a),e=b,i(f,e)},getClearAlpha:function(){return e},setClearAlpha:function(a){e=a,i(f,e)},render:n}}function hz(b,j,g,d){const B=b.getParameter(34921),h=d.isWebGL2?null:j.get("OES_vertex_array_object"),w=d.isWebGL2||h!==null,c={},f=p(null);let a=f;function v(i,h,f,c,d){let e=!1;if(w){const b=C(c,f,h);a!==b&&(a=b,m(a.object)),e=t(c,d),e&&s(c,d)}else{const b=h.wireframe===!0;(a.geometry!==c.id||a.program!==f.id||a.wireframe!==b)&&(a.geometry=c.id,a.program=f.id,a.wireframe=b,e=!0)}i.isInstancedMesh===!0&&(e=!0),d!==null&&g.update(d,34963),e&&(x(i,h,f,c),d!==null&&b.bindBuffer(34963,g.get(d).buffer))}function u(){return d.isWebGL2?b.createVertexArray():h.createVertexArrayOES()}function m(a){return d.isWebGL2?b.bindVertexArray(a):h.bindVertexArrayOES(a)}function i(a){return d.isWebGL2?b.deleteVertexArray(a):h.deleteVertexArrayOES(a)}function C(g,e,h){const f=h.wireframe===!0;let a=c[g.id];a===void 0&&(a={},c[g.id]=a);let b=a[e.id];b===void 0&&(b={},a[e.id]=b);let d=b[f];return d===void 0&&(d=p(u()),b[f]=d),d}function p(d){const a=[],b=[],c=[];for(let d=0;d<B;d++)a[d]=0,b[d]=0,c[d]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:a,enabledAttributes:b,attributeDivisors:c,object:d,attributes:{},index:null}}function t(d,e){const f=a.attributes,b=d.attributes;let c=0;for(const d in b){const a=f[d],e=b[d];if(a===void 0)return!0;if(a.attribute!==e)return!0;if(a.data!==e.data)return!0;c++}return a.attributesNum!==c||(a.index!==e)}function s(e,f){const b={},c=e.attributes;let d=0;for(const f in c){const a=c[f],e={};e.attribute=a,a.data&&(e.data=a.data),b[f]=e,d++}a.attributes=b,a.attributesNum=d,a.index=f}function q(){const b=a.newAttributes;for(let a=0,c=b.length;a<c;a++)b[a]=0}function k(a){e(a,0)}function e(c,e){const h=a.newAttributes,f=a.enabledAttributes,g=a.attributeDivisors;if(h[c]=1,f[c]===0&&(b.enableVertexAttribArray(c),f[c]=1),g[c]!==e){const a=d.isWebGL2?b:j.get("ANGLE_instanced_arrays");a[d.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](c,e),g[c]=e}}function l(){const d=a.newAttributes,c=a.enabledAttributes;for(let a=0,e=c.length;a<e;a++)c[a]!==d[a]&&(b.disableVertexAttribArray(a),c[a]=0)}function n(c,e,a,h,f,g){d.isWebGL2===!0&&(a===5124||a===5125)?b.vertexAttribIPointer(c,e,a,f,g):b.vertexAttribPointer(c,e,a,h,f,g)}function x(c,i,m,a){if(d.isWebGL2===!1&&(c.isInstancedMesh||a.isInstancedBufferGeometry))if(j.get("ANGLE_instanced_arrays")===null)return;q();const o=a.attributes,f=m.getAttributes(),h=i.defaultAttributeValues;for(const i in f){const d=f[i];if(d>=0){const f=o[i];if(f!==void 0){const h=f.normalized,i=f.itemSize,c=g.get(f);if(c===void 0)continue;const j=c.buffer,l=c.type,m=c.bytesPerElement;if(f.isInterleavedBufferAttribute){const c=f.data,g=c.stride,o=f.offset;c&&c.isInstancedInterleavedBuffer?(e(d,c.meshPerAttribute),a._maxInstanceCount===void 0&&(a._maxInstanceCount=c.meshPerAttribute*c.count)):k(d),b.bindBuffer(34962,j),n(d,i,l,h,g*m,o*m)}else f.isInstancedBufferAttribute?(e(d,f.meshPerAttribute),a._maxInstanceCount===void 0&&(a._maxInstanceCount=f.meshPerAttribute*f.count)):k(d),b.bindBuffer(34962,j),n(d,i,l,h,0,0)}else if(i==="instanceMatrix"){const f=g.get(c.instanceMatrix);if(f===void 0)continue;const h=f.buffer,a=f.type;e(d+0,1),e(d+1,1),e(d+2,1),e(d+3,1),b.bindBuffer(34962,h),b.vertexAttribPointer(d+0,4,a,!1,64,0),b.vertexAttribPointer(d+1,4,a,!1,64,16),b.vertexAttribPointer(d+2,4,a,!1,64,32),b.vertexAttribPointer(d+3,4,a,!1,64,48)}else if(i==="instanceColor"){const a=g.get(c.instanceColor);if(a===void 0)continue;const f=a.buffer,h=a.type;e(d,1),b.bindBuffer(34962,f),b.vertexAttribPointer(d,3,h,!1,12,0)}else if(h!==void 0){const a=h[i];if(a!==void 0)switch(a.length){case 2:b.vertexAttrib2fv(d,a);break;case 3:b.vertexAttrib3fv(d,a);break;case 4:b.vertexAttrib4fv(d,a);break;default:b.vertexAttrib1fv(d,a)}}}}l()}function y(){o();for(const b in c){const a=c[b];for(const c in a){const b=a[c];for(const a in b)i(b[a].object),delete b[a];delete a[c]}delete c[b]}}function z(a){if(c[a.id]===void 0)return;const b=c[a.id];for(const c in b){const a=b[c];for(const b in a)i(a[b].object),delete a[b];delete b[c]}delete c[a.id]}function A(a){for(const e in c){const b=c[e];if(b[a.id]===void 0)continue;const d=b[a.id];for(const a in d)i(d[a].object),delete d[a];delete b[a.id]}}function o(){if(r(),a===f)return;a=f,m(a.object)}function r(){f.geometry=null,f.program=null,f.wireframe=!1}return{setup:v,reset:o,resetDefaultState:r,dispose:y,releaseStatesOfGeometry:z,releaseStatesOfProgram:A,initAttributes:q,enableAttribute:k,disableUnusedAttributes:l}}function hA(b,d,c,e){const f=e.isWebGL2;let a;function g(b){a=b}function h(e,d){b.drawArrays(a,e,d),c.update(d,a,1)}function i(j,i,g){if(g===0)return;let e,h;if(f)e=b,h="drawArraysInstanced";else if(e=d.get("ANGLE_instanced_arrays"),h="drawArraysInstancedANGLE",e===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}e[h](a,j,i,g),c.update(i,a,g)}this.setMode=g,this.render=h,this.renderInstances=i}function hB(a,f,d){let c;function t(){if(c!==void 0)return c;if(f.has("EXT_texture_filter_anisotropic")===!0){const b=f.get("EXT_texture_filter_anisotropic");c=a.getParameter(b.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else c=0;return c}function i(b){if(b==="highp"){if(a.getShaderPrecisionFormat(35633,36338).precision>0&&a.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";b="mediump"}if(b==="mediump")if(a.getShaderPrecisionFormat(35633,36337).precision>0&&a.getShaderPrecisionFormat(35632,36337).precision>0)return"mediump";return"lowp"}const e=typeof WebGL2RenderingContext!="undefined"&&a instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext!="undefined"&&a instanceof WebGL2ComputeRenderingContext;let b=d.precision!==void 0?d.precision:"highp";const g=i(b);g!==b&&(console.warn("THREE.WebGLRenderer:",b,"not supported, using",g,"instead."),b=g);const s=d.logarithmicDepthBuffer===!0,l=a.getParameter(34930),k=a.getParameter(35660),m=a.getParameter(3379),n=a.getParameter(34076),o=a.getParameter(34921),p=a.getParameter(36347),q=a.getParameter(36348),r=a.getParameter(36349),j=k>0,h=e||f.has("OES_texture_float"),u=j&&h,v=e?a.getParameter(36183):0;return{isWebGL2:e,getMaxAnisotropy:t,getMaxPrecision:i,precision:b,logarithmicDepthBuffer:s,maxTextures:l,maxVertexTextures:k,maxTextureSize:m,maxCubemapSize:n,maxAttributes:o,maxVertexUniforms:p,maxVaryings:q,maxFragmentUniforms:r,vertexTextures:j,floatFragmentTextures:h,floatVertexTextures:u,maxSamples:v}}function hC(k){const d=this;let f=null,b=0,h=!1,c=!1;const g=new U,i=new v,a={value:null,needsUpdate:!1};this.uniform=a,this.numPlanes=0,this.numIntersection=0,this.init=function(a,c,d){const g=a.length!==0||c||b!==0||h;return h=c,f=e(a,d,0),b=a.length,g},this.beginShadows=function(){c=!0,e(null)},this.endShadows=function(){c=!1,j()},this.setState=function(d,l,m){const g=d.clippingPlanes,n=d.clipIntersection,o=d.clipShadows,i=k.get(d);if(!h||g===null||g.length===0||c&&!o)c?e(null):j();else{const h=c?0:b,j=h*4;let d=i.clippingState||null;a.value=d,d=e(g,l,j,m);for(let a=0;a!==j;++a)d[a]=f[a];i.clippingState=d,this.numIntersection=n?this.numPlanes:0,this.numPlanes+=h}};function j(){a.value!==f&&(a.value=f,a.needsUpdate=b>0),d.numPlanes=b,d.numIntersection=0}function e(e,h,f,j){const c=e!==null?e.length:0;let b=null;if(c!==0){if(b=a.value,j!==!0||b===null){const a=f+c*4,d=h.matrixWorldInverse;i.getNormalMatrix(d),(b===null||b.length<a)&&(b=new Float32Array(a));for(let a=0,h=f;a!==c;++a,h+=4)g.copy(e[a]).applyMatrix4(d,i),g.normal.toArray(b,h),b[h+3]=g.constant}a.value=b,a.needsUpdate=!0}return d.numPlanes=c,d.numIntersection=0,b}}function hD(b){let a=new WeakMap;function c(a,b){return b===fi?a.mapping=de:b===fg&&(a.mapping=di),a}function e(e){if(e&&e.isTexture){const f=e.mapping;if(f===fi||f===fg){if(a.has(e)){const b=a.get(e).texture;return c(b,e.mapping)}const f=e.image;if(f&&f.height>0){const h=b.getRenderTarget(),g=new eT(f.height/2);return g.fromEquirectangularTexture(b,e),a.set(e,g),b.setRenderTarget(h),e.addEventListener("dispose",d),c(g.texture,e.mapping)}return null}}return e}function d(e){const b=e.target;b.removeEventListener("dispose",d);const c=a.get(b);c!==void 0&&(a.delete(b),c.dispose())}function f(){a=new WeakMap}return{get:e,dispose:f}}function hE(b){const c={};function a(d){if(c[d]!==void 0)return c[d];let a;switch(d){case"WEBGL_depth_texture":a=b.getExtension("WEBGL_depth_texture")||b.getExtension("MOZ_WEBGL_depth_texture")||b.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":a=b.getExtension("EXT_texture_filter_anisotropic")||b.getExtension("MOZ_EXT_texture_filter_anisotropic")||b.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":a=b.getExtension("WEBGL_compressed_texture_s3tc")||b.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||b.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":a=b.getExtension("WEBGL_compressed_texture_pvrtc")||b.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:a=b.getExtension(d)}return c[d]=a,a}return{has:function(b){return a(b)!==null},init:function(b){b.isWebGL2?a("EXT_color_buffer_float"):(a("WEBGL_depth_texture"),a("OES_texture_float"),a("OES_texture_half_float"),a("OES_texture_half_float_linear"),a("OES_standard_derivatives"),a("OES_element_index_uint"),a("OES_vertex_array_object"),a("ANGLE_instanced_arrays")),a("OES_texture_float_linear"),a("EXT_color_buffer_half_float")},get:function(b){const c=a(b);return c===null&&console.warn("THREE.WebGLRenderer: "+b+" extension not supported."),c}}}function hF(k,a,e,i){const c={},b=new WeakMap;function d(h){const f=h.target;f.index!==null&&a.remove(f.index);for(const b in f.attributes)a.remove(f.attributes[b]);f.removeEventListener("dispose",d),delete c[f.id];const g=b.get(f);g&&(a.remove(g),b.delete(f)),i.releaseStatesOfGeometry(f),f.isInstancedBufferGeometry===!0&&delete f._maxInstanceCount,e.memory.geometries--}function g(b,a){return c[a.id]===!0?a:(a.addEventListener("dispose",d),c[a.id]=!0,e.memory.geometries++,a)}function h(b){const c=b.attributes;for(const b in c)a.update(c[b],34962);const d=b.morphAttributes;for(const c in d){const b=d[c];for(let c=0,d=b.length;c<d;c++)a.update(b[c],34962)}}function f(c){const d=[],e=c.index,g=c.attributes.position;let f=0;if(e!==null){const a=e.array;f=e.version;for(let b=0,g=a.length;b<g;b+=3){const c=a[b+0],e=a[b+1],f=a[b+2];d.push(c,e,e,f,f,c)}}else{const a=g.array;f=g.version;for(let b=0,g=a.length/3-1;b<g;b+=3){const c=b+0,e=b+1,f=b+2;d.push(c,e,e,f,f,c)}}const h=new(ed(d)>65535?ea:d$)(d,1);h.version=f;const i=b.get(c);i&&a.remove(i),b.set(c,h)}function j(a){const c=b.get(a);if(c){const b=a.index;b!==null&&c.version<b.version&&f(a)}else f(a);return b.get(a)}return{get:g,update:h,getWireframeAttribute:j}}function hG(d,i,e,f){const g=f.isWebGL2;let a;function h(b){a=b}let b,c;function j(a){b=a.type,c=a.bytesPerElement}function k(g,f){d.drawElements(a,f,b,g*c),e.update(f,a,1)}function l(l,k,h){if(h===0)return;let f,j;if(g)f=d,j="drawElementsInstanced";else if(f=i.get("ANGLE_instanced_arrays"),j="drawElementsInstancedANGLE",f===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}f[j](a,k,b,l*c,h),e.update(k,a,h)}this.setMode=h,this.setIndex=j,this.render=k,this.renderInstances=l}function hH(e){const b={geometries:0,textures:0},a={frame:0,calls:0,triangles:0,points:0,lines:0};function c(b,d,c){switch(a.calls++,d){case 4:a.triangles+=c*(b/3);break;case 1:a.lines+=c*(b/2);break;case 3:a.lines+=c*(b-1);break;case 2:a.lines+=c*b;break;case 0:a.points+=c*b;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",d);break}}function d(){a.frame++,a.calls=0,a.triangles=0,a.points=0,a.lines=0}return{memory:b,render:a,programs:null,autoReset:!0,reset:d,update:c}}function hI(a,b){return a[0]-b[0]}function hJ(a,b){return Math.abs(b[1])-Math.abs(a[1])}function hK(c){const d={},b=new Float32Array(8),a=[];for(let b=0;b<8;b++)a[b]=[b,0];function e(n,e,l,k){const i=n.morphTargetInfluences,j=i===void 0?0:i.length;let f=d[e.id];if(f===void 0){f=[];for(let a=0;a<j;a++)f[a]=[a,0];d[e.id]=f}for(let a=0;a<j;a++){const b=f[a];b[0]=a,b[1]=i[a]}f.sort(hJ);for(let b=0;b<8;b++)b<j&&f[b][1]?(a[b][0]=f[b][0],a[b][1]=f[b][1]):(a[b][0]=Number.MAX_SAFE_INTEGER,a[b][1]=0);a.sort(hI);const h=l.morphTargets&&e.morphAttributes.position,g=l.morphNormals&&e.morphAttributes.normal;let m=0;for(let c=0;c<8;c++){const i=a[c],d=i[0],f=i[1];d!==Number.MAX_SAFE_INTEGER&&f?(h&&e.getAttribute("morphTarget"+c)!==h[d]&&e.setAttribute("morphTarget"+c,h[d]),g&&e.getAttribute("morphNormal"+c)!==g[d]&&e.setAttribute("morphNormal"+c,g[d]),b[c]=f,m+=f):(h&&e.hasAttribute("morphTarget"+c)===!0&&e.deleteAttribute("morphTarget"+c),g&&e.hasAttribute("morphNormal"+c)===!0&&e.deleteAttribute("morphNormal"+c),b[c]=0)}const o=e.morphTargetsRelative?1:1-m;k.getUniforms().setValue(c,"morphTargetBaseInfluence",o),k.getUniforms().setValue(c,"morphTargetInfluences",b)}return{update:e}}function hL(h,d,a,f){let c=new WeakMap;function g(e){const h=f.render.frame,i=e.geometry,g=d.get(e,i);return c.get(g)!==h&&(d.update(g),c.set(g,h)),e.isInstancedMesh&&(e.hasEventListener("dispose",b)===!1&&e.addEventListener("dispose",b),a.update(e.instanceMatrix,34962),e.instanceColor!==null&&a.update(e.instanceColor,34962)),g}function e(){c=new WeakMap}function b(d){const c=d.target;c.removeEventListener("dispose",b),a.remove(c.instanceMatrix),c.instanceColor!==null&&a.remove(c.instanceColor)}return{update:g,dispose:e}}gi=class extends y{constructor(a=null,b=1,c=1,d=1){super(null),this.image={data:a,width:b,height:c,depth:d},this.magFilter=A,this.minFilter=A,this.wrapR=O,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}},gi.prototype.isDataTexture2DArray=!0,gh=class extends y{constructor(a=null,b=1,c=1,d=1){super(null),this.image={data:a,width:b,height:c,depth:d},this.magFilter=A,this.minFilter=A,this.wrapR=O,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}},gh.prototype.isDataTexture3D=!0,gg=new y,hP=new gi,hQ=new gh,gf=new cu,ge=[],gd=[],gc=new Float32Array(16),gb=new Float32Array(9),f$=new Float32Array(4);function aY(b,c,f){const d=b[0];if(d<=0||d>0)return b;const e=c*f;let a=ge[e];if(a===void 0&&(a=new Float32Array(e),ge[e]=a),c!==0){d.toArray(a,0);for(let d=1,e=0;d!==c;++d)e+=f,b[d].toArray(a,e)}return a}function C(a,b){if(a.length!==b.length)return!1;for(let c=0,d=a.length;c<d;c++)if(a[c]!==b[c])return!1;return!0}function z(b,a){for(let c=0,d=a.length;c<d;c++)b[c]=a[c]}function fX(c,b){let a=gd[b];a===void 0&&(a=new Int32Array(b),gd[b]=a);for(let d=0;d!==b;++d)a[d]=c.allocateTextureUnit();return a}function h$(c,a){const b=this.cache;if(b[0]===a)return;c.uniform1f(this.addr,a),b[0]=a}function ia(c,a){const b=this.cache;if(a.x!==void 0)(b[0]!==a.x||b[1]!==a.y)&&(c.uniform2f(this.addr,a.x,a.y),b[0]=a.x,b[1]=a.y);else{if(C(b,a))return;c.uniform2fv(this.addr,a),z(b,a)}}function ib(c,a){const b=this.cache;if(a.x!==void 0)(b[0]!==a.x||b[1]!==a.y||b[2]!==a.z)&&(c.uniform3f(this.addr,a.x,a.y,a.z),b[0]=a.x,b[1]=a.y,b[2]=a.z);else if(a.r!==void 0)(b[0]!==a.r||b[1]!==a.g||b[2]!==a.b)&&(c.uniform3f(this.addr,a.r,a.g,a.b),b[0]=a.r,b[1]=a.g,b[2]=a.b);else{if(C(b,a))return;c.uniform3fv(this.addr,a),z(b,a)}}function ic(c,a){const b=this.cache;if(a.x!==void 0)(b[0]!==a.x||b[1]!==a.y||b[2]!==a.z||b[3]!==a.w)&&(c.uniform4f(this.addr,a.x,a.y,a.z,a.w),b[0]=a.x,b[1]=a.y,b[2]=a.z,b[3]=a.w);else{if(C(b,a))return;c.uniform4fv(this.addr,a),z(b,a)}}function id(d,a){const b=this.cache,c=a.elements;if(c===void 0){if(C(b,a))return;d.uniformMatrix2fv(this.addr,!1,a),z(b,a)}else{if(C(b,c))return;f$.set(c),d.uniformMatrix2fv(this.addr,!1,f$),z(b,c)}}function ie(d,a){const b=this.cache,c=a.elements;if(c===void 0){if(C(b,a))return;d.uniformMatrix3fv(this.addr,!1,a),z(b,a)}else{if(C(b,c))return;gb.set(c),d.uniformMatrix3fv(this.addr,!1,gb),z(b,c)}}function ig(d,a){const b=this.cache,c=a.elements;if(c===void 0){if(C(b,a))return;d.uniformMatrix4fv(this.addr,!1,a),z(b,a)}else{if(C(b,c))return;gc.set(c),d.uniformMatrix4fv(this.addr,!1,gc),z(b,c)}}function ih(c,a){const b=this.cache;if(b[0]===a)return;c.uniform1i(this.addr,a),b[0]=a}function ii(c,a){const b=this.cache;if(C(b,a))return;c.uniform2iv(this.addr,a),z(b,a)}function ij(c,a){const b=this.cache;if(C(b,a))return;c.uniform3iv(this.addr,a),z(b,a)}function ik(c,a){const b=this.cache;if(C(b,a))return;c.uniform4iv(this.addr,a),z(b,a)}function il(c,a){const b=this.cache;if(b[0]===a)return;c.uniform1ui(this.addr,a),b[0]=a}function im(c,a){const b=this.cache;if(C(b,a))return;c.uniform2uiv(this.addr,a),z(b,a)}function io(c,a){const b=this.cache;if(C(b,a))return;c.uniform3uiv(this.addr,a),z(b,a)}function ip(c,a){const b=this.cache;if(C(b,a))return;c.uniform4uiv(this.addr,a),z(b,a)}function iq(d,e,b){const c=this.cache,a=b.allocateTextureUnit();c[0]!==a&&(d.uniform1i(this.addr,a),c[0]=a),b.safeSetTexture2D(e||gg,a)}function ir(d,e,b){const c=this.cache,a=b.allocateTextureUnit();c[0]!==a&&(d.uniform1i(this.addr,a),c[0]=a),b.setTexture3D(e||hQ,a)}function is(d,e,b){const c=this.cache,a=b.allocateTextureUnit();c[0]!==a&&(d.uniform1i(this.addr,a),c[0]=a),b.safeSetTextureCube(e||gf,a)}function it(d,e,b){const c=this.cache,a=b.allocateTextureUnit();c[0]!==a&&(d.uniform1i(this.addr,a),c[0]=a),b.setTexture2DArray(e||hP,a)}function iu(a){switch(a){case 5126:return h$;case 35664:return ia;case 35665:return ib;case 35666:return ic;case 35674:return id;case 35675:return ie;case 35676:return ig;case 5124:case 35670:return ih;case 35667:case 35671:return ii;case 35668:case 35672:return ij;case 35669:case 35673:return ik;case 5125:return il;case 36294:return im;case 36295:return io;case 36296:return ip;case 35678:case 36198:case 36298:case 36306:case 35682:return iq;case 35679:case 36299:case 36307:return ir;case 35680:case 36300:case 36308:case 36293:return is;case 36289:case 36303:case 36311:case 36292:return it}}function iv(a,b){a.uniform1fv(this.addr,b)}function iw(a,b){const c=aY(b,this.size,2);a.uniform2fv(this.addr,c)}function ix(a,b){const c=aY(b,this.size,3);a.uniform3fv(this.addr,c)}function iy(a,b){const c=aY(b,this.size,4);a.uniform4fv(this.addr,c)}function iz(a,b){const c=aY(b,this.size,4);a.uniformMatrix2fv(this.addr,!1,c)}function iA(a,b){const c=aY(b,this.size,9);a.uniformMatrix3fv(this.addr,!1,c)}function iB(a,b){const c=aY(b,this.size,16);a.uniformMatrix4fv(this.addr,!1,c)}function iC(a,b){a.uniform1iv(this.addr,b)}function iD(a,b){a.uniform2iv(this.addr,b)}function iE(a,b){a.uniform3iv(this.addr,b)}function iF(a,b){a.uniform4iv(this.addr,b)}function iG(a,b){a.uniform1uiv(this.addr,b)}function iH(a,b){a.uniform2uiv(this.addr,b)}function iI(a,b){a.uniform3uiv(this.addr,b)}function iJ(a,b){a.uniform4uiv(this.addr,b)}function iK(e,a,b){const c=a.length,d=fX(b,c);e.uniform1iv(this.addr,d);for(let e=0;e!==c;++e)b.safeSetTexture2D(a[e]||gg,d[e])}function iL(e,a,b){const c=a.length,d=fX(b,c);e.uniform1iv(this.addr,d);for(let e=0;e!==c;++e)b.safeSetTextureCube(a[e]||gf,d[e])}function iM(a){switch(a){case 5126:return iv;case 35664:return iw;case 35665:return ix;case 35666:return iy;case 35674:return iz;case 35675:return iA;case 35676:return iB;case 5124:case 35670:return iC;case 35667:case 35671:return iD;case 35668:case 35672:return iE;case 35669:case 35673:return iF;case 5125:return iG;case 36294:return iH;case 36295:return iI;case 36296:return iJ;case 35678:case 36198:case 36298:case 36306:case 35682:return iK;case 35680:case 36300:case 36308:case 36293:return iL}}function iN(a,b,c){this.id=a,this.addr=c,this.cache=[],this.setValue=iu(b.type)}function fW(b,a,c){this.id=b,this.addr=c,this.cache=[],this.size=a.size,this.setValue=iM(a.type)}fW.prototype.updateCache=function(a){const b=this.cache;a instanceof Float32Array&&b.length!==a.length&&(this.cache=new Float32Array(a.length)),z(b,a)};function gl(a){this.id=a,this.seq=[],this.map={}}gl.prototype.setValue=function(b,c,d){const a=this.seq;for(let e=0,g=a.length;e!==g;++e){const f=a[e];f.setValue(b,c[f.id],d)}},dn=/(\w+)(\])?(\[|\.)?/g;function fU(b,a){b.seq.push(a),b.map[a.id]=a}function iS(b,c,a){const d=b.name,e=d.length;for(dn.lastIndex=0;!0;){const i=dn.exec(d),j=dn.lastIndex;let f=i[1];const k=i[2]==="]",h=i[3];if(k&&(f=f|0),h===void 0||h==="["&&j+2===e){fU(a,h===void 0?new iN(f,b,c):new fW(f,b,c));break}const l=a.map;let g=l[f];g===void 0&&(g=new gl(f),fU(a,g)),a=g}}function am(a,b){this.seq=[],this.map={};const c=a.getProgramParameter(b,35718);for(let d=0;d<c;++d){const e=a.getActiveUniform(b,d),f=a.getUniformLocation(b,e.name);iS(e,f,this)}}am.prototype.setValue=function(b,c,d,e){const a=this.map[c];a!==void 0&&a.setValue(b,d,e)},am.prototype.setOptional=function(c,d,a){const b=d[a];b!==void 0&&this.setValue(c,a,b)},am.upload=function(b,a,c,d){for(let e=0,h=a.length;e!==h;++e){const f=a[e],g=c[f.id];g.needsUpdate!==!1&&f.setValue(b,g.value,d)}},am.seqWithValue=function(a,c){const b=[];for(let d=0,f=a.length;d!==f;++d){const e=a[d];e.id in c&&b.push(e)}return b};function fS(a,c,d){const b=a.createShader(c);return a.shaderSource(b,d),a.compileShader(b),b}iV=0;function iW(b){const a=b.split("\n");for(let b=0;b<a.length;b++)a[b]=b+1+": "+a[b];return a.join("\n")}function fR(a){switch(a){case aF:return["Linear","( value )"];case cZ:return["sRGB","( value )"];case es:return["RGBE","( value )"];case er:return["RGBM","( value, 7.0 )"];case eq:return["RGBM","( value, 16.0 )"];case ep:return["RGBD","( value, 256.0 )"];case dT:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case lz:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",a),["Linear","( value )"]}}function fQ(a,b,d){const e=a.getShaderParameter(b,35713),c=a.getShaderInfoLog(b).trim();if(e&&c==="")return"";const f=a.getShaderSource(b);return"THREE.WebGLShader: gl.getShaderInfoLog() "+d+"\n"+c+iW(f)}function bi(b,c){const a=fR(c);return"vec4 "+b+"( vec4 value ) { return "+a[0]+"ToLinear"+a[1]+"; }"}function i_(b,c){const a=fR(c);return"vec4 "+b+"( vec4 value ) { return LinearTo"+a[0]+a[1]+"; }"}function i$(c,b){let a;switch(b){case ni:a="Linear";break;case nh:a="Reinhard";break;case nf:a="OptimizedCineon";break;case ne:a="ACESFilmic";break;case nd:a="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",b),a="Linear"}return"vec3 "+c+"( vec3 color ) { return "+a+"ToneMapping( color ); }"}function ja(a){const b=[a.extensionDerivatives||a.envMapCubeUV||a.bumpMap||a.tangentSpaceNormalMap||a.clearcoatNormalMap||a.flatShading||a.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(a.extensionFragDepth||a.logarithmicDepthBuffer)&&a.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",a.extensionDrawBuffers&&a.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(a.extensionShaderTextureLOD||a.envMap)&&a.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""];return b.filter(br).join("\n")}function jb(a){const b=[];for(const c in a){const d=a[c];if(d===!1)continue;b.push("#define "+c+" "+d)}return b.join("\n")}function jc(a,b){const c={},d=a.getProgramParameter(b,35721);for(let e=0;e<d;e++){const g=a.getActiveAttrib(b,e),f=g.name;c[f]=a.getAttribLocation(b,f)}return c}function br(a){return a!==""}function fN(b,a){return b.replace(/NUM_DIR_LIGHTS/g,a.numDirLights).replace(/NUM_SPOT_LIGHTS/g,a.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,a.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,a.numPointLights).replace(/NUM_HEMI_LIGHTS/g,a.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,a.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,a.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,a.numPointLightShadows)}function fM(b,a){return b.replace(/NUM_CLIPPING_PLANES/g,a.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,a.numClippingPlanes-a.numClipIntersection)}jg=/^[ \t]*#include +<([\w\d./]+)>/gm;function df(a){return a.replace(jg,ji)}function ji(c,a){const b=f[a];if(b===void 0)throw new Error("Can not resolve #include <"+a+">");return df(b)}jj=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,jk=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function fK(a){return a.replace(jk,fJ).replace(jj,jm)}function jm(a,b,c,d){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),fJ(a,b,c,d)}function fJ(e,b,c,d){let a="";for(let e=parseInt(b);e<parseInt(c);e++)a+=d.replace(/\[\s*i\s*\]/g,"[ "+e+" ]").replace(/UNROLLED_LOOP_INDEX/g,e);return a}function fI(a){let b="precision "+a.precision+" float;\nprecision "+a.precision+" int;";return a.precision==="highp"?b+="\n#define HIGH_PRECISION":a.precision==="mediump"?b+="\n#define MEDIUM_PRECISION":a.precision==="lowp"&&(b+="\n#define LOW_PRECISION"),b}function jp(b){let a="SHADOWMAP_TYPE_BASIC";return b.shadowMapType===f_?a="SHADOWMAP_TYPE_PCF":b.shadowMapType===os?a="SHADOWMAP_TYPE_PCF_SOFT":b.shadowMapType===bt&&(a="SHADOWMAP_TYPE_VSM"),a}function jq(b){let a="ENVMAP_TYPE_CUBE";if(b.envMap)switch(b.envMapMode){case de:case di:a="ENVMAP_TYPE_CUBE";break;case dm:case dp:a="ENVMAP_TYPE_CUBE_UV";break}return a}function jr(a){let b="ENVMAP_MODE_REFLECTION";if(a.envMap)switch(a.envMapMode){case di:case dp:b="ENVMAP_MODE_REFRACTION";break}return b}function js(b){let a="ENVMAP_BLENDING_NONE";if(b.envMap)switch(b.combine){case ch:a="ENVMAP_BLENDING_MULTIPLY";break;case nk:a="ENVMAP_BLENDING_MIX";break;case nj:a="ENVMAP_BLENDING_ADD";break}return a}function jt(l,z,a,y){const b=l.getContext(),x=a.defines;let d=a.vertexShader,e=a.fragmentShader;const r=jp(a),u=jq(a),q=jr(a),t=js(a),s=l.gammaFactor>0?l.gammaFactor:1,p=a.isWebGL2?"":ja(a),k=jb(x),c=b.createProgram();let h,g,m=a.glslVersion?"#version "+a.glslVersion+"\n":"";a.isRawShaderMaterial?(h=[k].filter(br).join("\n"),h.length>0&&(h+="\n"),g=[p,k].filter(br).join("\n"),g.length>0&&(g+="\n")):(h=[fI(a),"#define SHADER_NAME "+a.shaderName,k,a.instancing?"#define USE_INSTANCING":"",a.instancingColor?"#define USE_INSTANCING_COLOR":"",a.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+s,"#define MAX_BONES "+a.maxBones,a.useFog&&a.fog?"#define USE_FOG":"",a.useFog&&a.fogExp2?"#define FOG_EXP2":"",a.map?"#define USE_MAP":"",a.envMap?"#define USE_ENVMAP":"",a.envMap?"#define "+q:"",a.lightMap?"#define USE_LIGHTMAP":"",a.aoMap?"#define USE_AOMAP":"",a.emissiveMap?"#define USE_EMISSIVEMAP":"",a.bumpMap?"#define USE_BUMPMAP":"",a.normalMap?"#define USE_NORMALMAP":"",a.normalMap&&a.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",a.normalMap&&a.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",a.clearcoatMap?"#define USE_CLEARCOATMAP":"",a.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",a.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",a.displacementMap&&a.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",a.specularMap?"#define USE_SPECULARMAP":"",a.roughnessMap?"#define USE_ROUGHNESSMAP":"",a.metalnessMap?"#define USE_METALNESSMAP":"",a.alphaMap?"#define USE_ALPHAMAP":"",a.transmissionMap?"#define USE_TRANSMISSIONMAP":"",a.vertexTangents?"#define USE_TANGENT":"",a.vertexColors?"#define USE_COLOR":"",a.vertexAlphas?"#define USE_COLOR_ALPHA":"",a.vertexUvs?"#define USE_UV":"",a.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",a.flatShading?"#define FLAT_SHADED":"",a.skinning?"#define USE_SKINNING":"",a.useVertexTexture?"#define BONE_TEXTURE":"",a.morphTargets?"#define USE_MORPHTARGETS":"",a.morphNormals&&a.flatShading===!1?"#define USE_MORPHNORMALS":"",a.doubleSided?"#define DOUBLE_SIDED":"",a.flipSided?"#define FLIP_SIDED":"",a.shadowMapEnabled?"#define USE_SHADOWMAP":"",a.shadowMapEnabled?"#define "+r:"",a.sizeAttenuation?"#define USE_SIZEATTENUATION":"",a.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",a.logarithmicDepthBuffer&&a.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif","\n"].filter(br).join("\n"),g=[p,fI(a),"#define SHADER_NAME "+a.shaderName,k,a.alphaTest?"#define ALPHATEST "+a.alphaTest+(a.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+s,a.useFog&&a.fog?"#define USE_FOG":"",a.useFog&&a.fogExp2?"#define FOG_EXP2":"",a.map?"#define USE_MAP":"",a.matcap?"#define USE_MATCAP":"",a.envMap?"#define USE_ENVMAP":"",a.envMap?"#define "+u:"",a.envMap?"#define "+q:"",a.envMap?"#define "+t:"",a.lightMap?"#define USE_LIGHTMAP":"",a.aoMap?"#define USE_AOMAP":"",a.emissiveMap?"#define USE_EMISSIVEMAP":"",a.bumpMap?"#define USE_BUMPMAP":"",a.normalMap?"#define USE_NORMALMAP":"",a.normalMap&&a.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",a.normalMap&&a.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",a.clearcoatMap?"#define USE_CLEARCOATMAP":"",a.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",a.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",a.specularMap?"#define USE_SPECULARMAP":"",a.roughnessMap?"#define USE_ROUGHNESSMAP":"",a.metalnessMap?"#define USE_METALNESSMAP":"",a.alphaMap?"#define USE_ALPHAMAP":"",a.sheen?"#define USE_SHEEN":"",a.transmissionMap?"#define USE_TRANSMISSIONMAP":"",a.vertexTangents?"#define USE_TANGENT":"",a.vertexColors||a.instancingColor?"#define USE_COLOR":"",a.vertexAlphas?"#define USE_COLOR_ALPHA":"",a.vertexUvs?"#define USE_UV":"",a.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",a.gradientMap?"#define USE_GRADIENTMAP":"",a.flatShading?"#define FLAT_SHADED":"",a.doubleSided?"#define DOUBLE_SIDED":"",a.flipSided?"#define FLIP_SIDED":"",a.shadowMapEnabled?"#define USE_SHADOWMAP":"",a.shadowMapEnabled?"#define "+r:"",a.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",a.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",a.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",a.logarithmicDepthBuffer&&a.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(a.extensionShaderTextureLOD||a.envMap)&&a.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",a.toneMapping!==bd?"#define TONE_MAPPING":"",a.toneMapping!==bd?f.tonemapping_pars_fragment:"",a.toneMapping!==bd?i$("toneMapping",a.toneMapping):"",a.dithering?"#define DITHERING":"",f.encodings_pars_fragment,a.map?bi("mapTexelToLinear",a.mapEncoding):"",a.matcap?bi("matcapTexelToLinear",a.matcapEncoding):"",a.envMap?bi("envMapTexelToLinear",a.envMapEncoding):"",a.emissiveMap?bi("emissiveMapTexelToLinear",a.emissiveMapEncoding):"",a.lightMap?bi("lightMapTexelToLinear",a.lightMapEncoding):"",i_("linearToOutputTexel",a.outputEncoding),a.depthPacking?"#define DEPTH_PACKING "+a.depthPacking:"","\n"].filter(br).join("\n")),d=df(d),d=fN(d,a),d=fM(d,a),e=df(e),e=fN(e,a),e=fM(e,a),d=fK(d),e=fK(e),a.isWebGL2&&a.isRawShaderMaterial!==!0&&(m="#version 300 es\n",h=["#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+h,g=["#define varying in",a.glslVersion===en?"":"out highp vec4 pc_fragColor;",a.glslVersion===en?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+g);const v=m+h+d,w=m+g+e,j=fS(b,35633,v),i=fS(b,35632,w);if(b.attachShader(c,j),b.attachShader(c,i),a.index0AttributeName!==void 0?b.bindAttribLocation(c,0,a.index0AttributeName):a.morphTargets===!0&&b.bindAttribLocation(c,0,"position"),b.linkProgram(c),l.debug.checkShaderErrors){const a=b.getProgramInfoLog(c).trim(),d=b.getShaderInfoLog(j).trim(),e=b.getShaderInfoLog(i).trim();let f=!0,k=!0;if(b.getProgramParameter(c,35714)===!1){f=!1;const d=fQ(b,j,"vertex"),e=fQ(b,i,"fragment");console.error("THREE.WebGLProgram: shader error: ",b.getError(),"35715",b.getProgramParameter(c,35715),"gl.getProgramInfoLog",a,d,e)}else a!==""?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",a):(d===""||e==="")&&(k=!1);k&&(this.diagnostics={runnable:f,programLog:a,vertexShader:{log:d,prefix:h},fragmentShader:{log:e,prefix:g}})}b.deleteShader(j),b.deleteShader(i);let n;this.getUniforms=function(){return n===void 0&&(n=new am(b,c)),n};let o;return this.getAttributes=function(){return o===void 0&&(o=jc(b,c)),o},this.destroy=function(){y.releaseStatesOfProgram(this),b.deleteProgram(c),this.program=void 0},this.name=a.shaderName,this.id=iV++,this.cacheKey=z,this.usedTimes=1,this.program=c,this.vertexShader=j,this.fragmentShader=i,this}function ju(a,q,g,c,o,h){const b=[],f=c.isWebGL2,n=c.logarithmicDepthBuffer,j=c.floatVertexTextures,m=c.maxVertexUniforms,l=c.vertexTextures;let e=c.precision;const i={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},k=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexAlphas","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen","transmissionMap"];function p(c){const d=c.skeleton,a=d.bones;if(j)return 1024;const e=m,f=Math.floor((e-20)/4),b=Math.min(f,a.length);return b<a.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+a.length+" bones. This GPU supports "+b+"."),0):b}function d(a){let b;return a&&a.isTexture?b=a.encoding:a&&a.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),b=a.texture.encoding):b=aF,b}function r(b,m,z,y,k){const s=y.fog,A=b.isMeshStandardMaterial?y.environment:null,o=q.get(b.envMap||A),u=i[b.type],x=k.isSkinnedMesh?p(k):0;b.precision!==null&&(e=c.getMaxPrecision(b.precision),e!==b.precision&&console.warn("THREE.WebGLProgram.getParameters:",b.precision,"not supported, using",e,"instead."));let r,v;if(u){const a=W[u];r=a.vertexShader,v=a.fragmentShader}else r=b.vertexShader,v=b.fragmentShader;const w=a.getRenderTarget(),B={isWebGL2:f,shaderID:u,shaderName:b.type,vertexShader:r,fragmentShader:v,defines:b.defines,isRawShaderMaterial:b.isRawShaderMaterial===!0,glslVersion:b.glslVersion,precision:e,instancing:k.isInstancedMesh===!0,instancingColor:k.isInstancedMesh===!0&&k.instanceColor!==null,supportsVertexTextures:l,outputEncoding:w!==null?d(w.texture):a.outputEncoding,map:!!b.map,mapEncoding:d(b.map),matcap:!!b.matcap,matcapEncoding:d(b.matcap),envMap:!!o,envMapMode:o&&o.mapping,envMapEncoding:d(o),envMapCubeUV:!!o&&(o.mapping===dm||o.mapping===dp),lightMap:!!b.lightMap,lightMapEncoding:d(b.lightMap),aoMap:!!b.aoMap,emissiveMap:!!b.emissiveMap,emissiveMapEncoding:d(b.emissiveMap),bumpMap:!!b.bumpMap,normalMap:!!b.normalMap,objectSpaceNormalMap:b.normalMapType===lw,tangentSpaceNormalMap:b.normalMapType===aS,clearcoatMap:!!b.clearcoatMap,clearcoatRoughnessMap:!!b.clearcoatRoughnessMap,clearcoatNormalMap:!!b.clearcoatNormalMap,displacementMap:!!b.displacementMap,roughnessMap:!!b.roughnessMap,metalnessMap:!!b.metalnessMap,specularMap:!!b.specularMap,alphaMap:!!b.alphaMap,gradientMap:!!b.gradientMap,sheen:!!b.sheen,transmissionMap:!!b.transmissionMap,combine:b.combine,vertexTangents:b.normalMap&&b.vertexTangents,vertexColors:b.vertexColors,vertexAlphas:b.vertexColors===!0&&k.geometry&&k.geometry.attributes.color&&k.geometry.attributes.color.itemSize===4,vertexUvs:!!b.map||!!b.bumpMap||!!b.normalMap||!!b.specularMap||!!b.alphaMap||!!b.emissiveMap||!!b.roughnessMap||!!b.metalnessMap||!!b.clearcoatMap||!!b.clearcoatRoughnessMap||!!b.clearcoatNormalMap||!!b.displacementMap||!!b.transmissionMap,uvsVertexOnly:!(!!b.map||!!b.bumpMap||!!b.normalMap||!!b.specularMap||!!b.alphaMap||!!b.emissiveMap||!!b.roughnessMap||!!b.metalnessMap||!!b.clearcoatNormalMap||!!b.transmissionMap)&&!!b.displacementMap,fog:!!s,useFog:b.fog,fogExp2:s&&s.isFogExp2,flatShading:!!b.flatShading,sizeAttenuation:b.sizeAttenuation,logarithmicDepthBuffer:n,skinning:b.skinning&&x>0,maxBones:x,useVertexTexture:j,morphTargets:b.morphTargets,morphNormals:b.morphNormals,numDirLights:m.directional.length,numPointLights:m.point.length,numSpotLights:m.spot.length,numRectAreaLights:m.rectArea.length,numHemiLights:m.hemi.length,numDirLightShadows:m.directionalShadowMap.length,numPointLightShadows:m.pointShadowMap.length,numSpotLightShadows:m.spotShadowMap.length,numClippingPlanes:h.numPlanes,numClipIntersection:h.numIntersection,dithering:b.dithering,shadowMapEnabled:a.shadowMap.enabled&&z.length>0,shadowMapType:a.shadowMap.type,toneMapping:b.toneMapped?a.toneMapping:bd,physicallyCorrectLights:a.physicallyCorrectLights,premultipliedAlpha:b.premultipliedAlpha,alphaTest:b.alphaTest,doubleSided:b.side===bj,flipSided:b.side===t,depthPacking:b.depthPacking!==void 0&&b.depthPacking,index0AttributeName:b.index0AttributeName,extensionDerivatives:b.extensions&&b.extensions.derivatives,extensionFragDepth:b.extensions&&b.extensions.fragDepth,extensionDrawBuffers:b.extensions&&b.extensions.drawBuffers,extensionShaderTextureLOD:b.extensions&&b.extensions.shaderTextureLOD,rendererExtensionFragDepth:f||g.has("EXT_frag_depth"),rendererExtensionDrawBuffers:f||g.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:f||g.has("EXT_shader_texture_lod"),customProgramCacheKey:b.customProgramCacheKey()};return B}function s(b){const c=[];if(b.shaderID?c.push(b.shaderID):(c.push(b.fragmentShader),c.push(b.vertexShader)),b.defines!==void 0)for(const a in b.defines)c.push(a),c.push(b.defines[a]);if(b.isRawShaderMaterial===!1){for(let a=0;a<k.length;a++)c.push(b[k[a]]);c.push(a.outputEncoding),c.push(a.gammaFactor)}return c.push(b.customProgramCacheKey),c.join()}function u(b){const c=i[b.type];let a;if(c){const b=W[c];a=kC.clone(b.uniforms)}else a=b.uniforms;return a}function v(e,d){let c;for(let a=0,f=b.length;a<f;a++){const e=b[a];if(e.cacheKey===d){c=e,++c.usedTimes;break}}return c===void 0&&(c=new jt(a,d,e,o),b.push(c)),c}function w(a){if(--a.usedTimes===0){const c=b.indexOf(a);b[c]=b[b.length-1],b.pop(),a.destroy()}}return{getParameters:r,getProgramCacheKey:s,getUniforms:u,acquireProgram:v,releaseProgram:w,programs:b}}function jv(){let a=new WeakMap;function b(c){let b=a.get(c);return b===void 0&&(b={},a.set(c,b)),b}function c(b){a.delete(b)}function d(b,c,d){a.get(b)[c]=d}function e(){a=new WeakMap}return{get:b,remove:c,update:d,dispose:e}}function jw(a,b){return a.groupOrder!==b.groupOrder?a.groupOrder-b.groupOrder:a.renderOrder!==b.renderOrder?a.renderOrder-b.renderOrder:a.program!==b.program?a.program.id-b.program.id:a.material.id!==b.material.id?a.material.id-b.material.id:a.z!==b.z?a.z-b.z:a.id-b.id}function jx(a,b){return a.groupOrder!==b.groupOrder?a.groupOrder-b.groupOrder:a.renderOrder!==b.renderOrder?a.renderOrder-b.renderOrder:a.z!==b.z?b.z-a.z:a.id-b.id}function fH(g){const d=[];let c=0;const a=[],b=[],e={id:-1};function h(){c=0,a.length=0,b.length=0}function f(b,h,f,i,j,k){let a=d[c];const l=g.get(f);return a===void 0?(a={id:b.id,object:b,geometry:h,material:f,program:l.program||e,groupOrder:i,renderOrder:b.renderOrder,z:j,group:k},d[c]=a):(a.id=b.id,a.object=b,a.geometry=h,a.material=f,a.program=l.program||e,a.groupOrder=i,a.renderOrder=b.renderOrder,a.z=j,a.group=k),c++,a}function i(d,e,c,g,h,i){const j=f(d,e,c,g,h,i);(c.transparent===!0?b:a).push(j)}function j(d,e,c,g,h,i){const j=f(d,e,c,g,h,i);(c.transparent===!0?b:a).unshift(j)}function k(c,d){a.length>1&&a.sort(c||jw),b.length>1&&b.sort(d||jx)}function l(){for(let b=c,e=d.length;b<e;b++){const a=d[b];if(a.id===null)break;a.id=null,a.object=null,a.geometry=null,a.material=null,a.program=null,a.group=null}}return{opaque:a,transparent:b,init:h,push:i,unshift:j,finish:l,sort:k}}function jz(b){let a=new WeakMap;function c(d,e){let c;return a.has(d)===!1?(c=new fH(b),a.set(d,[c])):e>=a.get(d).length?(c=new fH(b),a.get(d).push(c)):c=a.get(d)[e],c}function d(){a=new WeakMap}return{get:c,dispose:d}}function jA(){const b={};return{get:function(e){if(b[e.id]!==void 0)return b[e.id];let c;switch(e.type){case"DirectionalLight":c={direction:new a,color:new d};break;case"SpotLight":c={position:new a,direction:new a,color:new d,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":c={position:new a,color:new d,distance:0,decay:0};break;case"HemisphereLight":c={direction:new a,skyColor:new d,groundColor:new d};break;case"RectAreaLight":c={color:new d,position:new a,halfWidth:new a,halfHeight:new a};break}return b[e.id]=c,c}}}function jB(){const a={};return{get:function(d){if(a[d.id]!==void 0)return a[d.id];let c;switch(d.type){case"DirectionalLight":c={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new b};break;case"SpotLight":c={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new b};break;case"PointLight":c={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new b,shadowCameraNear:1,shadowCameraFar:1e3};break}return a[d.id]=c,c}}}jC=0;function jD(a,b){return(b.castShadow?1:0)-(a.castShadow?1:0)}function jE(j,k){const d=new jA,i=jB(),b={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let c=0;c<9;c++)b.probe.push(new a);const g=new a,h=new e,f=new e;function l(p){let s=0,r=0,q=0;for(let a=0;a<9;a++)b.probe[a].set(0,0,0);let e=0,f=0,g=0,m=0,o=0,n=0,h=0,l=0;p.sort(jD);for(let k=0,u=p.length;k<u;k++){const a=p[k],j=a.color,c=a.intensity,v=a.distance,t=a.shadow&&a.shadow.map?a.shadow.map.texture:null;if(a.isAmbientLight)s+=j.r*c,r+=j.g*c,q+=j.b*c;else if(a.isLightProbe)for(let d=0;d<9;d++)b.probe[d].addScaledVector(a.sh.coefficients[d],c);else if(a.isDirectionalLight){const c=d.get(a);if(c.color.copy(a.color).multiplyScalar(a.intensity),a.castShadow){const d=a.shadow,c=i.get(a);c.shadowBias=d.bias,c.shadowNormalBias=d.normalBias,c.shadowRadius=d.radius,c.shadowMapSize=d.mapSize,b.directionalShadow[e]=c,b.directionalShadowMap[e]=t,b.directionalShadowMatrix[e]=a.shadow.matrix,n++}b.directional[e]=c,e++}else if(a.isSpotLight){const e=d.get(a);if(e.position.setFromMatrixPosition(a.matrixWorld),e.color.copy(j).multiplyScalar(c),e.distance=v,e.coneCos=Math.cos(a.angle),e.penumbraCos=Math.cos(a.angle*(1-a.penumbra)),e.decay=a.decay,a.castShadow){const d=a.shadow,c=i.get(a);c.shadowBias=d.bias,c.shadowNormalBias=d.normalBias,c.shadowRadius=d.radius,c.shadowMapSize=d.mapSize,b.spotShadow[g]=c,b.spotShadowMap[g]=t,b.spotShadowMatrix[g]=a.shadow.matrix,l++}b.spot[g]=e,g++}else if(a.isRectAreaLight){const e=d.get(a);e.color.copy(j).multiplyScalar(c),e.halfWidth.set(a.width*.5,0,0),e.halfHeight.set(0,a.height*.5,0),b.rectArea[m]=e,m++}else if(a.isPointLight){const c=d.get(a);if(c.color.copy(a.color).multiplyScalar(a.intensity),c.distance=a.distance,c.decay=a.decay,a.castShadow){const d=a.shadow,c=i.get(a);c.shadowBias=d.bias,c.shadowNormalBias=d.normalBias,c.shadowRadius=d.radius,c.shadowMapSize=d.mapSize,c.shadowCameraNear=d.camera.near,c.shadowCameraFar=d.camera.far,b.pointShadow[f]=c,b.pointShadowMap[f]=t,b.pointShadowMatrix[f]=a.shadow.matrix,h++}b.point[f]=c,f++}else if(a.isHemisphereLight){const e=d.get(a);e.skyColor.copy(a.color).multiplyScalar(c),e.groundColor.copy(a.groundColor).multiplyScalar(c),b.hemi[o]=e,o++}}m>0&&(k.isWebGL2?(b.rectAreaLTC1=c.LTC_FLOAT_1,b.rectAreaLTC2=c.LTC_FLOAT_2):j.has("OES_texture_float_linear")===!0?(b.rectAreaLTC1=c.LTC_FLOAT_1,b.rectAreaLTC2=c.LTC_FLOAT_2):j.has("OES_texture_half_float_linear")===!0?(b.rectAreaLTC1=c.LTC_HALF_1,b.rectAreaLTC2=c.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),b.ambient[0]=s,b.ambient[1]=r,b.ambient[2]=q;const a=b.hash;(a.directionalLength!==e||a.pointLength!==f||a.spotLength!==g||a.rectAreaLength!==m||a.hemiLength!==o||a.numDirectionalShadows!==n||a.numPointShadows!==h||a.numSpotShadows!==l)&&(b.directional.length=e,b.spot.length=g,b.rectArea.length=m,b.point.length=f,b.hemi.length=o,b.directionalShadow.length=n,b.directionalShadowMap.length=n,b.pointShadow.length=h,b.pointShadowMap.length=h,b.spotShadow.length=l,b.spotShadowMap.length=l,b.directionalShadowMatrix.length=n,b.pointShadowMatrix.length=h,b.spotShadowMatrix.length=l,a.directionalLength=e,a.pointLength=f,a.spotLength=g,a.rectAreaLength=m,a.hemiLength=o,a.numDirectionalShadows=n,a.numPointShadows=h,a.numSpotShadows=l,b.version=jC++)}function m(c,l){let d=0,e=0,i=0,j=0,k=0;const a=l.matrixWorldInverse;for(let m=0,n=c.length;m<n;m++){const l=c[m];if(l.isDirectionalLight){const c=b.directional[d];c.direction.setFromMatrixPosition(l.matrixWorld),g.setFromMatrixPosition(l.target.matrixWorld),c.direction.sub(g),c.direction.transformDirection(a),d++}else if(l.isSpotLight){const c=b.spot[i];c.position.setFromMatrixPosition(l.matrixWorld),c.position.applyMatrix4(a),c.direction.setFromMatrixPosition(l.matrixWorld),g.setFromMatrixPosition(l.target.matrixWorld),c.direction.sub(g),c.direction.transformDirection(a),i++}else if(l.isRectAreaLight){const c=b.rectArea[j];c.position.setFromMatrixPosition(l.matrixWorld),c.position.applyMatrix4(a),f.identity(),h.copy(l.matrixWorld),h.premultiply(a),f.extractRotation(h),c.halfWidth.set(l.width*.5,0,0),c.halfHeight.set(0,l.height*.5,0),c.halfWidth.applyMatrix4(f),c.halfHeight.applyMatrix4(f),j++}else if(l.isPointLight){const c=b.point[e];c.position.setFromMatrixPosition(l.matrixWorld),c.position.applyMatrix4(a),e++}else if(l.isHemisphereLight){const c=b.hemi[k];c.direction.setFromMatrixPosition(l.matrixWorld),c.direction.transformDirection(a),c.direction.normalize(),k++}}}return{setup:l,setupView:m,state:b}}function fG(d,e){const b=new jE(d,e),a=[],c=[];function f(){a.length=0,c.length=0}function g(b){a.push(b)}function h(a){c.push(a)}function i(){b.setup(a)}function j(c){b.setupView(a,c)}const k={lightsArray:a,shadowsArray:c,lights:b};return{init:f,state:k,setupLights:i,setupLightsView:j,pushLight:g,pushShadow:h}}function jG(b,c){let a=new WeakMap;function d(e,f=0){let d;return a.has(e)===!1?(d=new fG(b,c),a.set(e,[d])):f>=a.get(e).length?(d=new fG(b,c),a.get(e).push(d)):d=a.get(e)[f],d}function e(){a=new WeakMap}return{get:d,dispose:e}}fF=class extends r{constructor(a){super(),this.type="MeshDepthMaterial",this.depthPacking=ly,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(a)}copy(a){return super.copy(a),this.depthPacking=a.depthPacking,this.skinning=a.skinning,this.morphTargets=a.morphTargets,this.map=a.map,this.alphaMap=a.alphaMap,this.displacementMap=a.displacementMap,this.displacementScale=a.displacementScale,this.displacementBias=a.displacementBias,this.wireframe=a.wireframe,this.wireframeLinewidth=a.wireframeLinewidth,this}},fF.prototype.isMeshDepthMaterial=!0,fE=class extends r{constructor(b){super(),this.type="MeshDistanceMaterial",this.referencePosition=new a,this.nearDistance=1,this.farDistance=1e3,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(b)}copy(a){return super.copy(a),this.referencePosition.copy(a.referencePosition),this.nearDistance=a.nearDistance,this.farDistance=a.farDistance,this.skinning=a.skinning,this.morphTargets=a.morphTargets,this.map=a.map,this.alphaMap=a.alphaMap,this.displacementMap=a.displacementMap,this.displacementScale=a.displacementScale,this.displacementBias=a.displacementBias,this}},fE.prototype.isMeshDistanceMaterial=!0,jJ="uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean * HALF_SAMPLE_RATE;\n	squared_mean = squared_mean * HALF_SAMPLE_RATE;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",jK="void main() {\n	gl_Position = vec4( position, 1.0 );\n}";function fD(a,q,z){let o=new cm;const c=new b,d=new b,n=new i,k=[],s=[],m={},e=z.maxTextureSize,B={0:t,1:cl,2:bj},f=new ak({defines:{SAMPLE_RATE:2/8,HALF_SAMPLE_RATE:1/8},uniforms:{shadow_pass:{value:null},resolution:{value:new b},radius:{value:4}},vertexShader:jK,fragmentShader:jJ}),g=f.clone();g.defines.HORIZONTAL_PASS=1;const r=new l;r.setAttribute("position",new u(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const j=new K(r,f),h=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=f_,this.render=function(f,i,g){if(h.enabled===!1)return;if(h.autoUpdate===!1&&h.needsUpdate===!1)return;if(f.length===0)return;const j=a.getRenderTarget(),k=a.getActiveCubeFace(),l=a.getActiveMipmapLevel(),b=a.state;b.setBlending(be),b.buffers.color.setClear(1,1,1,1),b.buffers.depth.setTest(!0),b.setScissorTest(!1);for(let l=0,m=f.length;l<m;l++){const j=f[l],h=j.shadow;if(h===void 0){console.warn("THREE.WebGLShadowMap:",j,"has no shadow.");continue}if(h.autoUpdate===!1&&h.needsUpdate===!1)continue;c.copy(h.mapSize);const k=h.getFrameExtents();if(c.multiply(k),d.copy(h.mapSize),(c.x>e||c.y>e)&&(c.x>e&&(d.x=Math.floor(e/k.x),c.x=d.x*k.x,h.mapSize.x=d.x),c.y>e&&(d.y=Math.floor(e/k.y),c.y=d.y*k.y,h.mapSize.y=d.y)),h.map===null&&!h.isPointLightShadow&&this.type===bt){const a={minFilter:I,magFilter:I,format:N};h.map=new ap(c.x,c.y,a),h.map.texture.name=j.name+".shadowMap",h.mapPass=new ap(c.x,c.y,a),h.camera.updateProjectionMatrix()}if(h.map===null){const a={minFilter:A,magFilter:A,format:N};h.map=new ap(c.x,c.y,a),h.map.texture.name=j.name+".shadowMap",h.camera.updateProjectionMatrix()}a.setRenderTarget(h.map),a.clear();const p=h.getViewportCount();for(let a=0;a<p;a++){const c=h.getViewport(a);n.set(d.x*c.x,d.y*c.y,d.x*c.z,d.y*c.w),b.viewport(n),h.updateMatrices(j,a),o=h.getFrustum(),v(i,g,h.camera,j,this.type)}!h.isPointLightShadow&&this.type===bt&&w(h,g),h.needsUpdate=!1}h.needsUpdate=!1,a.setRenderTarget(j,k,l)};function w(b,c){const d=q.update(j);f.uniforms.shadow_pass.value=b.map.texture,f.uniforms.resolution.value=b.mapSize,f.uniforms.radius.value=b.radius,a.setRenderTarget(b.mapPass),a.clear(),a.renderBufferDirect(c,null,d,f,j,null),g.uniforms.shadow_pass.value=b.mapPass.texture,g.uniforms.resolution.value=b.mapSize,g.uniforms.radius.value=b.radius,a.setRenderTarget(b.map),a.clear(),a.renderBufferDirect(c,null,d,g,j,null)}function x(b,c,e){const d=b<<0|c<<1|e<<2;let a=k[d];return a===void 0&&(a=new fF({depthPacking:lx,morphTargets:b,skinning:c}),k[d]=a),a}function y(b,c,e){const d=b<<0|c<<1|e<<2;let a=s[d];return a===void 0&&(a=new fE({morphTargets:b,skinning:c}),s[d]=a),a}function p(d,f,c,e,i,j,k){let b=null,h=x,g=d.customDepthMaterial;if(e.isPointLight===!0&&(h=y,g=d.customDistanceMaterial),g===void 0){let a=!1;c.morphTargets===!0&&(a=f.morphAttributes&&f.morphAttributes.position&&f.morphAttributes.position.length>0);let e=!1;d.isSkinnedMesh===!0&&(c.skinning===!0?e=!0:console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",d));const g=d.isInstancedMesh===!0;b=h(a,e,g)}else b=g;if(a.localClippingEnabled&&c.clipShadows===!0&&c.clippingPlanes.length!==0){const e=b.uuid,f=c.uuid;let a=m[e];a===void 0&&(a={},m[e]=a);let d=a[f];d===void 0&&(d=b.clone(),a[f]=d),b=d}return b.visible=c.visible,b.wireframe=c.wireframe,k===bt?b.side=c.shadowSide!==null?c.shadowSide:c.side:b.side=c.shadowSide!==null?c.shadowSide:B[c.side],b.clipShadows=c.clipShadows,b.clippingPlanes=c.clippingPlanes,b.clipIntersection=c.clipIntersection,b.wireframeLinewidth=c.wireframeLinewidth,b.linewidth=c.linewidth,e.isPointLight===!0&&b.isMeshDistanceMaterial===!0&&(b.referencePosition.setFromMatrixPosition(e.matrixWorld),b.nearDistance=i,b.farDistance=j),b}function v(b,f,c,e,d){if(b.visible===!1)return;const h=b.layers.test(f.layers);if(h&&(b.isMesh||b.isLine||b.isPoints))if((b.castShadow||b.receiveShadow&&d===bt)&&(!b.frustumCulled||o.intersectsObject(b))){b.modelViewMatrix.multiplyMatrices(c.matrixWorldInverse,b.matrixWorld);const f=q.update(b),g=b.material;if(Array.isArray(g)){{const h=f.groups;for(let i=0,l=h.length;i<l;i++){const k=h[i],j=g[k.materialIndex];if(j&&j.visible){const g=p(b,f,j,e,c.near,c.far,d);a.renderBufferDirect(c,null,f,g,b,k)}}}}else if(g.visible){const h=p(b,f,g,e,c.near,c.far,d);a.renderBufferDirect(c,null,f,h,b,null)}}const g=b.children;for(let a=0,b=g.length;a<b;a++)v(g[a],f,c,e,d)}}function jM(a,X,V){const I=V.isWebGL2;function U(){let b=!1;const c=new i;let d=null;const e=new i(0,0,0,0);return{setMask:function(c){d!==c&&!b&&(a.colorMask(c,c,c,c),d=c)},setLocked:function(a){b=a},setClear:function(d,f,g,b,h){h===!0&&(d*=b,f*=b,g*=b),c.set(d,f,g,b),e.equals(c)===!1&&(a.clearColor(d,f,g,b),e.copy(c))},reset:function(){b=!1,d=null,e.set(-1,0,0,0)}}}function T(){let d=!1,e=null,f=null,g=null;return{setTest:function(a){a?b(2929):c(2929)},setMask:function(b){e!==b&&!d&&(a.depthMask(b),e=b)},setFunc:function(b){if(f!==b){if(b)switch(b){case nL:a.depthFunc(512);break;case nH:a.depthFunc(519);break;case nB:a.depthFunc(513);break;case cG:a.depthFunc(515);break;case ns:a.depthFunc(514);break;case nr:a.depthFunc(518);break;case nn:a.depthFunc(516);break;case nm:a.depthFunc(517);break;default:a.depthFunc(515)}else a.depthFunc(515);f=b}},setLocked:function(a){d=a},setClear:function(b){g!==b&&(a.clearDepth(b),g=b)},reset:function(){d=!1,e=null,f=null,g=null}}}function _(){let d=!1,e=null,f=null,g=null,h=null,i=null,j=null,k=null,l=null;return{setTest:function(a){d||(a?b(2960):c(2960))},setMask:function(b){e!==b&&!d&&(a.stencilMask(b),e=b)},setFunc:function(b,c,d){(f!==b||g!==c||h!==d)&&(a.stencilFunc(b,c,d),f=b,g=c,h=d)},setOp:function(b,c,d){(i!==b||j!==c||k!==d)&&(a.stencilOp(b,c,d),i=b,j=c,k=d)},setLocked:function(a){d=a},setClear:function(b){l!==b&&(a.clearStencil(b),l=b)},reset:function(){d=!1,e=null,f=null,g=null,h=null,i=null,j=null,k=null,l=null}}}const p=new U,d=new T,f=new _;let l={},h=null,m={},H=null,n=!1,q=null,k=null,s=null,o=null,j=null,w=null,x=null,y=!1,M=null,G=null,E=null,C=null,D=null;const aa=a.getParameter(35661);let F=!1,z=0;const u=a.getParameter(7938);u.indexOf("WebGL")!==-1?(z=parseFloat(/^WebGL (\d)/.exec(u)[1]),F=z>=1):u.indexOf("OpenGL ES")!==-1&&(z=parseFloat(/^OpenGL ES (\d)/.exec(u)[1]),F=z>=2);let e=null,v={};const K=new i(0,0,a.canvas.width,a.canvas.height),L=new i(0,0,a.canvas.width,a.canvas.height);function Q(b,d,e){const f=new Uint8Array(4),c=a.createTexture();a.bindTexture(b,c),a.texParameteri(b,10241,9728),a.texParameteri(b,10240,9728);for(let b=0;b<e;b++)a.texImage2D(d+b,0,6408,1,1,0,6408,5121,f);return c}const B={};B[3553]=Q(3553,3553,1),B[34067]=Q(34067,34069,6),p.setClear(0,0,0,1),d.setClear(1),f.setClear(0),b(2929),d.setFunc(cG),J(!1),N(gj),b(2884),r(be);function b(b){l[b]!==!0&&(a.enable(b),l[b]=!0)}function c(b){l[b]!==!1&&(a.disable(b),l[b]=!1)}function Z(b){b!==h&&(a.bindFramebuffer(36160,b),h=b)}function Y(c,b){b===null&&h!==null&&(b=h),m[c]!==b&&(a.bindFramebuffer(c,b),m[c]=b,I&&(c===36009&&(m[36160]=b),c===36160&&(m[36009]=b)))}function S(b){return H!==b&&(a.useProgram(b),H=b,!0)}const g={[bc]:32774,[om]:32778,[ok]:32779};if(I)g[fL]=32775,g[fB]=32776;else{const a=X.get("EXT_blend_minmax");a!==null&&(g[fL]=a.MIN_EXT,g[fB]=a.MAX_EXT)}const A={[oj]:0,[oi]:1,[oe]:768,[fz]:770,[nN]:776,[n_]:774,[oc]:772,[od]:769,[fw]:771,[nW]:775,[ob]:773};function r(d,i,l,m,e,f,h,p){if(d===be){n===!0&&(c(3042),n=!1);return}if(n===!1&&(b(3042),n=!0),d!==or){if(d!==q||p!==y){if((k!==bc||j!==bc)&&(a.blendEquation(32774),k=bc,j=bc),p)switch(d){case bg:a.blendFuncSeparate(1,771,1,771);break;case fY:a.blendFunc(1,1);break;case fV:a.blendFuncSeparate(0,0,769,771);break;case fT:a.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",d);break}else switch(d){case bg:a.blendFuncSeparate(770,771,1,771);break;case fY:a.blendFunc(770,1);break;case fV:a.blendFunc(0,769);break;case fT:a.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",d);break}s=null,o=null,w=null,x=null,q=d,y=p}return}e=e||i,f=f||l,h=h||m,(i!==k||e!==j)&&(a.blendEquationSeparate(g[i],g[e]),k=i,j=e),(l!==s||m!==o||f!==w||h!==x)&&(a.blendFuncSeparate(A[l],A[m],A[f],A[h]),s=l,o=m,w=f,x=h),q=d,y=null}function W(a,h){a.side===bj?c(2884):b(2884);let e=a.side===t;h&&(e=!e),J(e),a.blending===bg&&a.transparent===!1?r(be):r(a.blending,a.blendEquation,a.blendSrc,a.blendDst,a.blendEquationAlpha,a.blendSrcAlpha,a.blendDstAlpha,a.premultipliedAlpha),d.setFunc(a.depthFunc),d.setTest(a.depthTest),d.setMask(a.depthWrite),p.setMask(a.colorWrite);const g=a.stencilWrite;f.setTest(g),g&&(f.setMask(a.stencilWriteMask),f.setFunc(a.stencilFunc,a.stencilRef,a.stencilFuncMask),f.setOp(a.stencilFail,a.stencilZFail,a.stencilZPass)),P(a.polygonOffset,a.polygonOffsetFactor,a.polygonOffsetUnits),a.alphaToCoverage===!0?b(32926):c(32926)}function J(b){M!==b&&(b?a.frontFace(2304):a.frontFace(2305),M=b)}function N(d){d!==k$?(b(2884),d!==G&&(d===gj?a.cullFace(1029):d===op?a.cullFace(1028):a.cullFace(1032))):c(2884),G=d}function R(b){b!==E&&(F&&a.lineWidth(b),E=b)}function P(f,d,e){f?(b(32823),(C!==d||D!==e)&&(a.polygonOffset(d,e),C=d,D=e)):c(32823)}function $(a){a?b(3089):c(3089)}function O(b){b===void 0&&(b=33984+aa-1),e!==b&&(a.activeTexture(b),e=b)}function ab(c,d){e===null&&O();let b=v[e];b===void 0&&(b={type:void 0,texture:void 0},v[e]=b),(b.type!==c||b.texture!==d)&&(a.bindTexture(c,d||B[c]),b.type=c,b.texture=d)}function ac(){const b=v[e];b!==void 0&&b.type!==void 0&&(a.bindTexture(b.type,null),b.type=void 0,b.texture=void 0)}function ad(){try{a.compressedTexImage2D.apply(a,arguments)}catch(a){console.error("THREE.WebGLState:",a)}}function ae(){try{a.texImage2D.apply(a,arguments)}catch(a){console.error("THREE.WebGLState:",a)}}function af(){try{a.texImage3D.apply(a,arguments)}catch(a){console.error("THREE.WebGLState:",a)}}function ag(b){K.equals(b)===!1&&(a.scissor(b.x,b.y,b.z,b.w),K.copy(b))}function ah(b){L.equals(b)===!1&&(a.viewport(b.x,b.y,b.z,b.w),L.copy(b))}function ai(){a.disable(3042),a.disable(2884),a.disable(2929),a.disable(32823),a.disable(3089),a.disable(2960),a.disable(32926),a.blendEquation(32774),a.blendFunc(1,0),a.blendFuncSeparate(1,0,1,0),a.colorMask(!0,!0,!0,!0),a.clearColor(0,0,0,0),a.depthMask(!0),a.depthFunc(513),a.clearDepth(1),a.stencilMask(4294967295),a.stencilFunc(519,0,4294967295),a.stencilOp(7680,7680,7680),a.clearStencil(0),a.cullFace(1029),a.frontFace(2305),a.polygonOffset(0,0),a.activeTexture(33984),a.bindFramebuffer(36160,null),I===!0&&(a.bindFramebuffer(36009,null),a.bindFramebuffer(36008,null)),a.useProgram(null),a.lineWidth(1),a.scissor(0,0,a.canvas.width,a.canvas.height),a.viewport(0,0,a.canvas.width,a.canvas.height),l={},e=null,v={},h=null,m={},H=null,n=!1,q=null,k=null,s=null,o=null,j=null,w=null,x=null,y=!1,M=null,G=null,E=null,C=null,D=null,K.set(0,0,a.canvas.width,a.canvas.height),L.set(0,0,a.canvas.width,a.canvas.height),p.reset(),d.reset(),f.reset()}return{buffers:{color:p,depth:d,stencil:f},enable:b,disable:c,bindFramebuffer:Y,bindXRFramebuffer:Z,useProgram:S,setBlending:r,setMaterial:W,setFlipSided:J,setCullFace:N,setLineWidth:R,setPolygonOffset:P,setScissorTest:$,activeTexture:O,bindTexture:ab,unbindTexture:ac,compressedTexImage2D:ad,texImage2D:ae,texImage3D:af,scissor:ag,viewport:ah,reset:ai}}function jN(a,h,b,c,f,e,g){const d=f.isWebGL2,G=f.maxTextures,aa=f.maxCubemapSize,$=f.maxTextureSize,Z=f.maxSamples,s=new WeakMap;let o,C=!1;try{C=typeof OffscreenCanvas!="undefined"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch(a){}function B(a,b){return C?new OffscreenCanvas(a,b):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function z(a,d,e,c){let b=1;if((a.width>c||a.height>c)&&(b=c/Math.max(a.width,a.height)),b<1||d===!0){if(typeof HTMLImageElement!="undefined"&&a instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&a instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&a instanceof ImageBitmap){const h=d?lf:Math.floor,c=h(b*a.width),f=h(b*a.height);o===void 0&&(o=B(c,f));const g=e?B(c,f):o;g.width=c,g.height=f;const i=g.getContext("2d");return i.drawImage(a,0,0,c,f),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+a.width+"x"+a.height+") to ("+c+"x"+f+")."),g}return"data"in a&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+a.width+"x"+a.height+")."),a}return a}function j(a){return el(a.width)&&el(a.height)}function Y(a){return!d&&(a.wrapS!==O||a.wrapT!==O||a.minFilter!==A&&a.minFilter!==I)}function l(a,b){return a.generateMipmaps&&b&&a.minFilter!==A&&a.minFilter!==I}function k(b,d,e,f){a.generateMipmap(b);const g=c.get(d);g.__maxMipLevel=Math.log2(Math.max(e,f))}function i(f,e,c){if(d===!1)return e;if(f!==null){if(a[f]!==void 0)return a[f];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+f+"'")}let b=e;return e===6403&&(c===5126&&(b=33326),c===5131&&(b=33325),c===5121&&(b=33321)),e===6407&&(c===5126&&(b=34837),c===5131&&(b=34843),c===5121&&(b=32849)),e===6408&&(c===5126&&(b=34836),c===5131&&(b=34842),c===5121&&(b=32856)),(b===33325||b===33326||b===34842||b===34836)&&h.get("EXT_color_buffer_float"),b}function w(a){return a===A||a===fe||a===eX?9728:9729}function x(b){const a=b.target;a.removeEventListener("dispose",x),T(a),a.isVideoTexture&&s.delete(a),g.memory.textures--}function y(b){const a=b.target;a.removeEventListener("dispose",y),K(a),g.memory.textures--}function T(b){const d=c.get(b);if(d.__webglInit===void 0)return;a.deleteTexture(d.__webglTexture),c.remove(b)}function K(d){const e=d.texture,b=c.get(d),f=c.get(e);if(!d)return;if(f.__webglTexture!==void 0&&a.deleteTexture(f.__webglTexture),d.depthTexture&&d.depthTexture.dispose(),d.isWebGLCubeRenderTarget){for(let c=0;c<6;c++)a.deleteFramebuffer(b.__webglFramebuffer[c]),b.__webglDepthbuffer&&a.deleteRenderbuffer(b.__webglDepthbuffer[c])}else a.deleteFramebuffer(b.__webglFramebuffer),b.__webglDepthbuffer&&a.deleteRenderbuffer(b.__webglDepthbuffer),b.__webglMultisampledFramebuffer&&a.deleteFramebuffer(b.__webglMultisampledFramebuffer),b.__webglColorRenderbuffer&&a.deleteRenderbuffer(b.__webglColorRenderbuffer),b.__webglDepthRenderbuffer&&a.deleteRenderbuffer(b.__webglDepthRenderbuffer);c.remove(e),c.remove(d)}let p=0;function Q(){p=0}function P(){const a=p;return a>=G&&console.warn("THREE.WebGLTextures: Trying to use "+a+" texture units while this GPU supports only "+G),p+=1,a}function r(a,e){const d=c.get(a);if(a.isVideoTexture&&_(a),a.version>0&&d.__version!==a.version){const b=a.image;if(b===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if(b.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{t(d,a,e);return}}b.activeTexture(33984+e),b.bindTexture(3553,d.__webglTexture)}function M(a,e){const d=c.get(a);if(a.version>0&&d.__version!==a.version){t(d,a,e);return}b.activeTexture(33984+e),b.bindTexture(35866,d.__webglTexture)}function L(a,e){const d=c.get(a);if(a.version>0&&d.__version!==a.version){t(d,a,e);return}b.activeTexture(33984+e),b.bindTexture(32879,d.__webglTexture)}function J(a,e){const d=c.get(a);if(a.version>0&&d.__version!==a.version){R(d,a,e);return}b.activeTexture(33984+e),b.bindTexture(34067,d.__webglTexture)}const u={[dq]:10497,[O]:33071,[dr]:33648},H={[A]:9728,[fe]:9984,[eX]:9986,[I]:9729,[nc]:9985,[dD]:9987};function m(e,b,g){if(g?(a.texParameteri(e,10242,u[b.wrapS]),a.texParameteri(e,10243,u[b.wrapT]),(e===32879||e===35866)&&a.texParameteri(e,32882,u[b.wrapR]),a.texParameteri(e,10240,H[b.magFilter]),a.texParameteri(e,10241,H[b.minFilter])):(a.texParameteri(e,10242,33071),a.texParameteri(e,10243,33071),(e===32879||e===35866)&&a.texParameteri(e,32882,33071),(b.wrapS!==O||b.wrapT!==O)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),a.texParameteri(e,10240,w(b.magFilter)),a.texParameteri(e,10241,w(b.minFilter)),b.minFilter!==A&&b.minFilter!==I&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),h.has("EXT_texture_filter_anisotropic")===!0){const g=h.get("EXT_texture_filter_anisotropic");if(b.type===ac&&h.has("OES_texture_float_linear")===!1)return;if(d===!1&&b.type===cw&&h.has("OES_texture_half_float_linear")===!1)return;(b.anisotropy>1||c.get(b).__currentAnisotropy)&&(a.texParameterf(e,g.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(b.anisotropy,f.getMaxAnisotropy())),c.get(b).__currentAnisotropy=b.anisotropy)}}function E(b,c){b.__webglInit===void 0&&(b.__webglInit=!0,c.addEventListener("dispose",x),b.__webglTexture=a.createTexture(),g.memory.textures++)}function t(p,c,t){let r=3553;c.isDataTexture2DArray&&(r=35866),c.isDataTexture3D&&(r=32879),E(p,c),b.activeTexture(33984+t),b.bindTexture(r,p.__webglTexture),a.pixelStorei(37440,c.flipY),a.pixelStorei(37441,c.premultiplyAlpha),a.pixelStorei(3317,c.unpackAlignment),a.pixelStorei(37443,0);const u=Y(c)&&j(c.image)===!1,g=z(c.image,u,!1,$),s=j(g)||d,q=e.convert(c.format);let n=e.convert(c.type),f=i(c.internalFormat,q,n);m(r,c,s);let h;const o=c.mipmaps;if(c.isDepthTexture)f=6402,d?c.type===ac?f=36012:c.type===cx?f=33190:c.type===bz?f=35056:f=33189:c.type===ac&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),c.format===aE&&f===6402&&c.type!==cp&&c.type!==cx&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),c.type=cp,n=e.convert(c.type)),c.format===bA&&f===6402&&(f=34041,c.type!==bz&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),c.type=bz,n=e.convert(c.type))),b.texImage2D(3553,0,f,g.width,g.height,0,q,n,null);else if(c.isDataTexture)if(o.length>0&&s){for(let a=0,c=o.length;a<c;a++)h=o[a],b.texImage2D(3553,a,f,h.width,h.height,0,q,n,h.data);c.generateMipmaps=!1,p.__maxMipLevel=o.length-1}else b.texImage2D(3553,0,f,g.width,g.height,0,q,n,g.data),p.__maxMipLevel=0;else if(c.isCompressedTexture){for(let a=0,d=o.length;a<d;a++)h=o[a],c.format!==N&&c.format!==av?q!==null?b.compressedTexImage2D(3553,a,f,h.width,h.height,0,h.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):b.texImage2D(3553,a,f,h.width,h.height,0,q,n,h.data);p.__maxMipLevel=o.length-1}else if(c.isDataTexture2DArray)b.texImage3D(35866,0,f,g.width,g.height,g.depth,0,q,n,g.data),p.__maxMipLevel=0;else if(c.isDataTexture3D)b.texImage3D(32879,0,f,g.width,g.height,g.depth,0,q,n,g.data),p.__maxMipLevel=0;else if(o.length>0&&s){for(let a=0,c=o.length;a<c;a++)h=o[a],b.texImage2D(3553,a,f,q,n,h);c.generateMipmaps=!1,p.__maxMipLevel=o.length-1}else b.texImage2D(3553,0,f,q,n,g),p.__maxMipLevel=0;l(c,s)&&k(r,c,g.width,g.height),p.__version=c.version,c.onUpdate&&c.onUpdate(c)}function R(p,c,u){if(c.image.length!==6)return;E(p,c),b.activeTexture(33984+u),b.bindTexture(34067,p.__webglTexture),a.pixelStorei(37440,c.flipY),a.pixelStorei(37441,c.premultiplyAlpha),a.pixelStorei(3317,c.unpackAlignment),a.pixelStorei(37443,0);const t=c&&(c.isCompressedTexture||c.image[0].isCompressedTexture),r=c.image[0]&&c.image[0].isDataTexture,g=[];for(let a=0;a<6;a++)!t&&!r?g[a]=z(c.image[a],!1,!0,aa):g[a]=r?c.image[a].image:c.image[a];const q=g[0],s=j(q)||d,h=e.convert(c.format),n=e.convert(c.type),o=i(c.internalFormat,h,n);m(34067,c,s);let f;if(t){for(let a=0;a<6;a++){f=g[a].mipmaps;for(let e=0;e<f.length;e++){const d=f[e];c.format!==N&&c.format!==av?h!==null?b.compressedTexImage2D(34069+a,e,o,d.width,d.height,0,d.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):b.texImage2D(34069+a,e,o,d.width,d.height,0,h,n,d.data)}}p.__maxMipLevel=f.length-1}else{f=c.mipmaps;for(let a=0;a<6;a++)if(r){b.texImage2D(34069+a,0,o,g[a].width,g[a].height,0,h,n,g[a].data);for(let c=0;c<f.length;c++){const e=f[c],d=e.image[a].image;b.texImage2D(34069+a,c+1,o,d.width,d.height,0,h,n,d.data)}}else{b.texImage2D(34069+a,0,o,h,n,g[a]);for(let c=0;c<f.length;c++){const d=f[c];b.texImage2D(34069+a,c+1,o,h,n,d.image[a])}}p.__maxMipLevel=f.length}l(c,s)&&k(34067,c,q.width,q.height),p.__version=c.version,c.onUpdate&&c.onUpdate(c)}function v(m,d,l,f){const g=d.texture,j=e.convert(g.format),h=e.convert(g.type),k=i(g.internalFormat,j,h);f===32879||f===35866?b.texImage3D(f,0,k,d.width,d.height,d.depth,0,j,h,null):b.texImage2D(f,0,k,d.width,d.height,0,j,h,null),b.bindFramebuffer(36160,m),a.framebufferTexture2D(36160,l,f,c.get(g).__webglTexture,0),b.bindFramebuffer(36160,null)}function q(c,b,d){if(a.bindRenderbuffer(36161,c),b.depthBuffer&&!b.stencilBuffer){let e=33189;if(d){const c=b.depthTexture;c&&c.isDepthTexture&&(c.type===ac?e=36012:c.type===cx&&(e=33190));const d=n(b);a.renderbufferStorageMultisample(36161,d,e,b.width,b.height)}else a.renderbufferStorage(36161,e,b.width,b.height);a.framebufferRenderbuffer(36160,36096,36161,c)}else if(b.depthBuffer&&b.stencilBuffer){if(d){const c=n(b);a.renderbufferStorageMultisample(36161,c,35056,b.width,b.height)}else a.renderbufferStorage(36161,34041,b.width,b.height);a.framebufferRenderbuffer(36160,33306,36161,c)}else{const c=b.texture,g=e.convert(c.format),h=e.convert(c.type),f=i(c.internalFormat,g,h);if(d){const c=n(b);a.renderbufferStorageMultisample(36161,c,f,b.width,b.height)}else a.renderbufferStorage(36161,f,b.width,b.height)}a.bindRenderbuffer(36161,null)}function U(f,d){const g=d&&d.isWebGLCubeRenderTarget;if(g)throw new Error("Depth Texture with cube render targets is not supported");if(b.bindFramebuffer(36160,f),!(d.depthTexture&&d.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!c.get(d.depthTexture).__webglTexture||d.depthTexture.image.width!==d.width||d.depthTexture.image.height!==d.height)&&(d.depthTexture.image.width=d.width,d.depthTexture.image.height=d.height,d.depthTexture.needsUpdate=!0),r(d.depthTexture,0);const e=c.get(d.depthTexture).__webglTexture;if(d.depthTexture.format===aE)a.framebufferTexture2D(36160,36096,3553,e,0);else if(d.depthTexture.format===bA)a.framebufferTexture2D(36160,33306,3553,e,0);else throw new Error("Unknown depthTexture format")}function V(e){const d=c.get(e),f=e.isWebGLCubeRenderTarget===!0;if(e.depthTexture){if(f)throw new Error("target.depthTexture not supported in Cube render targets");U(d.__webglFramebuffer,e)}else if(f){d.__webglDepthbuffer=[];for(let c=0;c<6;c++)b.bindFramebuffer(36160,d.__webglFramebuffer[c]),d.__webglDepthbuffer[c]=a.createRenderbuffer(),q(d.__webglDepthbuffer[c],e,!1)}else b.bindFramebuffer(36160,d.__webglFramebuffer),d.__webglDepthbuffer=a.createRenderbuffer(),q(d.__webglDepthbuffer,e,!1);b.bindFramebuffer(36160,null)}function W(f){const h=f.texture,o=c.get(f),p=c.get(h);f.addEventListener("dispose",y),p.__webglTexture=a.createTexture(),p.__version=h.version,g.memory.textures++;const s=f.isWebGLCubeRenderTarget===!0,t=f.isWebGLMultisampleRenderTarget===!0,u=h.isDataTexture3D||h.isDataTexture2DArray,r=j(f)||d;if(d&&h.format===av&&(h.type===ac||h.type===cw)&&(h.format=N,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),s){o.__webglFramebuffer=[];for(let b=0;b<6;b++)o.__webglFramebuffer[b]=a.createFramebuffer()}else if(o.__webglFramebuffer=a.createFramebuffer(),t)if(d){o.__webglMultisampledFramebuffer=a.createFramebuffer(),o.__webglColorRenderbuffer=a.createRenderbuffer(),a.bindRenderbuffer(36161,o.__webglColorRenderbuffer);const c=e.convert(h.format),d=e.convert(h.type),g=i(h.internalFormat,c,d),j=n(f);a.renderbufferStorageMultisample(36161,j,g,f.width,f.height),b.bindFramebuffer(36160,o.__webglMultisampledFramebuffer),a.framebufferRenderbuffer(36160,36064,36161,o.__webglColorRenderbuffer),a.bindRenderbuffer(36161,null),f.depthBuffer&&(o.__webglDepthRenderbuffer=a.createRenderbuffer(),q(o.__webglDepthRenderbuffer,f,!0)),b.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(s){b.bindTexture(34067,p.__webglTexture),m(34067,h,r);for(let a=0;a<6;a++)v(o.__webglFramebuffer[a],f,36064,34069+a);l(h,r)&&k(34067,h,f.width,f.height),b.bindTexture(34067,null)}else{let a=3553;if(u)if(d){const b=h.isDataTexture3D;a=b?32879:35866}else console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");b.bindTexture(a,p.__webglTexture),m(a,h,r),v(o.__webglFramebuffer,f,36064,a),l(h,r)&&k(3553,h,f.width,f.height),b.bindTexture(3553,null)}f.depthBuffer&&V(f)}function X(a){const e=a.texture,f=j(a)||d;if(l(e,f)){const d=a.isWebGLCubeRenderTarget?34067:3553,f=c.get(e).__webglTexture;b.bindTexture(d,f),k(d,e,a.width,a.height),b.bindTexture(d,null)}}function ad(e){if(e.isWebGLMultisampleRenderTarget)if(d){const g=e.width,h=e.height;let d=16384;e.depthBuffer&&(d|=256),e.stencilBuffer&&(d|=1024);const f=c.get(e);b.bindFramebuffer(36008,f.__webglMultisampledFramebuffer),b.bindFramebuffer(36009,f.__webglFramebuffer),a.blitFramebuffer(0,0,g,h,0,0,g,h,d,9728),b.bindFramebuffer(36008,null),b.bindFramebuffer(36009,f.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function n(a){return d&&a.isWebGLMultisampleRenderTarget?Math.min(Z,a.samples):0}function _(a){const b=g.render.frame;s.get(a)!==b&&(s.set(a,b),a.update())}let D=!1,F=!1;function ab(a,b){a&&a.isWebGLRenderTarget&&(D===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),D=!0),a=a.texture),r(a,b)}function S(a,b){a&&a.isWebGLCubeRenderTarget&&(F===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),F=!0),a=a.texture),J(a,b)}this.allocateTextureUnit=P,this.resetTextureUnits=Q,this.setTexture2D=r,this.setTexture2DArray=M,this.setTexture3D=L,this.setTextureCube=J,this.setupRenderTarget=W,this.updateRenderTargetMipmap=X,this.updateMultisampleRenderTarget=ad,this.safeSetTexture2D=ab,this.safeSetTextureCube=S}function jO(e,a,c){const b=c.isWebGL2;function d(c){let d;if(c===dI)return 5121;if(c===mZ)return 32819;if(c===mW)return 32820;if(c===mV)return 33635;if(c===nb)return 5120;if(c===m$)return 5122;if(c===cp)return 5123;if(c===m_)return 5124;if(c===cx)return 5125;if(c===ac)return 5126;if(c===cw)return b?5131:(d=a.get("OES_texture_half_float"),d!==null)?d.HALF_FLOAT_OES:null;if(c===mU)return 6406;if(c===av)return 6407;if(c===N)return 6408;if(c===mS)return 6409;if(c===mR)return 6410;if(c===aE)return 6402;if(c===bA)return 34041;if(c===mQ)return 6403;if(c===mP)return 36244;if(c===mK)return 33319;if(c===mI)return 33320;if(c===mG)return 36248;if(c===mF)return 36249;if(c===eO||c===eN||c===eM||c===eK)if(d=a.get("WEBGL_compressed_texture_s3tc"),d!==null){{if(c===eO)return d.COMPRESSED_RGB_S3TC_DXT1_EXT;if(c===eN)return d.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(c===eM)return d.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(c===eK)return d.COMPRESSED_RGBA_S3TC_DXT5_EXT}}else return null;if(c===eJ||c===eI||c===eH||c===eG)if(d=a.get("WEBGL_compressed_texture_pvrtc"),d!==null){{if(c===eJ)return d.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(c===eI)return d.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(c===eH)return d.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(c===eG)return d.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}}else return null;if(c===mE)return d=a.get("WEBGL_compressed_texture_etc1"),d!==null?d.COMPRESSED_RGB_ETC1_WEBGL:null;if(c===eF||c===eE)if(d=a.get("WEBGL_compressed_texture_etc"),d!==null){if(c===eF)return d.COMPRESSED_RGB8_ETC2;if(c===eE)return d.COMPRESSED_RGBA8_ETC2_EAC}if(c===mD||c===mC||c===kT||c===mB||c===mA||c===mz||c===my||c===mx||c===mu||c===ms||c===mr||c===mo||c===ml||c===mk||c===mi||c===mg||c===mf||c===me||c===md||c===mb||c===l$||c===l_||c===lS||c===lL||c===lK||c===lJ||c===lI||c===lG)return d=a.get("WEBGL_compressed_texture_astc"),d!==null?c:null;if(c===mj)return d=a.get("EXT_texture_compression_bptc"),d!==null?c:null;if(c===bz)return b?34042:(d=a.get("WEBGL_depth_texture"),d!==null)?d.UNSIGNED_INT_24_8_WEBGL:null}return{convert:d}}fC=class extends D{constructor(a=[]){super(),this.cameras=a}},fC.prototype.isArrayCamera=!0,bx=class extends h{constructor(){super(),this.type="Group"}},bx.prototype.isGroup=!0,jR={type:"move"},cS=class{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new bx,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new bx,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new a,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new a),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new bx,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new a,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new a),this._grip}dispatchEvent(a){return this._targetRay!==null&&this._targetRay.dispatchEvent(a),this._grip!==null&&this._grip.dispatchEvent(a),this._hand!==null&&this._hand.dispatchEvent(a),this}disconnect(a){return this.dispatchEvent({type:"disconnected",data:a}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(f,g,h){let d=null,e=null,i=null;const a=this._targetRay,b=this._grip,c=this._hand;if(f&&g.session.visibilityState!=="visible-blurred")if(a!==null&&(d=g.getPose(f.targetRaySpace,h),d!==null&&(a.matrix.fromArray(d.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),d.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(d.linearVelocity)):a.hasLinearVelocity=!1,d.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(d.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(jR))),c&&f.hand){i=!0;for(const b of f.hand.values()){const d=g.getJointPose(b,h);if(c.joints[b.jointName]===void 0){const a=new bx;a.matrixAutoUpdate=!1,a.visible=!1,c.joints[b.jointName]=a,c.add(a)}const a=c.joints[b.jointName];d!==null&&(a.matrix.fromArray(d.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),a.jointRadius=d.radius),a.visible=d!==null}const e=c.joints["index-finger-tip"],j=c.joints["thumb-tip"],a=e.position.distanceTo(j.position),b=.02,d=.005;c.inputState.pinching&&a>b+d?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:f.handedness,target:this})):!c.inputState.pinching&&a<=b-d&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:f.handedness,target:this}))}else b!==null&&f.gripSpace&&(e=g.getPose(f.gripSpace,h),e!==null&&(b.matrix.fromArray(e.transform.matrix),b.matrix.decompose(b.position,b.rotation,b.scale),e.linearVelocity?(b.hasLinearVelocity=!0,b.linearVelocity.copy(e.linearVelocity)):b.hasLinearVelocity=!1,e.angularVelocity?(b.hasAngularVelocity=!0,b.angularVelocity.copy(e.angularVelocity)):b.hasAngularVelocity=!1));return a!==null&&(a.visible=d!==null),b!==null&&(b.visible=e!==null),c!==null&&(c.visible=i!==null),this}},jT=class extends aq{constructor(r,p){super();const h=this,u=r.state;let c=null,t=1,k=null,s="local-floor",n=null;const d=[],e=new Map,f=new D;f.layers.enable(1),f.viewport=new i;const j=new D;j.layers.enable(2),j.viewport=new i;const C=[f,j],b=new fC;b.layers.enable(1),b.layers.enable(2);let q=null,m=null;this.enabled=!1,this.isPresenting=!1,this.getController=function(b){let a=d[b];return a===void 0&&(a=new cS,d[b]=a),a.getTargetRaySpace()},this.getControllerGrip=function(b){let a=d[b];return a===void 0&&(a=new cS,d[b]=a),a.getGripSpace()},this.getHand=function(b){let a=d[b];return a===void 0&&(a=new cS,d[b]=a),a.getHandSpace()};function g(a){const b=e.get(a.inputSource);b&&b.dispatchEvent({type:a.type,data:a.inputSource})}function A(){e.forEach(function(a,b){a.disconnect(b)}),e.clear(),q=null,m=null,u.bindXRFramebuffer(null),r.setRenderTarget(r.getRenderTarget()),l.stop(),h.isPresenting=!1,h.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(a){t=a,h.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(a){s=a,h.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return k},this.getSession=function(){return c},this.setSession=async function(a){if(c=a,c!==null){c.addEventListener("select",g),c.addEventListener("selectstart",g),c.addEventListener("selectend",g),c.addEventListener("squeeze",g),c.addEventListener("squeezestart",g),c.addEventListener("squeezeend",g),c.addEventListener("end",A),c.addEventListener("inputsourceschange",y);const a=p.getContextAttributes();a.xrCompatible!==!0&&await p.makeXRCompatible();const b={antialias:a.antialias,alpha:a.alpha,depth:a.depth,stencil:a.stencil,framebufferScaleFactor:t},d=new XRWebGLLayer(c,p,b);c.updateRenderState({baseLayer:d}),k=await c.requestReferenceSpace(s),l.setContext(c),l.start(),h.isPresenting=!0,h.dispatchEvent({type:"sessionstart"})}};function y(a){const b=c.inputSources;for(let a=0;a<d.length;a++)e.set(b[a],d[a]);for(let b=0;b<a.removed.length;b++){const c=a.removed[b],d=e.get(c);d&&(d.dispatchEvent({type:"disconnected",data:c}),e.delete(c))}for(let b=0;b<a.added.length;b++){const c=a.added[b],d=e.get(c);d&&d.dispatchEvent({type:"connected",data:c})}}const v=new a,w=new a;function z(a,g,m){v.setFromMatrixPosition(g.matrixWorld),w.setFromMatrixPosition(m.matrixWorld);const l=v.distanceTo(w),b=g.projectionMatrix.elements,k=m.projectionMatrix.elements,d=b[14]/(b[10]-1),h=b[14]/(b[10]+1),r=(b[9]+1)/b[5],q=(b[9]-1)/b[5],e=(b[8]-1)/b[0],n=(k[8]+1)/k[0],p=d*e,o=d*n,c=l/(-e+n),j=c*-e;g.matrixWorld.decompose(a.position,a.quaternion,a.scale),a.translateX(j),a.translateZ(c),a.matrixWorld.compose(a.position,a.quaternion,a.scale),a.matrixWorldInverse.copy(a.matrixWorld).invert();const f=d+c,i=h+c,s=p-j,t=o+(l-j),u=r*h/i*f,x=q*h/i*f;a.projectionMatrix.makePerspective(s,t,u,x,f,i)}function x(a,b){b===null?a.matrixWorld.copy(a.matrix):a.matrixWorld.multiplyMatrices(b.matrixWorld,a.matrix),a.matrixWorldInverse.copy(a.matrixWorld).invert()}this.getCamera=function(a){b.near=j.near=f.near=a.near,b.far=j.far=f.far=a.far,(q!==b.near||m!==b.far)&&(c.updateRenderState({depthNear:b.near,depthFar:b.far}),q=b.near,m=b.far);const e=a.parent,d=b.cameras;x(b,e);for(let a=0;a<d.length;a++)x(d[a],e);a.matrixWorld.copy(b.matrixWorld),a.matrix.copy(b.matrix),a.matrix.decompose(a.position,a.quaternion,a.scale);const g=a.children;for(let a=0,b=g.length;a<b;a++)g[a].updateMatrixWorld(!0);return d.length===2?z(b,f,j):b.projectionMatrix.copy(f.projectionMatrix),b};let o=null;function B(e,a){if(n=a.getViewerPose(k),n!==null){const a=n.views,d=c.renderState.baseLayer;u.bindXRFramebuffer(d.framebuffer);let e=!1;a.length!==b.cameras.length&&(b.cameras.length=0,e=!0);for(let c=0;c<a.length;c++){const h=a[c],g=d.getViewport(h),f=C[c];f.matrix.fromArray(h.transform.matrix),f.projectionMatrix.fromArray(h.projectionMatrix),f.viewport.set(g.x,g.y,g.width,g.height),c===0&&b.matrix.copy(f.matrix),e===!0&&b.cameras.push(f)}}const f=c.inputSources;for(let b=0;b<d.length;b++){const c=d[b],e=f[b];c.update(e,a,k)}o&&o(e,a)}const l=new eY;l.setAnimationLoop(B),this.setAnimationLoop=function(a){o=a},this.dispose=function(){}}};function jU(b){function l(b,a){b.fogColor.value.copy(a.color),a.isFog?(b.fogNear.value=a.near,b.fogFar.value=a.far):a.isFogExp2&&(b.fogDensity.value=a.density)}function i(i,b,l,r){b.isMeshBasicMaterial?a(i,b):b.isMeshLambertMaterial?(a(i,b),d(i,b)):b.isMeshToonMaterial?(a(i,b),k(i,b)):b.isMeshPhongMaterial?(a(i,b),j(i,b)):b.isMeshStandardMaterial?(a(i,b),b.isMeshPhysicalMaterial?m(i,b):c(i,b)):b.isMeshMatcapMaterial?(a(i,b),n(i,b)):b.isMeshDepthMaterial?(a(i,b),o(i,b)):b.isMeshDistanceMaterial?(a(i,b),p(i,b)):b.isMeshNormalMaterial?(a(i,b),q(i,b)):b.isLineBasicMaterial?(e(i,b),b.isLineDashedMaterial&&f(i,b)):b.isPointsMaterial?g(i,b,l,r):b.isSpriteMaterial?h(i,b):b.isShadowMaterial?(i.color.value.copy(b.color),i.opacity.value=b.opacity):b.isShaderMaterial&&(b.uniformsNeedUpdate=!1)}function a(d,a){d.opacity.value=a.opacity,a.color&&d.diffuse.value.copy(a.color),a.emissive&&d.emissive.value.copy(a.emissive).multiplyScalar(a.emissiveIntensity),a.map&&(d.map.value=a.map),a.alphaMap&&(d.alphaMap.value=a.alphaMap),a.specularMap&&(d.specularMap.value=a.specularMap);const f=b.get(a).envMap;if(f){d.envMap.value=f,d.flipEnvMap.value=f.isCubeTexture&&f._needsFlipEnvMap?-1:1,d.reflectivity.value=a.reflectivity,d.refractionRatio.value=a.refractionRatio;const c=b.get(f).__maxMipLevel;c!==void 0&&(d.maxMipLevel.value=c)}a.lightMap&&(d.lightMap.value=a.lightMap,d.lightMapIntensity.value=a.lightMapIntensity),a.aoMap&&(d.aoMap.value=a.aoMap,d.aoMapIntensity.value=a.aoMapIntensity);let c;a.map?c=a.map:a.specularMap?c=a.specularMap:a.displacementMap?c=a.displacementMap:a.normalMap?c=a.normalMap:a.bumpMap?c=a.bumpMap:a.roughnessMap?c=a.roughnessMap:a.metalnessMap?c=a.metalnessMap:a.alphaMap?c=a.alphaMap:a.emissiveMap?c=a.emissiveMap:a.clearcoatMap?c=a.clearcoatMap:a.clearcoatNormalMap?c=a.clearcoatNormalMap:a.clearcoatRoughnessMap&&(c=a.clearcoatRoughnessMap),c!==void 0&&(c.isWebGLRenderTarget&&(c=c.texture),c.matrixAutoUpdate===!0&&c.updateMatrix(),d.uvTransform.value.copy(c.matrix));let e;a.aoMap?e=a.aoMap:a.lightMap&&(e=a.lightMap),e!==void 0&&(e.isWebGLRenderTarget&&(e=e.texture),e.matrixAutoUpdate===!0&&e.updateMatrix(),d.uv2Transform.value.copy(e.matrix))}function e(a,b){a.diffuse.value.copy(b.color),a.opacity.value=b.opacity}function f(b,a){b.dashSize.value=a.dashSize,b.totalSize.value=a.dashSize+a.gapSize,b.scale.value=a.scale}function g(b,a,d,e){b.diffuse.value.copy(a.color),b.opacity.value=a.opacity,b.size.value=a.size*d,b.scale.value=e*.5,a.map&&(b.map.value=a.map),a.alphaMap&&(b.alphaMap.value=a.alphaMap);let c;a.map?c=a.map:a.alphaMap&&(c=a.alphaMap),c!==void 0&&(c.matrixAutoUpdate===!0&&c.updateMatrix(),b.uvTransform.value.copy(c.matrix))}function h(b,a){b.diffuse.value.copy(a.color),b.opacity.value=a.opacity,b.rotation.value=a.rotation,a.map&&(b.map.value=a.map),a.alphaMap&&(b.alphaMap.value=a.alphaMap);let c;a.map?c=a.map:a.alphaMap&&(c=a.alphaMap),c!==void 0&&(c.matrixAutoUpdate===!0&&c.updateMatrix(),b.uvTransform.value.copy(c.matrix))}function d(b,a){a.emissiveMap&&(b.emissiveMap.value=a.emissiveMap)}function j(b,a){b.specular.value.copy(a.specular),b.shininess.value=Math.max(a.shininess,1e-4),a.emissiveMap&&(b.emissiveMap.value=a.emissiveMap),a.bumpMap&&(b.bumpMap.value=a.bumpMap,b.bumpScale.value=a.bumpScale,a.side===t&&(b.bumpScale.value*=-1)),a.normalMap&&(b.normalMap.value=a.normalMap,b.normalScale.value.copy(a.normalScale),a.side===t&&b.normalScale.value.negate()),a.displacementMap&&(b.displacementMap.value=a.displacementMap,b.displacementScale.value=a.displacementScale,b.displacementBias.value=a.displacementBias)}function k(b,a){a.gradientMap&&(b.gradientMap.value=a.gradientMap),a.emissiveMap&&(b.emissiveMap.value=a.emissiveMap),a.bumpMap&&(b.bumpMap.value=a.bumpMap,b.bumpScale.value=a.bumpScale,a.side===t&&(b.bumpScale.value*=-1)),a.normalMap&&(b.normalMap.value=a.normalMap,b.normalScale.value.copy(a.normalScale),a.side===t&&b.normalScale.value.negate()),a.displacementMap&&(b.displacementMap.value=a.displacementMap,b.displacementScale.value=a.displacementScale,b.displacementBias.value=a.displacementBias)}function c(c,a){c.roughness.value=a.roughness,c.metalness.value=a.metalness,a.roughnessMap&&(c.roughnessMap.value=a.roughnessMap),a.metalnessMap&&(c.metalnessMap.value=a.metalnessMap),a.emissiveMap&&(c.emissiveMap.value=a.emissiveMap),a.bumpMap&&(c.bumpMap.value=a.bumpMap,c.bumpScale.value=a.bumpScale,a.side===t&&(c.bumpScale.value*=-1)),a.normalMap&&(c.normalMap.value=a.normalMap,c.normalScale.value.copy(a.normalScale),a.side===t&&c.normalScale.value.negate()),a.displacementMap&&(c.displacementMap.value=a.displacementMap,c.displacementScale.value=a.displacementScale,c.displacementBias.value=a.displacementBias);const d=b.get(a).envMap;d&&(c.envMapIntensity.value=a.envMapIntensity)}function m(b,a){c(b,a),b.reflectivity.value=a.reflectivity,b.clearcoat.value=a.clearcoat,b.clearcoatRoughness.value=a.clearcoatRoughness,a.sheen&&b.sheen.value.copy(a.sheen),a.clearcoatMap&&(b.clearcoatMap.value=a.clearcoatMap),a.clearcoatRoughnessMap&&(b.clearcoatRoughnessMap.value=a.clearcoatRoughnessMap),a.clearcoatNormalMap&&(b.clearcoatNormalScale.value.copy(a.clearcoatNormalScale),b.clearcoatNormalMap.value=a.clearcoatNormalMap,a.side===t&&b.clearcoatNormalScale.value.negate()),b.transmission.value=a.transmission,a.transmissionMap&&(b.transmissionMap.value=a.transmissionMap)}function n(b,a){a.matcap&&(b.matcap.value=a.matcap),a.bumpMap&&(b.bumpMap.value=a.bumpMap,b.bumpScale.value=a.bumpScale,a.side===t&&(b.bumpScale.value*=-1)),a.normalMap&&(b.normalMap.value=a.normalMap,b.normalScale.value.copy(a.normalScale),a.side===t&&b.normalScale.value.negate()),a.displacementMap&&(b.displacementMap.value=a.displacementMap,b.displacementScale.value=a.displacementScale,b.displacementBias.value=a.displacementBias)}function o(b,a){a.displacementMap&&(b.displacementMap.value=a.displacementMap,b.displacementScale.value=a.displacementScale,b.displacementBias.value=a.displacementBias)}function p(b,a){a.displacementMap&&(b.displacementMap.value=a.displacementMap,b.displacementScale.value=a.displacementScale,b.displacementBias.value=a.displacementBias),b.referencePosition.value.copy(a.referencePosition),b.nearDistance.value=a.nearDistance,b.farDistance.value=a.farDistance}function q(b,a){a.bumpMap&&(b.bumpMap.value=a.bumpMap,b.bumpScale.value=a.bumpScale,a.side===t&&(b.bumpScale.value*=-1)),a.normalMap&&(b.normalMap.value=a.normalMap,b.normalScale.value.copy(a.normalScale),a.side===t&&b.normalScale.value.negate()),a.displacementMap&&(b.displacementMap.value=a.displacementMap,b.displacementScale.value=a.displacementScale,b.displacementBias.value=a.displacementBias)}return{refreshFogUniforms:l,refreshMaterialUniforms:i}}function jV(){const a=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return a.style.display="block",a}function j(h){h=h||{};const p=h.canvas!==void 0?h.canvas:jV(),aG=h.context!==void 0?h.context:null,aE=h.alpha!==void 0&&h.alpha,aI=h.depth===void 0||h.depth,aD=h.stencil===void 0||h.stencil,aJ=h.antialias!==void 0&&h.antialias,ak=h.premultipliedAlpha===void 0||h.premultipliedAlpha,aK=h.preserveDrawingBuffer!==void 0&&h.preserveDrawingBuffer,aL=h.powerPreference!==void 0?h.powerPreference:"default",aM=h.failIfMajorPerformanceCaveat!==void 0&&h.failIfMajorPerformanceCaveat;let o=null,k=null;const E=[],J=[];this.domElement=p,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=aF,this.physicallyCorrectLights=!1,this.toneMapping=bd,this.toneMappingExposure=1;const g=this;let _=!1,U=0,ab=0,t=null,T=-1,H=null;const G=new i,Q=new i;let $=null,B=p.width,y=p.height,q=1,ah=null,ay=null;const L=new i(0,0,B,y),K=new i(0,0,B,y);let ad=!1;const Y=new cm;let P=!1,X=!1;const O=new e,A=new a,W={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function af(){return t===null?q:1}let c=aG;function aj(a,b){for(let c=0;c<a.length;c++){const e=a[c],d=p.getContext(e,b);if(d!==null)return d}return null}try{const a={alpha:aE,depth:aI,stencil:aD,antialias:aJ,premultipliedAlpha:ak,preserveDrawingBuffer:aK,powerPreference:aL,failIfMajorPerformanceCaveat:aM};if(p.addEventListener("webglcontextlost",av,!1),p.addEventListener("webglcontextrestored",aq,!1),c===null){const b=["webgl2","webgl","experimental-webgl"];if(g.isWebGL1Renderer===!0&&b.shift(),c=aj(b,a),c===null)throw aj(b)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}c.getShaderPrecisionFormat===void 0&&(c.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(a){throw console.error("THREE.WebGLRenderer: "+a.message),a}let l,m,f,s,j,r,I,M,Z,F,D,aa,R,S,x,u,z,an,ao,ap,w,n;function az(){l=new hE(c),m=new hB(c,l,h),l.init(m),w=new jO(c,l,m),f=new jM(c,l,m),s=new hH(c),j=new jv,r=new jN(c,l,f,j,m,w,s),I=new hD(g),M=new kz(c,m),n=new hz(c,l,M,m),Z=new hF(c,M,s,n),F=new hL(c,Z,M,s),an=new hK(c),x=new hC(j),D=new ju(g,I,l,m,n,x),aa=new jU(j),R=new jz(j),S=new jG(l,m),z=new hy(g,I,f,F,ak),u=new fD(g,F,m),ao=new hA(c,l,s,m),ap=new hG(c,l,s,m),s.programs=D.programs,g.capabilities=m,g.extensions=l,g.properties=j,g.renderLists=R,g.shadowMap=u,g.state=f,g.info=s}az();const v=new jT(g,c);this.xr=v,this.getContext=function(){return c},this.getContextAttributes=function(){return c.getContextAttributes()},this.forceContextLoss=function(){const a=l.get("WEBGL_lose_context");a&&a.loseContext()},this.forceContextRestore=function(){const a=l.get("WEBGL_lose_context");a&&a.restoreContext()},this.getPixelRatio=function(){return q},this.setPixelRatio=function(a){if(a===void 0)return;q=a,this.setSize(B,y,!1)},this.getSize=function(a){return a===void 0&&(console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),a=new b),a.set(B,y)},this.setSize=function(a,b,c){if(v.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}B=a,y=b,p.width=Math.floor(a*q),p.height=Math.floor(b*q),c!==!1&&(p.style.width=a+"px",p.style.height=b+"px"),this.setViewport(0,0,a,b)},this.getDrawingBufferSize=function(a){return a===void 0&&(console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),a=new b),a.set(B*q,y*q).floor()},this.setDrawingBufferSize=function(a,b,c){B=a,y=b,q=c,p.width=Math.floor(a*c),p.height=Math.floor(b*c),this.setViewport(0,0,a,b)},this.getCurrentViewport=function(a){return a===void 0&&(console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),a=new i),a.copy(G)},this.getViewport=function(a){return a.copy(L)},this.setViewport=function(a,b,c,d){a.isVector4?L.set(a.x,a.y,a.z,a.w):L.set(a,b,c,d),f.viewport(G.copy(L).multiplyScalar(q).floor())},this.getScissor=function(a){return a.copy(K)},this.setScissor=function(a,b,c,d){a.isVector4?K.set(a.x,a.y,a.z,a.w):K.set(a,b,c,d),f.scissor(Q.copy(K).multiplyScalar(q).floor())},this.getScissorTest=function(){return ad},this.setScissorTest=function(a){f.setScissorTest(ad=a)},this.setOpaqueSort=function(a){ah=a},this.setTransparentSort=function(a){ay=a},this.getClearColor=function(a){return a===void 0&&(console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),a=new d),a.copy(z.getClearColor())},this.setClearColor=function(){z.setClearColor.apply(z,arguments)},this.getClearAlpha=function(){return z.getClearAlpha()},this.setClearAlpha=function(){z.setClearAlpha.apply(z,arguments)},this.clear=function(b,d,e){let a=0;(b===void 0||b)&&(a|=16384),(d===void 0||d)&&(a|=256),(e===void 0||e)&&(a|=1024),c.clear(a)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){p.removeEventListener("webglcontextlost",av,!1),p.removeEventListener("webglcontextrestored",aq,!1),R.dispose(),S.dispose(),j.dispose(),I.dispose(),F.dispose(),n.dispose(),v.dispose(),v.removeEventListener("sessionstart",aw),v.removeEventListener("sessionend",au),C.stop()};function av(a){a.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),_=!0}function aq(){console.log("THREE.WebGLRenderer: Context Restored."),_=!1;const a=s.autoReset,b=u.enabled,c=u.autoUpdate,d=u.needsUpdate,e=u.type;az(),s.autoReset=a,u.enabled=b,u.autoUpdate=c,u.needsUpdate=d,u.type=e}function ax(b){const a=b.target;a.removeEventListener("dispose",ax),aB(a)}function aB(a){aO(a),j.remove(a)}function aO(b){const a=j.get(b).programs;a!==void 0&&a.forEach(function(a){D.releaseProgram(a)})}function aH(a,b){a.render(function(a){g.renderBufferImmediate(a,b)})}this.renderBufferImmediate=function(a,e){n.initAttributes();const b=j.get(a);a.hasPositions&&!b.position&&(b.position=c.createBuffer()),a.hasNormals&&!b.normal&&(b.normal=c.createBuffer()),a.hasUvs&&!b.uv&&(b.uv=c.createBuffer()),a.hasColors&&!b.color&&(b.color=c.createBuffer());const d=e.getAttributes();a.hasPositions&&(c.bindBuffer(34962,b.position),c.bufferData(34962,a.positionArray,35048),n.enableAttribute(d.position),c.vertexAttribPointer(d.position,3,5126,!1,0,0)),a.hasNormals&&(c.bindBuffer(34962,b.normal),c.bufferData(34962,a.normalArray,35048),n.enableAttribute(d.normal),c.vertexAttribPointer(d.normal,3,5126,!1,0,0)),a.hasUvs&&(c.bindBuffer(34962,b.uv),c.bufferData(34962,a.uvArray,35048),n.enableAttribute(d.uv),c.vertexAttribPointer(d.uv,2,5126,!1,0,0)),a.hasColors&&(c.bindBuffer(34962,b.color),c.bufferData(34962,a.colorArray,35048),n.enableAttribute(d.color),c.vertexAttribPointer(d.color,3,5126,!1,0,0)),n.disableUnusedAttributes(),c.drawArrays(4,0,a.count),a.count=0},this.renderBufferDirect=function(w,l,c,d,a,h){l===null&&(l=W);const u=a.isMesh&&a.matrixWorld.determinant()<0,m=ag(w,l,d,a);f.setMaterial(d,u);let e=c.index;const k=c.attributes.position;if(e===null){if(k===void 0||k.count===0)return}else if(e.count===0)return;let g=1;d.wireframe===!0&&(e=Z.getWireframeAttribute(c),g=2),(d.morphTargets||d.morphNormals)&&an.update(a,c,d,m),n.setup(a,d,m,c,e);let o,b=ao;e!==null&&(o=M.get(e),b=ap,b.setIndex(o));const r=e!==null?e.count:k.count,p=c.drawRange.start*g,s=c.drawRange.count*g,q=h!==null?h.start*g:0,t=h!==null?h.count*g:1/0,i=Math.max(p,q),v=Math.min(r,p+s,q+t)-1,j=Math.max(0,v-i+1);if(j===0)return;if(a.isMesh)d.wireframe===!0?(f.setLineWidth(d.wireframeLinewidth*af()),b.setMode(1)):b.setMode(4);else if(a.isLine){let c=d.linewidth;c===void 0&&(c=1),f.setLineWidth(c*af()),a.isLineSegments?b.setMode(1):a.isLineLoop?b.setMode(2):b.setMode(3)}else a.isPoints?b.setMode(0):a.isSprite&&b.setMode(4);if(a.isInstancedMesh)b.renderInstances(i,j,a.count);else if(c.isInstancedBufferGeometry){const a=Math.min(c.instanceCount,c._maxInstanceCount);b.renderInstances(i,j,a)}else b.render(i,j)},this.compile=function(a,b){k=S.get(a),k.init(),a.traverseVisible(function(a){a.isLight&&a.layers.test(b.layers)&&(k.pushLight(a),a.castShadow&&k.pushShadow(a))}),k.setupLights(),a.traverse(function(c){const b=c.material;if(b)if(Array.isArray(b))for(let d=0;d<b.length;d++){const e=b[d];V(e,a,c)}else V(b,a,c)})};let ae=null;function aC(a){ae&&ae(a)}function aw(){C.stop()}function au(){C.start()}const C=new eY;C.setAnimationLoop(aC),typeof window!="undefined"&&C.setContext(window),this.setAnimationLoop=function(a){ae=a,v.setAnimationLoop(a),a===null?C.stop():C.start()},v.addEventListener("sessionstart",aw),v.addEventListener("sessionend",au),this.render=function(b,a){let c,d;if(arguments[2]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),c=arguments[2]),arguments[3]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),d=arguments[3]),a!==void 0&&a.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(_===!0)return;b.autoUpdate===!0&&b.updateMatrixWorld(),a.parent===null&&a.updateMatrixWorld(),v.enabled===!0&&v.isPresenting===!0&&(a=v.getCamera(a)),b.isScene===!0&&b.onBeforeRender(g,b,a,c||t),k=S.get(b,J.length),k.init(),J.push(k),O.multiplyMatrices(a.projectionMatrix,a.matrixWorldInverse),Y.setFromProjectionMatrix(O),X=this.localClippingEnabled,P=x.init(this.clippingPlanes,X,a),o=R.get(b,E.length),o.init(),E.push(o),at(b,a,0,g.sortObjects),o.finish(),g.sortObjects===!0&&o.sort(ah,ay),P===!0&&x.beginShadows();const i=k.state.shadowsArray;u.render(i,b,a),k.setupLights(),k.setupLightsView(a),P===!0&&x.endShadows(),this.info.autoReset===!0&&this.info.reset(),c!==void 0&&this.setRenderTarget(c),z.render(o,b,a,d);const e=o.opaque,h=o.transparent;e.length>0&&ar(e,b,a),h.length>0&&ar(h,b,a),t!==null&&(r.updateRenderTargetMipmap(t),r.updateMultisampleRenderTarget(t)),b.isScene===!0&&b.onAfterRender(g,b,a),f.buffers.depth.setTest(!0),f.buffers.depth.setMask(!0),f.buffers.color.setMask(!0),f.setPolygonOffset(!1),n.resetDefaultState(),T=-1,H=null,J.pop(),J.length>0?k=J[J.length-1]:k=null,E.pop(),E.length>0?o=E[E.length-1]:o=null};function at(a,d,b,c){if(a.visible===!1)return;const f=a.layers.test(d.layers);if(f)if(a.isGroup)b=a.renderOrder;else if(a.isLOD)a.autoUpdate===!0&&a.update(d);else if(a.isLight)k.pushLight(a),a.castShadow&&k.pushShadow(a);else if(a.isSprite){if(!a.frustumCulled||Y.intersectsSprite(a)){c&&A.setFromMatrixPosition(a.matrixWorld).applyMatrix4(O);const e=F.update(a),d=a.material;d.visible&&o.push(a,e,d,b,A.z,null)}}else if(a.isImmediateRenderObject)c&&A.setFromMatrixPosition(a.matrixWorld).applyMatrix4(O),o.push(a,null,a.material,b,A.z,null);else if(a.isMesh||a.isLine||a.isPoints)if(a.isSkinnedMesh&&a.skeleton.frame!==s.render.frame&&(a.skeleton.update(),a.skeleton.frame=s.render.frame),!a.frustumCulled||Y.intersectsObject(a)){c&&A.setFromMatrixPosition(a.matrixWorld).applyMatrix4(O);const e=F.update(a),d=a.material;if(Array.isArray(d)){{const c=e.groups;for(let f=0,i=c.length;f<i;f++){const h=c[f],g=d[h.materialIndex];g&&g.visible&&o.push(a,e,g,b,A.z,h)}}}else d.visible&&o.push(a,e,d,b,A.z,null)}const e=a.children;for(let a=0,f=e.length;a<f;a++)at(e[a],d,b,c)}function ar(c,a,b){const d=a.isScene===!0?a.overrideMaterial:null;for(let g=0,m=c.length;g<m;g++){const e=c[g],h=e.object,i=e.geometry,j=d===null?e.material:d,l=e.group;if(b.isArrayCamera){{const c=b.cameras;for(let d=0,e=c.length;d<e;d++){const b=c[d];h.layers.test(b.layers)&&(f.viewport(G.copy(b.viewport)),k.setupLightsView(b),al(h,a,b,i,j,l))}}}else al(h,a,b,i,j,l)}}function al(a,d,b,e,c,h){if(a.onBeforeRender(g,d,b,e,c,h),a.modelViewMatrix.multiplyMatrices(b.matrixWorldInverse,a.matrixWorld),a.normalMatrix.getNormalMatrix(a.modelViewMatrix),a.isImmediateRenderObject){const e=ag(b,d,c,a);f.setMaterial(c),n.reset(),aH(a,e)}else g.renderBufferDirect(b,d,e,c,a,h);a.onAfterRender(g,d,b,e,c,h)}function V(d,i,o){i.isScene!==!0&&(i=W);const c=j.get(d),b=k.state.lights,n=k.state.shadowsArray,m=b.state.version,f=D.getParameters(d,b.state,n,i,o),l=D.getProgramCacheKey(f);let h=c.programs;c.environment=d.isMeshStandardMaterial?i.environment:null,c.fog=i.fog,c.envMap=I.get(d.envMap||c.environment),h===void 0&&(d.addEventListener("dispose",ax),h=new Map,c.programs=h);let e=h.get(l);if(e!==void 0){if(c.currentProgram===e&&c.lightsStateVersion===m)return ai(d,f),e}else f.uniforms=D.getUniforms(d),d.onBuild(f,g),d.onBeforeCompile(f,g),e=D.acquireProgram(f,l),h.set(l,e),c.uniforms=f.uniforms;const a=c.uniforms;(!d.isShaderMaterial&&!d.isRawShaderMaterial||d.clipping===!0)&&(a.clippingPlanes=x.uniform),ai(d,f),c.needsLights=aA(d),c.lightsStateVersion=m,c.needsLights&&(a.ambientLightColor.value=b.state.ambient,a.lightProbe.value=b.state.probe,a.directionalLights.value=b.state.directional,a.directionalLightShadows.value=b.state.directionalShadow,a.spotLights.value=b.state.spot,a.spotLightShadows.value=b.state.spotShadow,a.rectAreaLights.value=b.state.rectArea,a.ltc_1.value=b.state.rectAreaLTC1,a.ltc_2.value=b.state.rectAreaLTC2,a.pointLights.value=b.state.point,a.pointLightShadows.value=b.state.pointShadow,a.hemisphereLights.value=b.state.hemi,a.directionalShadowMap.value=b.state.directionalShadowMap,a.directionalShadowMatrix.value=b.state.directionalShadowMatrix,a.spotShadowMap.value=b.state.spotShadowMap,a.spotShadowMatrix.value=b.state.spotShadowMatrix,a.pointShadowMap.value=b.state.pointShadowMap,a.pointShadowMatrix.value=b.state.pointShadowMatrix);const p=e.getUniforms(),q=am.seqWithValue(p.seq,a);return c.currentProgram=e,c.uniformsList=q,e}function ai(c,a){const b=j.get(c);b.outputEncoding=a.outputEncoding,b.instancing=a.instancing,b.numClippingPlanes=a.numClippingPlanes,b.numIntersection=a.numClipIntersection,b.vertexAlphas=a.vertexAlphas}function ag(h,l,a,e){l.isScene!==!0&&(l=W),r.resetTextureUnits();const s=l.fog,D=a.isMeshStandardMaterial?l.environment:null,C=t===null?g.outputEncoding:t.texture.encoding,B=I.get(a.envMap||D),z=a.vertexColors===!0&&e.geometry&&e.geometry.attributes.color&&e.geometry.attributes.color.itemSize===4,b=j.get(a),w=k.state.lights;if(P===!0)if(X===!0||h!==H){const b=h===H&&a.id===T;x.setState(a,h,b)}let i=!1;a.version===b.__version?b.needsLights&&b.lightsStateVersion!==w.state.version?i=!0:b.outputEncoding!==C?i=!0:e.isInstancedMesh&&b.instancing===!1?i=!0:!e.isInstancedMesh&&b.instancing===!0?i=!0:b.envMap!==B?i=!0:a.fog&&b.fog!==s?i=!0:b.numClippingPlanes!==void 0&&(b.numClippingPlanes!==x.numPlanes||b.numIntersection!==x.numIntersection)?i=!0:b.vertexAlphas!==z&&(i=!0):(i=!0,b.__version=a.version);let p=b.currentProgram;i===!0&&(p=V(a,l,e));let v=!1,n=!1,u=!1;const d=p.getUniforms(),o=b.uniforms;if(f.useProgram(p.program)&&(v=!0,n=!0,u=!0),a.id!==T&&(T=a.id,n=!0),v||H!==h){if(d.setValue(c,"projectionMatrix",h.projectionMatrix),m.logarithmicDepthBuffer&&d.setValue(c,"logDepthBufFC",2/(Math.log(h.far+1)/Math.LN2)),H!==h&&(H=h,n=!0,u=!0),a.isShaderMaterial||a.isMeshPhongMaterial||a.isMeshToonMaterial||a.isMeshStandardMaterial||a.envMap){const a=d.map.cameraPosition;a!==void 0&&a.setValue(c,A.setFromMatrixPosition(h.matrixWorld))}(a.isMeshPhongMaterial||a.isMeshToonMaterial||a.isMeshLambertMaterial||a.isMeshBasicMaterial||a.isMeshStandardMaterial||a.isShaderMaterial)&&d.setValue(c,"isOrthographic",h.isOrthographicCamera===!0),(a.isMeshPhongMaterial||a.isMeshToonMaterial||a.isMeshLambertMaterial||a.isMeshBasicMaterial||a.isMeshStandardMaterial||a.isShaderMaterial||a.isShadowMaterial||a.skinning)&&d.setValue(c,"viewMatrix",h.matrixWorldInverse)}if(a.skinning){d.setOptional(c,e,"bindMatrix"),d.setOptional(c,e,"bindMatrixInverse");const a=e.skeleton;if(a){const b=a.bones;if(m.floatVertexTextures){if(a.boneTexture===null){let c=Math.sqrt(b.length*4);c=lr(c),c=Math.max(c,4);const d=new Float32Array(c*c*4);d.set(a.boneMatrices);const e=new eU(d,c,c,N,ac);a.boneMatrices=d,a.boneTexture=e,a.boneTextureSize=c}d.setValue(c,"boneTexture",a.boneTexture,r),d.setValue(c,"boneTextureSize",a.boneTextureSize)}else d.setOptional(c,a,"boneMatrices")}}return(n||b.receiveShadow!==e.receiveShadow)&&(b.receiveShadow=e.receiveShadow,d.setValue(c,"receiveShadow",e.receiveShadow)),n&&(d.setValue(c,"toneMappingExposure",g.toneMappingExposure),b.needsLights&&aN(o,u),s&&a.fog&&aa.refreshFogUniforms(o,s),aa.refreshMaterialUniforms(o,a,q,y),am.upload(c,b.uniformsList,o,r)),a.isShaderMaterial&&a.uniformsNeedUpdate===!0&&(am.upload(c,b.uniformsList,o,r),a.uniformsNeedUpdate=!1),a.isSpriteMaterial&&d.setValue(c,"center",e.center),d.setValue(c,"modelViewMatrix",e.modelViewMatrix),d.setValue(c,"normalMatrix",e.normalMatrix),d.setValue(c,"modelMatrix",e.matrixWorld),p}function aN(a,b){a.ambientLightColor.needsUpdate=b,a.lightProbe.needsUpdate=b,a.directionalLights.needsUpdate=b,a.directionalLightShadows.needsUpdate=b,a.pointLights.needsUpdate=b,a.pointLightShadows.needsUpdate=b,a.spotLights.needsUpdate=b,a.spotLightShadows.needsUpdate=b,a.rectAreaLights.needsUpdate=b,a.hemisphereLights.needsUpdate=b}function aA(a){return a.isMeshLambertMaterial||a.isMeshToonMaterial||a.isMeshPhongMaterial||a.isMeshStandardMaterial||a.isShadowMaterial||a.isShaderMaterial&&a.lights===!0}this.getActiveCubeFace=function(){return U},this.getActiveMipmapLevel=function(){return ab},this.getRenderTarget=function(){return t},this.setRenderTarget=function(a,b=0,e=0){t=a,U=b,ab=e,a&&j.get(a).__webglFramebuffer===void 0&&r.setupRenderTarget(a);let d=null,g=!1,h=!1;if(a){const c=a.texture;(c.isDataTexture3D||c.isDataTexture2DArray)&&(h=!0);const e=j.get(a).__webglFramebuffer;a.isWebGLCubeRenderTarget?(d=e[b],g=!0):a.isWebGLMultisampleRenderTarget?d=j.get(a).__webglMultisampledFramebuffer:d=e,G.copy(a.viewport),Q.copy(a.scissor),$=a.scissorTest}else G.copy(L).multiplyScalar(q).floor(),Q.copy(K).multiplyScalar(q).floor(),$=ad;if(f.bindFramebuffer(36160,d),f.viewport(G),f.scissor(Q),f.setScissorTest($),g){const d=j.get(a.texture);c.framebufferTexture2D(36160,36064,34069+b,d.__webglTexture,e)}else if(h){const d=j.get(a.texture),f=b||0;c.framebufferTextureLayer(36160,36064,d.__webglTexture,e||0,f)}},this.readRenderTargetPixels=function(a,e,d,g,h,k,i){if(!(a&&a.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let b=j.get(a).__webglFramebuffer;if(a.isWebGLCubeRenderTarget&&i!==void 0&&(b=b[i]),b){f.bindFramebuffer(36160,b);try{const i=a.texture,f=i.format,b=i.type;if(f!==N&&w.convert(f)!==c.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const j=b===cw&&(l.has("EXT_color_buffer_half_float")||m.isWebGL2&&l.has("EXT_color_buffer_float"));if(b!==dI&&w.convert(b)!==c.getParameter(35738)&&!(b===ac&&(m.isWebGL2||l.has("OES_texture_float")||l.has("WEBGL_color_buffer_float")))&&!j){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}c.checkFramebufferStatus(36160)===36053?e>=0&&e<=a.width-g&&d>=0&&d<=a.height-h&&c.readPixels(e,d,g,h,w.convert(f),w.convert(b),k):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const a=t!==null?j.get(t).__webglFramebuffer:null;f.bindFramebuffer(36160,a)}}},this.copyFramebufferToTexture=function(b,a,d=0){const e=Math.pow(2,-d),g=Math.floor(a.image.width*e),h=Math.floor(a.image.height*e),i=w.convert(a.format);r.setTexture2D(a,0),c.copyTexImage2D(3553,d,i,b.x,b.y,g,h,0),f.unbindTexture()},this.copyTextureToTexture=function(d,a,b,e=0){const i=a.image.width,j=a.image.height,g=w.convert(b.format),h=w.convert(b.type);r.setTexture2D(b,0),c.pixelStorei(37440,b.flipY),c.pixelStorei(37441,b.premultiplyAlpha),c.pixelStorei(3317,b.unpackAlignment),a.isDataTexture?c.texSubImage2D(3553,e,d.x,d.y,i,j,g,h,a.image.data):a.isCompressedTexture?c.compressedTexSubImage2D(3553,e,d.x,d.y,a.mipmaps[0].width,a.mipmaps[0].height,g,a.mipmaps[0].data):c.texSubImage2D(3553,e,d.x,d.y,g,h,a.image),e===0&&b.generateMipmaps&&c.generateMipmap(3553),f.unbindTexture()},this.copyTextureToTexture3D=function(b,e,n,a,h=0){if(g.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const{width:l,height:j,data:k}=n.image,i=w.convert(a.format),m=w.convert(a.type);let d;if(a.isDataTexture3D)r.setTexture3D(a,0),d=32879;else if(a.isDataTexture2DArray)r.setTexture2DArray(a,0),d=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}c.pixelStorei(37440,a.flipY),c.pixelStorei(37441,a.premultiplyAlpha),c.pixelStorei(3317,a.unpackAlignment);const o=c.getParameter(3314),p=c.getParameter(32878),q=c.getParameter(3316),s=c.getParameter(3315),t=c.getParameter(32877);c.pixelStorei(3314,l),c.pixelStorei(32878,j),c.pixelStorei(3316,b.min.x),c.pixelStorei(3315,b.min.y),c.pixelStorei(32877,b.min.z),c.texSubImage3D(d,h,e.x,e.y,e.z,b.max.x-b.min.x+1,b.max.y-b.min.y+1,b.max.z-b.min.z+1,i,m,k),c.pixelStorei(3314,o),c.pixelStorei(32878,p),c.pixelStorei(3316,q),c.pixelStorei(3315,s),c.pixelStorei(32877,t),h===0&&a.generateMipmaps&&c.generateMipmap(d),f.unbindTexture()},this.initTexture=function(a){r.setTexture2D(a,0),f.unbindTexture()},this.resetState=function(){U=0,ab=0,t=null,f.reset(),n.reset()},typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}jX=class extends j{},jX.prototype.isWebGL1Renderer=!0,fy=class{constructor(a,b=25e-5){this.name="",this.color=new d(a),this.density=b}clone(){return new fy(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}},fy.prototype.isFogExp2=!0,fx=class{constructor(a,b=1,c=1e3){this.name="",this.color=new d(a),this.near=b,this.far=c}clone(){return new fx(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}},fx.prototype.isFog=!0,cN=class extends h{constructor(){super(),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(a,b){return super.copy(a,b),a.background!==null&&(this.background=a.background.clone()),a.environment!==null&&(this.environment=a.environment.clone()),a.fog!==null&&(this.fog=a.fog.clone()),a.overrideMaterial!==null&&(this.overrideMaterial=a.overrideMaterial.clone()),this.autoUpdate=a.autoUpdate,this.matrixAutoUpdate=a.matrixAutoUpdate,this}toJSON(b){const a=super.toJSON(b);return this.background!==null&&(a.object.background=this.background.toJSON(b)),this.environment!==null&&(a.object.environment=this.environment.toJSON(b)),this.fog!==null&&(a.object.fog=this.fog.toJSON()),a}},cN.prototype.isScene=!0,aO=class{constructor(a,b){this.array=a,this.stride=b,this.count=a!==void 0?a.length/b:0,this.usage=bl,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=R(),this.onUploadCallback=function(){}}set needsUpdate(a){a===!0&&this.version++}setUsage(a){return this.usage=a,this}copy(a){return this.array=new a.array.constructor(a.array),this.count=a.count,this.stride=a.stride,this.usage=a.usage,this}copyAt(a,b,c){a*=this.stride,c*=b.stride;for(let d=0,e=this.stride;d<e;d++)this.array[a+d]=b.array[c+d];return this}set(a,b=0){return this.array.set(a,b),this}clone(a){a.arrayBuffers===void 0&&(a.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=R()),a.arrayBuffers[this.array.buffer._uuid]===void 0&&(a.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const c=new this.array.constructor(a.arrayBuffers[this.array.buffer._uuid]),b=new aO(c,this.stride);return b.setUsage(this.usage),b}onUpload(a){return this.onUploadCallback=a,this}toJSON(a){return a.arrayBuffers===void 0&&(a.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=R()),a.arrayBuffers[this.array.buffer._uuid]===void 0&&(a.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}},aO.prototype.isInterleavedBuffer=!0,o=new a,ct=class{constructor(a,b,c,d){this.name="",this.data=a,this.itemSize=b,this.offset=c,this.normalized=d===!0}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(a){this.data.needsUpdate=a}applyMatrix4(a){for(let b=0,c=this.data.count;b<c;b++)o.x=this.getX(b),o.y=this.getY(b),o.z=this.getZ(b),o.applyMatrix4(a),this.setXYZ(b,o.x,o.y,o.z);return this}applyNormalMatrix(a){for(let b=0,c=this.count;b<c;b++)o.x=this.getX(b),o.y=this.getY(b),o.z=this.getZ(b),o.applyNormalMatrix(a),this.setXYZ(b,o.x,o.y,o.z);return this}transformDirection(a){for(let b=0,c=this.count;b<c;b++)o.x=this.getX(b),o.y=this.getY(b),o.z=this.getZ(b),o.transformDirection(a),this.setXYZ(b,o.x,o.y,o.z);return this}setX(a,b){return this.data.array[a*this.data.stride+this.offset]=b,this}setY(a,b){return this.data.array[a*this.data.stride+this.offset+1]=b,this}setZ(a,b){return this.data.array[a*this.data.stride+this.offset+2]=b,this}setW(a,b){return this.data.array[a*this.data.stride+this.offset+3]=b,this}getX(a){return this.data.array[a*this.data.stride+this.offset]}getY(a){return this.data.array[a*this.data.stride+this.offset+1]}getZ(a){return this.data.array[a*this.data.stride+this.offset+2]}getW(a){return this.data.array[a*this.data.stride+this.offset+3]}setXY(a,b,c){return a=a*this.data.stride+this.offset,this.data.array[a+0]=b,this.data.array[a+1]=c,this}setXYZ(a,b,c,d){return a=a*this.data.stride+this.offset,this.data.array[a+0]=b,this.data.array[a+1]=c,this.data.array[a+2]=d,this}setXYZW(a,b,c,d,e){return a=a*this.data.stride+this.offset,this.data.array[a+0]=b,this.data.array[a+1]=c,this.data.array[a+2]=d,this.data.array[a+3]=e,this}clone(a){if(a===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const a=[];for(let b=0;b<this.count;b++){const c=b*this.data.stride+this.offset;for(let b=0;b<this.itemSize;b++)a.push(this.data.array[c+b])}return new u(new this.array.constructor(a),this.itemSize,this.normalized)}return a.interleavedBuffers===void 0&&(a.interleavedBuffers={}),a.interleavedBuffers[this.data.uuid]===void 0&&(a.interleavedBuffers[this.data.uuid]=this.data.clone(a)),new ct(a.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(a){if(a===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const a=[];for(let b=0;b<this.count;b++){const c=b*this.data.stride+this.offset;for(let b=0;b<this.itemSize;b++)a.push(this.data.array[c+b])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:a,normalized:this.normalized}}return a.interleavedBuffers===void 0&&(a.interleavedBuffers={}),a.interleavedBuffers[this.data.uuid]===void 0&&(a.interleavedBuffers[this.data.uuid]=this.data.toJSON(a)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}},ct.prototype.isInterleavedBufferAttribute=!0,fs=class extends r{constructor(a){super(),this.type="SpriteMaterial",this.color=new d(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(a)}copy(a){return super.copy(a),this.color.copy(a.color),this.map=a.map,this.alphaMap=a.alphaMap,this.rotation=a.rotation,this.sizeAttenuation=a.sizeAttenuation,this}},fs.prototype.isSpriteMaterial=!0,bs=new a,aU=new a,ba=new a,aM=new b,bv=new b,fl=new e,bM=new a,bo=new a,bU=new a,fh=new b,dj=new b,ff=new b,kq=class extends h{constructor(a){if(super(),this.type="Sprite",aT===void 0){aT=new l;const b=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),a=new aO(b,5);aT.setIndex([0,1,2,0,2,3]),aT.setAttribute("position",new ct(a,3,0,!1)),aT.setAttribute("uv",new ct(a,2,3,!1))}this.geometry=aT,this.material=a!==void 0?a:new fs,this.center=new b(.5,.5)}raycast(a,i){a.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),aU.setFromMatrixScale(this.matrixWorld),fl.copy(a.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(a.camera.matrixWorldInverse,this.matrixWorld),ba.setFromMatrixPosition(this.modelViewMatrix),a.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&aU.multiplyScalar(-ba.z);const g=this.material.rotation;let c,d;g!==0&&(d=Math.cos(g),c=Math.sin(g));const e=this.center;ci(bM.set(-.5,-.5,0),ba,e,aU,c,d),ci(bo.set(.5,-.5,0),ba,e,aU,c,d),ci(bU.set(.5,.5,0),ba,e,aU,c,d),fh.set(0,0),dj.set(1,0),ff.set(1,1);let h=a.ray.intersectTriangle(bM,bo,bU,!1,bs);if(h===null)if(ci(bo.set(-.5,.5,0),ba,e,aU,c,d),dj.set(0,1),h=a.ray.intersectTriangle(bM,bU,bo,!1,bs),h===null)return;const f=a.ray.origin.distanceTo(bs);if(f<a.near||f>a.far)return;i.push({distance:f,point:bs.clone(),uv:p.getUV(bs,bM,bo,bU,fh,dj,ff,new b),face:null,object:this})}copy(a){return super.copy(a),a.center!==void 0&&this.center.copy(a.center),this.material=a.material,this}},kq.prototype.isSprite=!0;function ci(a,d,e,f,b,c){aM.subVectors(a,e).addScalar(.5).multiply(f),b!==void 0?(bv.x=c*aM.x-b*aM.y,bv.y=b*aM.x+c*aM.y):bv.copy(aM),a.copy(d),a.x+=bv.x,a.y+=bv.y,a.applyMatrix4(fl)}fd=new a,fc=new i,fb=new i,kv=new a,fa=new e,e$=class extends K{constructor(a,b){super(a,b),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new e,this.bindMatrixInverse=new e}copy(a){return super.copy(a),this.bindMode=a.bindMode,this.bindMatrix.copy(a.bindMatrix),this.bindMatrixInverse.copy(a.bindMatrixInverse),this.skeleton=a.skeleton,this}bind(b,a){this.skeleton=b,a===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),a=this.matrixWorld),this.bindMatrix.copy(a),this.bindMatrixInverse.copy(a).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const a=new i,b=this.geometry.attributes.skinWeight;for(let c=0,e=b.count;c<e;c++){a.x=b.getX(c),a.y=b.getY(c),a.z=b.getZ(c),a.w=b.getW(c);const d=1/a.manhattanLength();d!==1/0?a.multiplyScalar(d):a.set(1,0,0,0),b.setXYZW(c,a.x,a.y,a.z,a.w)}}updateMatrixWorld(a){super.updateMatrixWorld(a),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(a,b){const d=this.skeleton,c=this.geometry;fc.fromBufferAttribute(c.attributes.skinIndex,a),fb.fromBufferAttribute(c.attributes.skinWeight,a),fd.fromBufferAttribute(c.attributes.position,a).applyMatrix4(this.bindMatrix),b.set(0,0,0);for(let a=0;a<4;a++){const c=fb.getComponent(a);if(c!==0){const e=fc.getComponent(a);fa.multiplyMatrices(d.bones[e].matrixWorld,d.boneInverses[e]),b.addScaledVector(kv.copy(fd).applyMatrix4(fa),c)}}return b.applyMatrix4(this.bindMatrixInverse)}},e$.prototype.isSkinnedMesh=!0,ky=class extends h{constructor(){super(),this.type="Bone"}},ky.prototype.isBone=!0,eZ=new e,eL=new e,cn=[],bE=new K,kD=class extends K{constructor(b,c,a){super(b,c),this.instanceMatrix=new u(new Float32Array(a*16),16),this.instanceColor=null,this.count=a,this.frustumCulled=!1}copy(a){return super.copy(a),this.instanceMatrix.copy(a.instanceMatrix),a.instanceColor!==null&&(this.instanceColor=a.instanceColor.clone()),this.count=a.count,this}getColorAt(a,b){b.fromArray(this.instanceColor.array,a*3)}getMatrixAt(a,b){b.fromArray(this.instanceMatrix.array,a*16)}raycast(a,b){const c=this.matrixWorld,d=this.count;if(bE.geometry=this.geometry,bE.material=this.material,bE.material===void 0)return;for(let e=0;e<d;e++){this.getMatrixAt(e,eZ),eL.multiplyMatrices(c,eZ),bE.matrixWorld=eL,bE.raycast(a,cn);for(let a=0,d=cn.length;a<d;a++){const c=cn[a];c.instanceId=e,c.object=this,b.push(c)}cn.length=0}}setColorAt(a,b){this.instanceColor===null&&(this.instanceColor=new u(new Float32Array(this.count*3),3)),b.toArray(this.instanceColor.array,a*3)}setMatrixAt(a,b){b.toArray(this.instanceMatrix.array,a*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}},kD.prototype.isInstancedMesh=!0,bn=class extends r{constructor(a){super(),this.type="LineBasicMaterial",this.color=new d(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.morphTargets=!1,this.setValues(a)}copy(a){return super.copy(a),this.color.copy(a.color),this.linewidth=a.linewidth,this.linecap=a.linecap,this.linejoin=a.linejoin,this.morphTargets=a.morphTargets,this}},bn.prototype.isLineBasicMaterial=!0,ee=new a,eb=new a,dR=new e,dP=new aG,ck=new aN,dw=class extends h{constructor(a=new l,b=new bn){super(),this.type="Line",this.geometry=a,this.material=b,this.updateMorphTargets()}copy(a){return super.copy(a),this.material=a.material,this.geometry=a.geometry,this}computeLineDistances(){const a=this.geometry;if(a.isBufferGeometry)if(a.index===null){const c=a.attributes.position,b=[0];for(let a=1,d=c.count;a<d;a++)ee.fromBufferAttribute(c,a-1),eb.fromBufferAttribute(c,a),b[a]=b[a-1],b[a]+=ee.distanceTo(eb);a.setAttribute("lineDistance",new s(b,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else a.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(b,m){const c=this.geometry,l=this.matrixWorld,k=b.params.Line.threshold,e=c.drawRange;if(c.boundingSphere===null&&c.computeBoundingSphere(),ck.copy(c.boundingSphere),ck.applyMatrix4(l),ck.radius+=k,b.ray.intersectsSphere(ck)===!1)return;dR.copy(l).invert(),dP.copy(b.ray).applyMatrix4(dR);const i=k/((this.scale.x+this.scale.y+this.scale.z)/3),j=i*i,h=new a,g=new a,f=new a,d=new a,n=this.isLineSegments?2:1;if(c.isBufferGeometry){const i=c.index,k=c.attributes,a=k.position;if(i!==null){const c=Math.max(0,e.start),k=Math.min(i.count,e.start+e.count);for(let e=c,o=k-1;e<o;e+=n){const p=i.getX(e),q=i.getX(e+1);h.fromBufferAttribute(a,p),g.fromBufferAttribute(a,q);const r=dP.distanceSqToSegment(h,g,d,f);if(r>j)continue;d.applyMatrix4(this.matrixWorld);const l=b.ray.origin.distanceTo(d);if(l<b.near||l>b.far)continue;m.push({distance:l,point:f.clone().applyMatrix4(this.matrixWorld),index:e,face:null,faceIndex:null,object:this})}}else{const c=Math.max(0,e.start),i=Math.min(a.count,e.start+e.count);for(let e=c,l=i-1;e<l;e+=n){h.fromBufferAttribute(a,e),g.fromBufferAttribute(a,e+1);const o=dP.distanceSqToSegment(h,g,d,f);if(o>j)continue;d.applyMatrix4(this.matrixWorld);const k=b.ray.origin.distanceTo(d);if(k<b.near||k>b.far)continue;m.push({distance:k,point:f.clone().applyMatrix4(this.matrixWorld),index:e,face:null,faceIndex:null,object:this})}}}else c.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const a=this.geometry;if(a.isBufferGeometry){{const b=a.morphAttributes,c=Object.keys(b);if(c.length>0){const a=b[c[0]];if(a!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let b=0,c=a.length;b<c;b++){const d=a[b].name||String(b);this.morphTargetInfluences.push(0),this.morphTargetDictionary[d]=b}}}}}else{const b=a.morphTargets;b!==void 0&&b.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}},dw.prototype.isLine=!0,dY=new a,gn=new a,cV=class extends dw{constructor(a,b){super(a,b),this.type="LineSegments"}computeLineDistances(){const a=this.geometry;if(a.isBufferGeometry)if(a.index===null){const c=a.attributes.position,b=[];for(let a=0,d=c.count;a<d;a+=2)dY.fromBufferAttribute(c,a),gn.fromBufferAttribute(c,a+1),b[a]=a===0?0:b[a-1],b[a+1]=b[a]+dY.distanceTo(gn);a.setAttribute("lineDistance",new s(b,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else a.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}},cV.prototype.isLineSegments=!0,kO=class extends dw{constructor(a,b){super(a,b),this.type="LineLoop"}},kO.prototype.isLineLoop=!0,d_=class extends r{constructor(a){super(),this.type="PointsMaterial",this.color=new d(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.morphTargets=!1,this.setValues(a)}copy(a){return super.copy(a),this.color.copy(a.color),this.map=a.map,this.alphaMap=a.alphaMap,this.size=a.size,this.sizeAttenuation=a.sizeAttenuation,this.morphTargets=a.morphTargets,this}},d_.prototype.isPointsMaterial=!0,ec=new e,dc=new aG,bK=new aN,cA=new a,kU=class extends h{constructor(a=new l,b=new d_){super(),this.type="Points",this.geometry=a,this.material=b,this.updateMorphTargets()}copy(a){return super.copy(a),this.material=a.material,this.geometry=a.geometry,this}raycast(c,e){const a=this.geometry,d=this.matrixWorld,f=c.params.Points.threshold,b=a.drawRange;if(a.boundingSphere===null&&a.computeBoundingSphere(),bK.copy(a.boundingSphere),bK.applyMatrix4(d),bK.radius+=f,c.ray.intersectsSphere(bK)===!1)return;ec.copy(d).invert(),dc.copy(c.ray).applyMatrix4(ec);const g=f/((this.scale.x+this.scale.y+this.scale.z)/3),h=g*g;if(a.isBufferGeometry){const f=a.index,i=a.attributes,g=i.position;if(f!==null){const a=Math.max(0,b.start),i=Math.min(f.count,b.start+b.count);for(let b=a,k=i;b<k;b++){const j=f.getX(b);cA.fromBufferAttribute(g,j),ei(cA,j,h,d,c,e,this)}}else{const a=Math.max(0,b.start),f=Math.min(g.count,b.start+b.count);for(let b=a,i=f;b<i;b++)cA.fromBufferAttribute(g,b),ei(cA,b,h,d,c,e,this)}}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const a=this.geometry;if(a.isBufferGeometry){{const b=a.morphAttributes,c=Object.keys(b);if(c.length>0){const a=b[c[0]];if(a!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let b=0,c=a.length;b<c;b++){const d=a[b].name||String(b);this.morphTargetInfluences.push(0),this.morphTargetDictionary[d]=b}}}}}else{const b=a.morphTargets;b!==void 0&&b.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}},kU.prototype.isPoints=!0;function ei(c,i,e,f,b,g,h){const d=dc.distanceSqToPoint(c);if(d<e){const e=new a;dc.closestPointToPoint(c,e),e.applyMatrix4(f);const j=b.ray.origin.distanceTo(e);if(j<b.near||j>b.far)return;g.push({distance:j,distanceToRay:Math.sqrt(d),point:e,index:i,face:null,object:h})}}kW=class extends y{constructor(a,f,g,h,b,c,d,i,j){super(a,f,g,h,b,c,d,i,j),this.format=d!==void 0?d:av,this.minFilter=c!==void 0?c:I,this.magFilter=b!==void 0?b:I,this.generateMipmaps=!1;const k=this;function e(){k.needsUpdate=!0,a.requestVideoFrameCallback(e)}"requestVideoFrameCallback"in a&&a.requestVideoFrameCallback(e)}clone(){return new this.constructor(this.image).copy(this)}update(){const a=this.image,b="requestVideoFrameCallback"in a;b===!1&&a.readyState>=a.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}},kW.prototype.isVideoTexture=!0,kX=class extends y{constructor(a,b,c,d,e,f,g,h,i,j,k,l){super(null,f,g,h,i,j,d,e,k,l),this.image={width:b,height:c},this.mipmaps=a,this.flipY=!1,this.generateMipmaps=!1}},kX.prototype.isCompressedTexture=!0,kY=class extends y{constructor(a,b,c,d,e,f,g,h,i){super(a,b,c,d,e,f,g,h,i),this.needsUpdate=!0}},kY.prototype.isCanvasTexture=!0,kZ=class extends y{constructor(g,h,b,j,e,f,c,d,i,a){if(a=a!==void 0?a:aE,a!==aE&&a!==bA)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");b===void 0&&a===aE&&(b=cp),b===void 0&&a===bA&&(b=bz),super(null,j,e,f,c,d,a,b,i),this.image={width:g,height:h},this.magFilter=c!==void 0?c:A,this.minFilter=d!==void 0?d:A,this.flipY=!1,this.generateMipmaps=!1}},kZ.prototype.isDepthTexture=!0,oE=new a,oD=new a,oC=new a,oB=new p,lc={triangulate:function(b,k,a){a=a||2;const n=k&&k.length,m=n?k[0]*a:b.length;let c=ek(b,0,m,a,!0);const l=[];if(!c||c.next===c.prev)return l;let g,f,i,j,e,d,h;if(n&&(c=lk(b,k,c,a)),b.length>80*a){g=i=b[0],f=j=b[1];for(let c=a;c<m;c+=a)e=b[c],d=b[c+1],e<g&&(g=e),d<f&&(f=d),e>i&&(i=e),d>j&&(j=d);h=Math.max(i-g,j-f),h=h!==0?1/h:0}return bp(c,l,a,g,f,h),l}};function ek(c,e,f,d,g){let a,b;if(g===lH(c,e,f,d)>0)for(a=e;a<f;a+=d)b=ev(a,c[a],c[a+1],b);else for(a=f-d;a>=e;a-=d)b=ev(a,c[a],c[a+1],b);return b&&bV(b,b.next)&&(by(b),b=b.next),b}function an(c,b){if(!c)return c;b||(b=c);let a=c,d;do if(d=!1,!a.steiner&&(bV(a,a.next)||n(a.prev,a,a.next)===0)){if(by(a),a=b=a.prev,a===a.next)break;d=!0}else a=a.next;while(d||a!==b)return b}function bp(a,b,c,e,f,d,h){if(!a)return;!h&&d&&lp(a,e,f,d);let i=a,j,g;while(a.prev!==a.next){if(j=a.prev,g=a.next,d?lh(a,e,f,d):lg(a)){b.push(j.i/c),b.push(a.i/c),b.push(g.i/c),by(a),a=g.next,i=g.next;continue}if(a=g,a===i){h?h===1?(a=li(an(a),b,c),bp(a,b,c,e,f,d,2)):h===2&&lj(a,b,c,e,f,d):bp(an(a),b,c,e,f,d,1);break}}}function lg(b){const c=b.prev,d=b,e=b.next;if(n(c,d,e)>=0)return!1;let a=b.next.next;while(a!==b.prev){if(a_(c.x,c.y,d.x,d.y,e.x,e.y,a.x,a.y)&&n(a.prev,a,a.next)>=0)return!1;a=a.next}return!0}function lh(f,k,h,g){const e=f.prev,d=f,a=f.next;if(n(e,d,a)>=0)return!1;const p=e.x<d.x?e.x<a.x?e.x:a.x:d.x<a.x?d.x:a.x,l=e.y<d.y?e.y<a.y?e.y:a.y:d.y<a.y?d.y:a.y,m=e.x>d.x?e.x>a.x?e.x:a.x:d.x>a.x?d.x:a.x,o=e.y>d.y?e.y>a.y?e.y:a.y:d.y>a.y?d.y:a.y,i=cI(p,l,k,h,g),j=cI(m,o,k,h,g);let b=f.prevZ,c=f.nextZ;while(b&&b.z>=i&&c&&c.z<=j){if(b!==f.prev&&b!==f.next&&a_(e.x,e.y,d.x,d.y,a.x,a.y,b.x,b.y)&&n(b.prev,b,b.next)>=0)return!1;if(b=b.prevZ,c!==f.prev&&c!==f.next&&a_(e.x,e.y,d.x,d.y,a.x,a.y,c.x,c.y)&&n(c.prev,c,c.next)>=0)return!1;c=c.nextZ}while(b&&b.z>=i){if(b!==f.prev&&b!==f.next&&a_(e.x,e.y,d.x,d.y,a.x,a.y,b.x,b.y)&&n(b.prev,b,b.next)>=0)return!1;b=b.prevZ}while(c&&c.z<=j){if(c!==f.prev&&c!==f.next&&a_(e.x,e.y,d.x,d.y,a.x,a.y,c.x,c.y)&&n(c.prev,c,c.next)>=0)return!1;c=c.nextZ}return!0}function li(b,c,d){let a=b;do{const f=a.prev,e=a.next.next;!bV(f,e)&&eo(f,a,a.next,e)&&bB(f,e)&&bB(e,f)&&(c.push(f.i/d),c.push(a.i/d),c.push(e.i/d),by(a),by(a.next),a=b=e),a=a.next}while(a!==b)return an(a)}function lj(g,b,c,d,e,f){let a=g;do{let g=a.next.next;while(g!==a.prev){if(a.i!==g.i&&lu(a,g)){let h=eu(a,g);a=an(a,a.next),h=an(h,h.next),bp(a,b,c,d,e,f),bp(h,b,c,d,e,f);return}g=g.next}a=a.next}while(a!==g)}function lk(h,f,b,g){const d=[];let a,e,i,j,c;for(a=0,e=f.length;a<e;a++)i=f[a]*g,j=a<e-1?f[a+1]*g:h.length,c=ek(h,i,j,g,!1),c===c.next&&(c.steiner=!0),d.push(ls(c));d.sort(ll);for(a=0;a<d.length;a++)lm(d[a],b),b=an(b,b.next);return b}function ll(a,b){return a.x-b.x}function lm(b,a){if(a=ln(b,a),a){const c=eu(a,b);an(a,a.next),an(c,c.next)}}function ln(g,j){let a=j;const d=g.x,c=g.y;let e=-(1/0),b;do{if(c<=a.y&&c>=a.next.y&&a.next.y!==a.y){const f=a.x+(c-a.y)*(a.next.x-a.x)/(a.next.y-a.y);if(f<=d&&f>e){if(e=f,f===d){if(c===a.y)return a;if(c===a.next.y)return a.next}b=a.x<a.next.x?a:a.next}}a=a.next}while(a!==j)if(!b)return null;if(d===e)return b;const l=b,k=b.x,h=b.y;let i=1/0,f;a=b;do d>=a.x&&a.x>=k&&d!==a.x&&a_(c<h?d:e,c,k,h,c<h?e:d,c,a.x,a.y)&&(f=Math.abs(c-a.y)/(d-a.x),bB(a,g)&&(f<i||f===i&&(a.x>b.x||a.x===b.x&&lo(b,a)))&&(b=a,i=f)),a=a.next;while(a!==l)return b}function lo(a,b){return n(a.prev,a,b.prev)<0&&n(b.next,a,a.next)<0}function lp(b,c,d,e){let a=b;do a.z===null&&(a.z=cI(a.x,a.y,c,d,e)),a.prevZ=a.prev,a.nextZ=a.next,a=a.next;while(a!==b)a.prevZ.nextZ=null,a.prevZ=null,lq(a)}function lq(f){let i,b,a,c,d,h,e,g,j=1;do{for(b=f,f=null,d=null,h=0;b;){h++,a=b,e=0;for(i=0;i<j;i++)if(e++,a=a.nextZ,!a)break;for(g=j;e>0||g>0&&a;)e!==0&&(g===0||!a||b.z<=a.z)?(c=b,b=b.nextZ,e--):(c=a,a=a.nextZ,g--),d?d.nextZ=c:f=c,c.prevZ=d,d=c;b=a}d.nextZ=null,j*=2}while(h>1)return f}function cI(a,b,d,e,c){return a=32767*(a-d)*c,b=32767*(b-e)*c,a=(a|a<<8)&16711935,a=(a|a<<4)&252645135,a=(a|a<<2)&858993459,a=(a|a<<1)&1431655765,b=(b|b<<8)&16711935,b=(b|b<<4)&252645135,b=(b|b<<2)&858993459,b=(b|b<<1)&1431655765,a|b<<1}function ls(c){let a=c,b=c;do(a.x<b.x||a.x===b.x&&a.y<b.y)&&(b=a),a=a.next;while(a!==c)return b}function a_(g,h,c,d,e,f,a,b){return(e-a)*(h-b)-(g-a)*(f-b)>=0&&(g-a)*(d-b)-(c-a)*(h-b)>=0&&(c-a)*(f-b)-(e-a)*(d-b)>=0}function lu(a,b){return a.next.i!==b.i&&a.prev.i!==b.i&&!lA(a,b)&&(bB(a,b)&&bB(b,a)&&lC(a,b)&&(n(a.prev,a,b.prev)||n(a,b.prev,b))||bV(a,b)&&n(a.prev,a,a.next)>0&&n(b.prev,b,b.next)>0)}function n(b,a,c){return(a.y-b.y)*(c.x-a.x)-(a.x-b.x)*(c.y-a.y)}function bV(a,b){return a.x===b.x&&a.y===b.y}function eo(a,b,c,d){const e=bO(n(a,b,c)),f=bO(n(a,b,d)),g=bO(n(c,d,a)),h=bO(n(c,d,b));return!!(e!==f&&g!==h)||(!!(e===0&&bS(a,c,b))||(!!(f===0&&bS(a,d,b))||(!!(g===0&&bS(c,a,d))||(!!(h===0&&bS(c,b,d))))))}function bS(a,b,c){return b.x<=Math.max(a.x,c.x)&&b.x>=Math.min(a.x,c.x)&&b.y<=Math.max(a.y,c.y)&&b.y>=Math.min(a.y,c.y)}function bO(a){return a>0?1:a<0?-1:0}function lA(b,c){let a=b;do{if(a.i!==b.i&&a.next.i!==b.i&&a.i!==c.i&&a.next.i!==c.i&&eo(a,a.next,b,c))return!0;a=a.next}while(a!==b)return!1}function bB(a,b){return n(a.prev,a,a.next)<0?n(a,b,a.next)>=0&&n(a,a.prev,b)>=0:n(a,b,a.prev)<0||n(a,a.next,b)<0}function lC(b,e){let a=b,c=!1;const f=(b.x+e.x)/2,d=(b.y+e.y)/2;do a.y>d!==a.next.y>d&&a.next.y!==a.y&&f<(a.next.x-a.x)*(d-a.y)/(a.next.y-a.y)+a.x&&(c=!c),a=a.next;while(a!==b)return c}function eu(a,b){const d=new dd(a.i,a.x,a.y),c=new dd(b.i,b.x,b.y),e=a.next,f=b.prev;return a.next=b,b.prev=a,d.next=e,e.prev=d,c.next=d,d.prev=c,f.next=c,c.prev=f,c}function ev(c,d,e,b){const a=new dd(c,d,e);return b?(a.next=b.next,a.prev=b,b.next.prev=a,b.next=a):(a.prev=a,a.next=a),a}function by(a){a.next.prev=a.prev,a.prev.next=a.next,a.prevZ&&(a.prevZ.nextZ=a.nextZ),a.nextZ&&(a.nextZ.prevZ=a.prevZ)}function dd(a,b,c){this.i=a,this.x=b,this.y=c,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function lH(a,e,b,c){let d=0;for(let f=e,g=b-c;f<b;f+=c)d+=(a[g]-a[f])*(a[f+1]+a[g+1]),g=f;return d}ad=class{static area(a){const b=a.length;let c=0;for(let e=b-1,d=0;d<b;e=d++)c+=a[e].x*a[d].y-a[d].x*a[e].y;return c*.5}static isClockWise(a){return ad.area(a)<0}static triangulateShape(b,a){const c=[],d=[],e=[];ew(b),ex(c,b);let f=b.length;a.forEach(ew);for(let b=0;b<a.length;b++)d.push(f),f+=a[b].length,ex(c,a[b]);const g=lc.triangulate(c,d);for(let a=0;a<g.length;a+=3)e.push(g.slice(a,a+3));return e}};function ew(a){const b=a.length;b>2&&a[b-1].equals(a[0])&&a.pop()}function ex(b,a){for(let c=0;c<a.length;c++)b.push(a[c].x),b.push(a[c].y)}bR=class extends l{constructor(e,c){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:c},e=Array.isArray(e)?e:[e];const f=this,d=[],g=[];for(let a=0,b=e.length;a<b;a++){const c=e[a];h(c)}this.setAttribute("position",new s(d,3)),this.setAttribute("uv",new s(g,2)),this.computeVertexNormals();function h(U){const r=[],R=c.curveSegments!==void 0?c.curveSegments:12,i=c.steps!==void 0?c.steps:1;let B=c.depth!==void 0?c.depth:100,y=c.bevelEnabled===void 0||c.bevelEnabled,A=c.bevelThickness!==void 0?c.bevelThickness:6,C=c.bevelSize!==void 0?c.bevelSize:A-2,E=c.bevelOffset!==void 0?c.bevelOffset:0,q=c.bevelSegments!==void 0?c.bevelSegments:3;const J=c.extrudePath,N=c.UVGenerator!==void 0?c.UVGenerator:lM;c.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),B=c.amount);let u,F=!1,w,v,x,o;J&&(u=J.getSpacedPoints(i),F=!0,y=!1,w=J.computeFrenetFrames(i,!1),v=new a,x=new a,o=new a),y||(q=0,A=0,C=0,E=0);const O=U.extractPoints(R);let h=O.shape;const e=O.holes,Q=!ad.isClockWise(h);if(Q){h=h.reverse();for(let a=0,c=e.length;a<c;a++){const b=e[a];ad.isClockWise(b)&&(e[a]=b.reverse())}}const t=ad.triangulateShape(h,e),j=h;for(let a=0,b=e.length;a<b;a++){const c=e[a];h=h.concat(c)}function s(b,a,c){return a||console.error("THREE.ExtrudeGeometry: vec does not exist"),a.clone().multiplyScalar(c).add(b)}const m=h.length,G=t.length;function L(h,j,k){let e,f,i;const a=h.x-j.x,c=h.y-j.y,d=k.x-h.x,g=k.y-h.y,l=a*a+c*c,m=a*g-c*d;if(Math.abs(m)>Number.EPSILON){const m=Math.sqrt(l),n=Math.sqrt(d*d+g*g),o=j.x-c/m,p=j.y+a/m,s=k.x-g/n,t=k.y+d/n,q=((s-o)*g-(t-p)*d)/(a*g-c*d);e=o+a*q-h.x,f=p+c*q-h.y;const r=e*e+f*f;if(r<=2)return new b(e,f);i=Math.sqrt(r/2)}else{let b=!1;a>Number.EPSILON?d>Number.EPSILON&&(b=!0):a<-Number.EPSILON?d<-Number.EPSILON&&(b=!0):Math.sign(c)===Math.sign(g)&&(b=!0),b?(e=-c,f=a,i=Math.sqrt(l)):(e=a,f=c,i=Math.sqrt(l/2))}return new b(e/i,f/i)}const z=[];for(let a=0,b=j.length,c=b-1,d=a+1;a<b;a++,c++,d++)c===b&&(c=0),d===b&&(d=0),z[a]=L(j[a],j[c],j[d]);const I=[];let p,H=z.concat();for(let b=0,c=e.length;b<c;b++){const a=e[b];p=[];for(let b=0,c=a.length,d=c-1,e=b+1;b<c;b++,d++,e++)d===c&&(d=0),e===c&&(e=0),p[b]=L(a[b],a[d],a[e]);I.push(p),H=H.concat(p)}for(let a=0;a<q;a++){const b=a/q,c=A*Math.cos(b*Math.PI/2),d=C*Math.sin(b*Math.PI/2)+E;for(let a=0,e=j.length;a<e;a++){const b=s(j[a],z[a],d);k(b.x,b.y,-c)}for(let a=0,f=e.length;a<f;a++){const b=e[a];p=I[a];for(let a=0,f=b.length;a<f;a++){const e=s(b[a],p[a],d);k(e.x,e.y,-c)}}}const M=C+E;for(let a=0;a<m;a++){const b=y?s(h[a],H[a],M):h[a];F?(x.copy(w.normals[0]).multiplyScalar(b.x),v.copy(w.binormals[0]).multiplyScalar(b.y),o.copy(u[0]).add(x).add(v),k(o.x,o.y,o.z)):k(b.x,b.y,0)}for(let a=1;a<=i;a++)for(let b=0;b<m;b++){const c=y?s(h[b],H[b],M):h[b];F?(x.copy(w.normals[a]).multiplyScalar(c.x),v.copy(w.binormals[a]).multiplyScalar(c.y),o.copy(u[a]).add(x).add(v),k(o.x,o.y,o.z)):k(c.x,c.y,B/i*a)}for(let a=q-1;a>=0;a--){const c=a/q,b=A*Math.cos(c*Math.PI/2),d=C*Math.sin(c*Math.PI/2)+E;for(let a=0,e=j.length;a<e;a++){const c=s(j[a],z[a],d);k(c.x,c.y,B+b)}for(let a=0,f=e.length;a<f;a++){const c=e[a];p=I[a];for(let a=0,f=c.length;a<f;a++){const e=s(c[a],p[a],d);F?k(e.x,e.y+u[i-1].y,u[i-1].x+b):k(e.x,e.y,B+b)}}}T(),P();function T(){const a=d.length/3;if(y){let b=0,a=m*b;for(let b=0;b<G;b++){const c=t[b];D(c[2]+a,c[1]+a,c[0]+a)}b=i+q*2,a=m*b;for(let b=0;b<G;b++){const c=t[b];D(c[0]+a,c[1]+a,c[2]+a)}}else{for(let a=0;a<G;a++){const b=t[a];D(b[2],b[1],b[0])}for(let a=0;a<G;a++){const b=t[a];D(b[0]+m*i,b[1]+m*i,b[2]+m*i)}}f.addGroup(a,d.length/3-a,0)}function P(){const b=d.length/3;let a=0;K(j,a),a+=j.length;for(let b=0,d=e.length;b<d;b++){const c=e[b];K(c,a),a+=c.length}f.addGroup(b,d.length/3-b,1)}function K(c,a){let b=c.length;while(--b>=0){const e=b;let d=b-1;d<0&&(d=c.length-1);for(let b=0,g=i+q*2;b<g;b++){const c=m*b,f=m*(b+1),h=a+e+c,j=a+d+c,k=a+d+f,l=a+e+f;S(h,j,k,l)}}}function k(a,b,c){r.push(a),r.push(b),r.push(c)}function D(c,e,g){n(c),n(e),n(g);const a=d.length/3,b=N.generateTopUV(f,d,a-3,a-2,a-1);l(b[0]),l(b[1]),l(b[2])}function S(g,c,h,e){n(g),n(c),n(e),n(c),n(h),n(e);const b=d.length/3,a=N.generateSideWallUV(f,d,b-6,b-3,b-2,b-1);l(a[0]),l(a[1]),l(a[3]),l(a[1]),l(a[2]),l(a[3])}function n(a){d.push(r[a*3+0]),d.push(r[a*3+1]),d.push(r[a*3+2])}function l(a){g.push(a.x),g.push(a.y)}}}toJSON(){const a=l.prototype.toJSON.call(this),b=this.parameters.shapes,c=this.parameters.options;return lN(b,c,a)}},lM={generateTopUV:function(l,a,c,d,e){const g=a[c*3],f=a[c*3+1],h=a[d*3],i=a[d*3+1],j=a[e*3],k=a[e*3+1];return[new b(g,f),new b(h,i),new b(j,k)]},generateSideWallUV:function(s,a,c,d,e,f){const p=a[c*3],i=a[c*3+1],j=a[c*3+2],m=a[d*3],l=a[d*3+1],g=a[d*3+2],n=a[e*3],o=a[e*3+1],h=a[e*3+2],q=a[f*3],r=a[f*3+1],k=a[f*3+2];return Math.abs(i-l)<.01?[new b(p,1-j),new b(m,1-g),new b(n,1-h),new b(q,1-k)]:[new b(i,1-j),new b(l,1-g),new b(o,1-h),new b(r,1-k)]}};function lN(b,c,a){if(a.shapes=[],Array.isArray(b))for(let c=0,d=b.length;c<d;c++){const e=b[c];a.shapes.push(e.uuid)}else a.shapes.push(b.uuid);return c.extrudePath!==void 0&&(a.options.extrudePath=c.extrudePath.toJSON()),a}lO=class extends l{constructor(a,h=12){super(),this.type="ShapeGeometry",this.parameters={shapes:a,curveSegments:h};const d=[],c=[],e=[],f=[];let g=0,b=0;if(Array.isArray(a)===!1)i(a);else for(let c=0;c<a.length;c++)i(a[c]),this.addGroup(g,b,c),g+=b,b=0;this.setIndex(d),this.setAttribute("position",new s(c,3)),this.setAttribute("normal",new s(e,3)),this.setAttribute("uv",new s(f,2));function i(l){const i=c.length/3,j=l.extractPoints(h);let a=j.shape;const g=j.holes;ad.isClockWise(a)===!1&&(a=a.reverse());for(let a=0,c=g.length;a<c;a++){const b=g[a];ad.isClockWise(b)===!0&&(g[a]=b.reverse())}const k=ad.triangulateShape(a,g);for(let b=0,c=g.length;b<c;b++){const d=g[b];a=a.concat(d)}for(let d=0,g=a.length;d<g;d++){const b=a[d];c.push(b.x,b.y,0),e.push(0,0,1),f.push(b.x,b.y)}for(let a=0,e=k.length;a<e;a++){const c=k[a],f=c[0]+i,g=c[1]+i,h=c[2]+i;d.push(f,g,h),b+=3}}}toJSON(){const a=l.prototype.toJSON.call(this),b=this.parameters.shapes;return lP(b,a)}};function lP(a,b){if(b.shapes=[],Array.isArray(a))for(let c=0,d=a.length;c<d;c++){const e=a[c];b.shapes.push(e.uuid)}else b.shapes.push(a.uuid);return b}lQ=class extends r{constructor(a){super(),this.type="ShadowMaterial",this.color=new d(0),this.transparent=!0,this.setValues(a)}copy(a){return super.copy(a),this.color.copy(a.color),this}},lQ.prototype.isShadowMaterial=!0,lR=class extends ak{constructor(a){super(a),this.type="RawShaderMaterial"}},lR.prototype.isRawShaderMaterial=!0,ey=class extends r{constructor(a){super(),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new d(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new d(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=aS,this.normalScale=new b(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.vertexTangents=!1,this.setValues(a)}copy(a){return super.copy(a),this.defines={STANDARD:""},this.color.copy(a.color),this.roughness=a.roughness,this.metalness=a.metalness,this.map=a.map,this.lightMap=a.lightMap,this.lightMapIntensity=a.lightMapIntensity,this.aoMap=a.aoMap,this.aoMapIntensity=a.aoMapIntensity,this.emissive.copy(a.emissive),this.emissiveMap=a.emissiveMap,this.emissiveIntensity=a.emissiveIntensity,this.bumpMap=a.bumpMap,this.bumpScale=a.bumpScale,this.normalMap=a.normalMap,this.normalMapType=a.normalMapType,this.normalScale.copy(a.normalScale),this.displacementMap=a.displacementMap,this.displacementScale=a.displacementScale,this.displacementBias=a.displacementBias,this.roughnessMap=a.roughnessMap,this.metalnessMap=a.metalnessMap,this.alphaMap=a.alphaMap,this.envMap=a.envMap,this.envMapIntensity=a.envMapIntensity,this.refractionRatio=a.refractionRatio,this.wireframe=a.wireframe,this.wireframeLinewidth=a.wireframeLinewidth,this.wireframeLinecap=a.wireframeLinecap,this.wireframeLinejoin=a.wireframeLinejoin,this.skinning=a.skinning,this.morphTargets=a.morphTargets,this.morphNormals=a.morphNormals,this.flatShading=a.flatShading,this.vertexTangents=a.vertexTangents,this}},ey.prototype.isMeshStandardMaterial=!0,lT=class extends ey{constructor(a){super(),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoat=0,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new b(1,1),this.clearcoatNormalMap=null,this.reflectivity=.5,Object.defineProperty(this,"ior",{get:function(){return(1+.4*this.reflectivity)/(1-.4*this.reflectivity)},set:function(a){this.reflectivity=E(2.5*(a-1)/(a+1),0,1)}}),this.sheen=null,this.transmission=0,this.transmissionMap=null,this.setValues(a)}copy(a){return super.copy(a),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=a.clearcoat,this.clearcoatMap=a.clearcoatMap,this.clearcoatRoughness=a.clearcoatRoughness,this.clearcoatRoughnessMap=a.clearcoatRoughnessMap,this.clearcoatNormalMap=a.clearcoatNormalMap,this.clearcoatNormalScale.copy(a.clearcoatNormalScale),this.reflectivity=a.reflectivity,a.sheen?this.sheen=(this.sheen||new d).copy(a.sheen):this.sheen=null,this.transmission=a.transmission,this.transmissionMap=a.transmissionMap,this}},lT.prototype.isMeshPhysicalMaterial=!0,lU=class extends r{constructor(a){super(),this.type="MeshPhongMaterial",this.color=new d(16777215),this.specular=new d(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new d(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=aS,this.normalScale=new b(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=ch,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.setValues(a)}copy(a){return super.copy(a),this.color.copy(a.color),this.specular.copy(a.specular),this.shininess=a.shininess,this.map=a.map,this.lightMap=a.lightMap,this.lightMapIntensity=a.lightMapIntensity,this.aoMap=a.aoMap,this.aoMapIntensity=a.aoMapIntensity,this.emissive.copy(a.emissive),this.emissiveMap=a.emissiveMap,this.emissiveIntensity=a.emissiveIntensity,this.bumpMap=a.bumpMap,this.bumpScale=a.bumpScale,this.normalMap=a.normalMap,this.normalMapType=a.normalMapType,this.normalScale.copy(a.normalScale),this.displacementMap=a.displacementMap,this.displacementScale=a.displacementScale,this.displacementBias=a.displacementBias,this.specularMap=a.specularMap,this.alphaMap=a.alphaMap,this.envMap=a.envMap,this.combine=a.combine,this.reflectivity=a.reflectivity,this.refractionRatio=a.refractionRatio,this.wireframe=a.wireframe,this.wireframeLinewidth=a.wireframeLinewidth,this.wireframeLinecap=a.wireframeLinecap,this.wireframeLinejoin=a.wireframeLinejoin,this.skinning=a.skinning,this.morphTargets=a.morphTargets,this.morphNormals=a.morphNormals,this.flatShading=a.flatShading,this}},lU.prototype.isMeshPhongMaterial=!0,lV=class extends r{constructor(a){super(),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new d(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new d(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=aS,this.normalScale=new b(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(a)}copy(a){return super.copy(a),this.color.copy(a.color),this.map=a.map,this.gradientMap=a.gradientMap,this.lightMap=a.lightMap,this.lightMapIntensity=a.lightMapIntensity,this.aoMap=a.aoMap,this.aoMapIntensity=a.aoMapIntensity,this.emissive.copy(a.emissive),this.emissiveMap=a.emissiveMap,this.emissiveIntensity=a.emissiveIntensity,this.bumpMap=a.bumpMap,this.bumpScale=a.bumpScale,this.normalMap=a.normalMap,this.normalMapType=a.normalMapType,this.normalScale.copy(a.normalScale),this.displacementMap=a.displacementMap,this.displacementScale=a.displacementScale,this.displacementBias=a.displacementBias,this.alphaMap=a.alphaMap,this.wireframe=a.wireframe,this.wireframeLinewidth=a.wireframeLinewidth,this.wireframeLinecap=a.wireframeLinecap,this.wireframeLinejoin=a.wireframeLinejoin,this.skinning=a.skinning,this.morphTargets=a.morphTargets,this.morphNormals=a.morphNormals,this}},lV.prototype.isMeshToonMaterial=!0,lW=class extends r{constructor(a){super(),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=aS,this.normalScale=new b(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.setValues(a)}copy(a){return super.copy(a),this.bumpMap=a.bumpMap,this.bumpScale=a.bumpScale,this.normalMap=a.normalMap,this.normalMapType=a.normalMapType,this.normalScale.copy(a.normalScale),this.displacementMap=a.displacementMap,this.displacementScale=a.displacementScale,this.displacementBias=a.displacementBias,this.wireframe=a.wireframe,this.wireframeLinewidth=a.wireframeLinewidth,this.skinning=a.skinning,this.morphTargets=a.morphTargets,this.morphNormals=a.morphNormals,this.flatShading=a.flatShading,this}},lW.prototype.isMeshNormalMaterial=!0,lX=class extends r{constructor(a){super(),this.type="MeshLambertMaterial",this.color=new d(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new d(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=ch,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(a)}copy(a){return super.copy(a),this.color.copy(a.color),this.map=a.map,this.lightMap=a.lightMap,this.lightMapIntensity=a.lightMapIntensity,this.aoMap=a.aoMap,this.aoMapIntensity=a.aoMapIntensity,this.emissive.copy(a.emissive),this.emissiveMap=a.emissiveMap,this.emissiveIntensity=a.emissiveIntensity,this.specularMap=a.specularMap,this.alphaMap=a.alphaMap,this.envMap=a.envMap,this.combine=a.combine,this.reflectivity=a.reflectivity,this.refractionRatio=a.refractionRatio,this.wireframe=a.wireframe,this.wireframeLinewidth=a.wireframeLinewidth,this.wireframeLinecap=a.wireframeLinecap,this.wireframeLinejoin=a.wireframeLinejoin,this.skinning=a.skinning,this.morphTargets=a.morphTargets,this.morphNormals=a.morphNormals,this}},lX.prototype.isMeshLambertMaterial=!0,lY=class extends r{constructor(a){super(),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new d(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=aS,this.normalScale=new b(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.setValues(a)}copy(a){return super.copy(a),this.defines={MATCAP:""},this.color.copy(a.color),this.matcap=a.matcap,this.map=a.map,this.bumpMap=a.bumpMap,this.bumpScale=a.bumpScale,this.normalMap=a.normalMap,this.normalMapType=a.normalMapType,this.normalScale.copy(a.normalScale),this.displacementMap=a.displacementMap,this.displacementScale=a.displacementScale,this.displacementBias=a.displacementBias,this.alphaMap=a.alphaMap,this.skinning=a.skinning,this.morphTargets=a.morphTargets,this.morphNormals=a.morphNormals,this.flatShading=a.flatShading,this}},lY.prototype.isMeshMatcapMaterial=!0,lZ=class extends bn{constructor(a){super(),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(a)}copy(a){return super.copy(a),this.scale=a.scale,this.dashSize=a.dashSize,this.gapSize=a.gapSize,this}},lZ.prototype.isLineDashedMaterial=!0,m={arraySlice:function(a,c,b){return m.isTypedArray(a)?new a.constructor(a.subarray(c,b!==void 0?b:a.length)):a.slice(c,b)},convertArray:function(a,b,c){return!a||!c&&a.constructor===b?a:typeof b.BYTES_PER_ELEMENT=="number"?new b(a):Array.prototype.slice.call(a)},isTypedArray:function(a){return ArrayBuffer.isView(a)&&!(a instanceof DataView)},getKeyframeOrder:function(a){function d(b,c){return a[b]-a[c]}const c=a.length,b=new Array(c);for(let a=0;a!==c;++a)b[a]=a;return b.sort(d),b},sortedArray:function(a,b,e){const c=a.length,d=new a.constructor(c);for(let f=0,g=0;g!==c;++f){const h=e[f]*b;for(let c=0;c!==b;++c)d[g++]=a[h+c]}return d},flattenJSON:function(e,g,c,d){let f=1,a=e[0];while(a!==void 0&&a[d]===void 0)a=e[f++];if(a===void 0)return;let b=a[d];if(b===void 0)return;if(Array.isArray(b))do b=a[d],b!==void 0&&(g.push(a.time),c.push.apply(c,b)),a=e[f++];while(a!==void 0)else if(b.toArray!==void 0)do b=a[d],b!==void 0&&(g.push(a.time),b.toArray(c,c.length)),a=e[f++];while(a!==void 0)else do b=a[d],b!==void 0&&(g.push(a.time),c.push(b)),a=e[f++];while(a!==void 0)},subclip:function(g,h,d,e,f=30){const a=g.clone();a.name=h;const c=[];for(let g=0;g<a.tracks.length;++g){const b=a.tracks[g],i=b.getValueSize(),h=[],j=[];for(let a=0;a<b.times.length;++a){const c=b.times[a]*f;if(c<d||c>=e)continue;h.push(b.times[a]);for(let c=0;c<i;++c)j.push(b.values[a*i+c])}if(h.length===0)continue;b.times=m.convertArray(h,b.times.constructor),b.values=m.convertArray(j,b.values.constructor),c.push(b)}a.tracks=c;let b=1/0;for(let c=0;c<a.tracks.length;++c)b>a.tracks[c].times[0]&&(b=a.tracks[c].times[0]);for(let c=0;c<a.tracks.length;++c)a.tracks[c].shift(-1*b);return a.resetDuration(),a},makeClipAdditive:function(a,e=0,d=a,b=30){b<=0&&(b=30);const f=d.tracks.length,c=e/b;for(let k=0;k<f;++k){const b=d.tracks[k],i=b.ValueTypeName;if(i==="bool"||i==="string")continue;const e=a.tracks.find(function(a){return a.name===b.name&&a.ValueTypeName===i});if(e===void 0)continue;let g=0;const j=b.getValueSize();b.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(g=j/3);let l=0;const n=e.getValueSize();e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(l=n/3);const o=b.times.length-1;let h;if(c<=b.times[0]){const a=g,c=j-g;h=m.arraySlice(b.values,a,c)}else if(c>=b.times[o]){const a=o*j+g,c=a+j-g;h=m.arraySlice(b.values,a,c)}else{const a=b.createInterpolant(),d=g,e=j-g;a.evaluate(c),h=m.arraySlice(a.resultBuffer,d,e)}if(i==="quaternion"){const a=(new B).fromArray(h).normalize().conjugate();a.toArray(h)}const p=e.times.length;for(let a=0;a<p;++a){const b=a*n+l;if(i==="quaternion")B.multiplyQuaternionsFlat(e.values,b,h,0,e.values,b);else{const a=n-l*2;for(let c=0;c<a;++c)e.values[b+c]-=h[c]}}}return a.blendMode=et,a}},aa=class{constructor(d,a,b,c){this.parameterPositions=d,this._cachedIndex=0,this.resultBuffer=c!==void 0?c:new a.constructor(b),this.sampleValues=a,this.valueSize=b,this.settings=null,this.DefaultSettings_={}}evaluate(c){const e=this.parameterPositions;let a=this._cachedIndex,d=e[a],b=e[a-1];validate_interval:{seek:{let f;linear_scan:{forward_scan:if(!(c<d)){for(let f=a+2;;){if(d===void 0){if(c<b)break forward_scan;return a=e.length,this._cachedIndex=a,this.afterEnd_(a-1,c,b)}if(a===f)break;if(b=d,d=e[++a],c<d)break seek}f=e.length;break linear_scan}if(!(c>=b)){const g=e[1];if(c<g){a=2;b=g}for(let f=a-2;;){if(b===void 0)return this._cachedIndex=0,this.beforeStart_(0,c,d);if(a===f)break;if(d=b,b=e[--a-1],c>=b)break seek}f=a;a=0;break linear_scan}break validate_interval}while(a<f){const b=a+f>>>1;c<e[b]?f=b:a=b+1}d=e[a];b=e[a-1];if(b===void 0){this._cachedIndex=0;return this.beforeStart_(0,c,d)}if(d===void 0){a=e.length;this._cachedIndex=a;return this.afterEnd_(a-1,b,c)}}this._cachedIndex=a;this.intervalChanged_(a,b,d)}return this.interpolate_(a,b,c,d)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(c){const a=this.resultBuffer,d=this.sampleValues,b=this.valueSize,e=c*b;for(let c=0;c!==b;++c)a[c]=d[e+c];return a}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}},aa.prototype.beforeStart_=aa.prototype.copySampleValue_,aa.prototype.afterEnd_=aa.prototype.copySampleValue_,ma=class extends aa{constructor(a,b,c,d){super(a,b,c,d),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:aH,endingEnd:aH}}intervalChanged_(c,d,e){const a=this.parameterPositions;let b=c-2,f=c+1,g=a[b],h=a[f];if(g===void 0)switch(this.getSettings_().endingStart){case ay:b=c,g=2*d-e;break;case cb:b=a.length-2,g=d+a[b]-a[b+1];break;default:b=c,g=e}if(h===void 0)switch(this.getSettings_().endingEnd){case ay:f=c,h=2*e-d;break;case cb:f=1,h=e+a[1]-a[0];break;default:f=c-1,h=d}const i=(e-d)*.5,j=this.valueSize;this._weightPrev=i/(d-g),this._weightNext=i/(h-e),this._offsetPrev=b*j,this._offsetNext=f*j}interpolate_(k,h,p,o){const i=this.resultBuffer,d=this.sampleValues,g=this.valueSize,j=k*g,n=j-g,m=this._offsetPrev,l=this._offsetNext,a=this._weightPrev,f=this._weightNext,b=(p-h)/(o-h),c=b*b,e=c*b,q=-a*e+2*a*c-a*b,r=(1+a)*e+(-1.5-2*a)*c+(-.5+a)*b+1,s=(-1-f)*e+(1.5+f)*c+.5*b,t=f*e-f*c;for(let a=0;a!==g;++a)i[a]=q*d[m+a]+r*d[n+a]+s*d[j+a]+t*d[l+a];return i}},ez=class extends aa{constructor(a,b,c,d){super(a,b,c,d)}interpolate_(h,b,g,j){const d=this.resultBuffer,e=this.sampleValues,a=this.valueSize,f=h*a,i=f-a,c=(g-b)/(j-b),k=1-c;for(let b=0;b!==a;++b)d[b]=e[i+b]*k+e[f+b]*c;return d}},mc=class extends aa{constructor(a,b,c,d){super(a,b,c,d)}interpolate_(a){return this.copySampleValue_(a-1)}},T=class{constructor(a,b,c,d){if(a===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(b===void 0||b.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+a);this.name=a,this.times=m.convertArray(b,this.TimeBufferType),this.values=m.convertArray(c,this.ValueBufferType),this.setInterpolation(d||this.DefaultInterpolation)}static toJSON(a){const c=a.constructor;let b;if(c.toJSON!==this.toJSON)b=c.toJSON(a);else{b={name:a.name,times:m.convertArray(a.times,Array),values:m.convertArray(a.values,Array)};const c=a.getInterpolation();c!==a.DefaultInterpolation&&(b.interpolation=c)}return b.type=a.ValueTypeName,b}InterpolantFactoryMethodDiscrete(a){return new mc(this.times,this.values,this.getValueSize(),a)}InterpolantFactoryMethodLinear(a){return new ez(this.times,this.values,this.getValueSize(),a)}InterpolantFactoryMethodSmooth(a){return new ma(this.times,this.values,this.getValueSize(),a)}setInterpolation(b){let a;switch(b){case bJ:a=this.InterpolantFactoryMethodDiscrete;break;case bH:a=this.InterpolantFactoryMethodLinear;break;case da:a=this.InterpolantFactoryMethodSmooth;break}if(a===void 0){const a="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(b!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(a);return console.warn("THREE.KeyframeTrack:",a),this}return this.createInterpolant=a,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return bJ;case this.InterpolantFactoryMethodLinear:return bH;case this.InterpolantFactoryMethodSmooth:return da}}getValueSize(){return this.values.length/this.times.length}shift(a){if(a!==0){const b=this.times;for(let c=0,d=b.length;c!==d;++c)b[c]+=a}return this}scale(a){if(a!==1){const b=this.times;for(let c=0,d=b.length;c!==d;++c)b[c]*=a}return this}trim(e,f){const c=this.times,d=c.length;let b=0,a=d-1;while(b!==d&&c[b]<e)++b;while(a!==-1&&c[a]>f)--a;if(++a,b!==0||a!==d){b>=a&&(a=Math.max(a,1),b=a-1);const d=this.getValueSize();this.times=m.arraySlice(c,b,a),this.values=m.arraySlice(this.values,b*d,a*d)}return this}validate(){let a=!0;const d=this.getValueSize();d-Math.floor(d)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),a=!1);const e=this.times,b=this.values,f=e.length;f===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),a=!1);let c=null;for(let d=0;d!==f;d++){const b=e[d];if(typeof b=="number"&&isNaN(b)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,d,b),a=!1;break}if(c!==null&&c>b){console.error("THREE.KeyframeTrack: Out of order keys.",this,d,b,c),a=!1;break}c=b}if(b!==void 0)if(m.isTypedArray(b))for(let c=0,e=b.length;c!==e;++c){const d=b[c];if(isNaN(d)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,c,d),a=!1;break}}return a}optimize(){const a=m.arraySlice(this.times),d=m.arraySlice(this.values),b=this.getValueSize(),f=this.getInterpolation()===da,e=a.length-1;let c=1;for(let g=1;g<e;++g){let h=!1;const i=a[g],j=a[g+1];if(i!==j&&(g!==1||i!==a[0]))if(f)h=!0;else{const a=g*b,c=a-b,e=a+b;for(let f=0;f!==b;++f){const g=d[a+f];if(g!==d[c+f]||g!==d[e+f]){h=!0;break}}}if(h){if(g!==c){a[c]=a[g];const e=g*b,f=c*b;for(let a=0;a!==b;++a)d[f+a]=d[e+a]}++c}}if(e>0){a[c]=a[e];for(let f=e*b,g=c*b,a=0;a!==b;++a)d[g+a]=d[f+a];++c}return c!==a.length?(this.times=m.arraySlice(a,0,c),this.values=m.arraySlice(d,0,c*b)):(this.times=a,this.values=d),this}clone(){const b=m.arraySlice(this.times,0),c=m.arraySlice(this.values,0),d=this.constructor,a=new d(this.name,b,c);return a.createInterpolant=this.createInterpolant,a}},T.prototype.TimeBufferType=Float32Array,T.prototype.ValueBufferType=Float32Array,T.prototype.DefaultInterpolation=bH,aW=class extends T{},aW.prototype.ValueTypeName="bool",aW.prototype.ValueBufferType=Array,aW.prototype.DefaultInterpolation=bJ,aW.prototype.InterpolantFactoryMethodLinear=void 0,aW.prototype.InterpolantFactoryMethodSmooth=void 0,eA=class extends T{},eA.prototype.ValueTypeName="color",bY=class extends T{},bY.prototype.ValueTypeName="number",mh=class extends aa{constructor(a,b,c,d){super(a,b,c,d)}interpolate_(g,c,i,f){const d=this.resultBuffer,e=this.sampleValues,b=this.valueSize,h=(i-c)/(f-c);let a=g*b;for(let c=a+b;a!==c;a+=4)B.slerpFlat(d,0,e,a-b,e,a,h);return d}},bk=class extends T{InterpolantFactoryMethodLinear(a){return new mh(this.times,this.values,this.getValueSize(),a)}},bk.prototype.ValueTypeName="quaternion",bk.prototype.DefaultInterpolation=bH,bk.prototype.InterpolantFactoryMethodSmooth=void 0,aX=class extends T{},aX.prototype.ValueTypeName="string",aX.prototype.ValueBufferType=Array,aX.prototype.DefaultInterpolation=bJ,aX.prototype.InterpolantFactoryMethodLinear=void 0,aX.prototype.InterpolantFactoryMethodSmooth=void 0,cz=class extends T{},cz.prototype.ValueTypeName="vector",eB=class{constructor(a,b=-1,c,d=c$){this.name=a,this.tracks=c,this.duration=b,this.blendMode=d,this.uuid=R(),this.duration<0&&this.resetDuration()}static parse(a){const b=[],c=a.tracks,e=1/(a.fps||1);for(let a=0,d=c.length;a!==d;++a)b.push(mn(c[a]).scale(e));const d=new this(a.name,a.duration,b,a.blendMode);return d.uuid=a.uuid,d}static toJSON(a){const b=[],c=a.tracks,d={name:a.name,duration:a.duration,tracks:b,uuid:a.uuid,blendMode:a.blendMode};for(let a=0,d=c.length;a!==d;++a)b.push(T.toJSON(c[a]));return d}static CreateFromMorphTargetSequence(d,b,e,f){const a=b.length,c=[];for(let g=0;g<a;g++){let d=[],h=[];d.push((g+a-1)%a,g,(g+1)%a),h.push(0,1,0);const i=m.getKeyframeOrder(d);d=m.sortedArray(d,1,i),h=m.sortedArray(h,1,i),!f&&d[0]===0&&(d.push(a),h.push(h[0])),c.push(new bY(".morphTargetInfluences["+b[g].name+"]",d,h).scale(1/e))}return new this(d,-1,c)}static findByName(b,c){let a=b;if(!Array.isArray(b)){const c=b;a=c.geometry&&c.geometry.animations||c.animations}for(let b=0;b<a.length;b++)if(a[b].name===c)return a[b];return null}static CreateClipsFromMorphTargetSequences(b,d,e){const a={},f=/^([\w-]*?)([\d]+)$/;for(let c=0,g=b.length;c<g;c++){const e=b[c],d=e.name.match(f);if(d&&d.length>1){const c=d[1];let b=a[c];b||(a[c]=b=[]),b.push(e)}}const c=[];for(const b in a)c.push(this.CreateFromMorphTargetSequence(b,a[b],d,e));return c}static parseAnimation(a,i){if(!a)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const c=function(b,c,a,d,e){if(a.length!==0){const f=[],g=[];m.flattenJSON(a,f,g,d),f.length!==0&&e.push(new b(c,f,g))}},b=[],f=a.name||"default",g=a.fps||30,h=a.blendMode;let d=a.length||-1;const e=a.hierarchy||[];for(let f=0;f<e.length;f++){const a=e[f].keys;if(!a||a.length===0)continue;if(a[0].morphTargets){const e={};let c;for(c=0;c<a.length;c++)if(a[c].morphTargets)for(let b=0;b<a[c].morphTargets.length;b++)e[a[c].morphTargets[b]]=-1;for(const d in e){const f=[],g=[];for(let b=0;b!==a[c].morphTargets.length;++b){const e=a[c];f.push(e.time),g.push(e.morphTarget===d?1:0)}b.push(new bY(".morphTargetInfluence["+d+"]",f,g))}d=e.length*(g||1)}else{const d=".bones["+i[f].name+"]";c(cz,d+".position",a,"pos",b),c(bk,d+".quaternion",a,"rot",b),c(cz,d+".scale",a,"scl",b)}}if(b.length===0)return null;const j=new this(f,d,b,h);return j}resetDuration(){const b=this.tracks;let a=0;for(let c=0,e=b.length;c!==e;++c){const d=this.tracks[c];a=Math.max(a,d.times[d.times.length-1])}return this.duration=a,this}trim(){for(let a=0;a<this.tracks.length;a++)this.tracks[a].trim(0,this.duration);return this}validate(){let a=!0;for(let b=0;b<this.tracks.length;b++)a=a&&this.tracks[b].validate();return a}optimize(){for(let a=0;a<this.tracks.length;a++)this.tracks[a].optimize();return this}clone(){const a=[];for(let b=0;b<this.tracks.length;b++)a.push(this.tracks[b].clone());return new this.constructor(this.name,this.duration,a,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}};function mm(a){switch(a.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return bY;case"vector":case"vector2":case"vector3":case"vector4":return cz;case"color":return eA;case"quaternion":return bk;case"bool":case"boolean":return aW;case"string":return aX}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+a)}function mn(a){if(a.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const b=mm(a.type);if(a.times===void 0){const b=[],c=[];m.flattenJSON(a.keys,b,c,"value"),a.times=b,a.values=c}return b.parse!==void 0?b.parse(a):new b(a.name,a.times,a.values,a.interpolation)}a$={enabled:!1,files:{},add:function(a,b){if(this.enabled===!1)return;this.files[a]=b},get:function(a){if(this.enabled===!1)return;return this.files[a]},remove:function(a){delete this.files[a]},clear:function(){this.files={}}},mp=class{constructor(g,h,i){const a=this;let f=!1,d=0,c=0,e=void 0;const b=[];this.onStart=void 0,this.onLoad=g,this.onProgress=h,this.onError=i,this.itemStart=function(b){c++,f===!1&&a.onStart!==void 0&&a.onStart(b,d,c),f=!0},this.itemEnd=function(b){d++,a.onProgress!==void 0&&a.onProgress(b,d,c),d===c&&(f=!1,a.onLoad!==void 0&&a.onLoad())},this.itemError=function(b){a.onError!==void 0&&a.onError(b)},this.resolveURL=function(a){return e?e(a):a},this.setURLModifier=function(a){return e=a,this},this.addHandler=function(a,c){return b.push(a,c),this},this.removeHandler=function(c){const a=b.indexOf(c);return a!==-1&&b.splice(a,2),this},this.getHandler=function(a){for(let c=0,e=b.length;c<e;c+=2){const d=b[c],f=b[c+1];if(d.global&&(d.lastIndex=0),d.test(a))return f}return null}}},mq=new mp,ab=class{constructor(a){this.manager=a!==void 0?a:mq,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(a,b){const c=this;return new Promise(function(d,e){c.load(a,d,b,e)})}parse(){}setCrossOrigin(a){return this.crossOrigin=a,this}setWithCredentials(a){return this.withCredentials=a,this}setPath(a){return this.path=a,this}setResourcePath(a){return this.resourcePath=a,this}setRequestHeader(a){return this.requestHeader=a,this}},M={},mt=class extends ab{constructor(a){super(a)}load(a,d,h,e){a===void 0&&(a=""),this.path!==void 0&&(a=this.path+a),a=this.manager.resolveURL(a);const c=this,g=a$.get(a);if(g!==void 0)return c.manager.itemStart(a),setTimeout(function(){d&&d(g),c.manager.itemEnd(a)},0),g;if(M[a]!==void 0){M[a].push({onLoad:d,onProgress:h,onError:e});return}const i=/^data:(.*?)(;base64)?,(.*)$/,f=a.match(i);let b;if(f){const g=f[1],h=!!f[2];let b=f[3];b=decodeURIComponent(b),h&&(b=atob(b));try{let e;const f=(this.responseType||"").toLowerCase();switch(f){case"arraybuffer":case"blob":const a=new Uint8Array(b.length);for(let c=0;c<b.length;c++)a[c]=b.charCodeAt(c);f==="blob"?e=new Blob([a.buffer],{type:g}):e=a.buffer;break;case"document":const c=new DOMParser;e=c.parseFromString(b,g);break;case"json":e=JSON.parse(b);break;default:e=b;break}setTimeout(function(){d&&d(e),c.manager.itemEnd(a)},0)}catch(b){setTimeout(function(){e&&e(b),c.manager.itemError(a),c.manager.itemEnd(a)},0)}}else{M[a]=[],M[a].push({onLoad:d,onProgress:h,onError:e}),b=new XMLHttpRequest,b.open("GET",a,!0),b.addEventListener("load",function(e){const d=this.response,b=M[a];if(delete M[a],this.status===200||this.status===0){this.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),a$.add(a,d);for(let a=0,e=b.length;a<e;a++){const c=b[a];c.onLoad&&c.onLoad(d)}c.manager.itemEnd(a)}else{for(let a=0,d=b.length;a<d;a++){const c=b[a];c.onError&&c.onError(e)}c.manager.itemError(a),c.manager.itemEnd(a)}},!1),b.addEventListener("progress",function(c){const b=M[a];for(let a=0,e=b.length;a<e;a++){const d=b[a];d.onProgress&&d.onProgress(c)}},!1),b.addEventListener("error",function(d){const b=M[a];delete M[a];for(let a=0,e=b.length;a<e;a++){const c=b[a];c.onError&&c.onError(d)}c.manager.itemError(a),c.manager.itemEnd(a)},!1),b.addEventListener("abort",function(d){const b=M[a];delete M[a];for(let a=0,e=b.length;a<e;a++){const c=b[a];c.onError&&c.onError(d)}c.manager.itemError(a),c.manager.itemEnd(a)},!1),this.responseType!==void 0&&(b.responseType=this.responseType),this.withCredentials!==void 0&&(b.withCredentials=this.withCredentials),b.overrideMimeType&&b.overrideMimeType(this.mimeType!==void 0?this.mimeType:"text/plain");for(const a in this.requestHeader)b.setRequestHeader(a,this.requestHeader[a]);b.send(null)}return c.manager.itemStart(a),b}setResponseType(a){return this.responseType=a,this}setMimeType(a){return this.mimeType=a,this}},eC=class extends ab{constructor(a){super(a)}load(a,d,i,h){this.path!==void 0&&(a=this.path+a),a=this.manager.resolveURL(a);const c=this,f=a$.get(a);if(f!==void 0)return c.manager.itemStart(a),setTimeout(function(){d&&d(f),c.manager.itemEnd(a)},0),f;const b=document.createElementNS("http://www.w3.org/1999/xhtml","img");function g(){b.removeEventListener("load",g,!1),b.removeEventListener("error",e,!1),a$.add(a,this),d&&d(this),c.manager.itemEnd(a)}function e(d){b.removeEventListener("load",g,!1),b.removeEventListener("error",e,!1),h&&h(d),c.manager.itemError(a),c.manager.itemEnd(a)}return b.addEventListener("load",g,!1),b.addEventListener("error",e,!1),a.substr(0,5)!=="data:"&&this.crossOrigin!==void 0&&(b.crossOrigin=this.crossOrigin),c.manager.itemStart(a),b.src=a,b}},mv=class extends ab{constructor(a){super(a)}load(c,d,h,f){const a=new cu,b=new eC(this.manager);b.setCrossOrigin(this.crossOrigin),b.setPath(this.path);let e=0;function g(g){b.load(c[g],function(b){a.images[g]=b,e++,e===6&&(a.needsUpdate=!0,d&&d(a))},void 0,f)}for(let a=0;a<c.length;++a)g(a);return a}},mw=class extends ab{constructor(a){super(a)}load(b,d,e,f){const a=new y,c=new eC(this.manager);return c.setCrossOrigin(this.crossOrigin),c.setPath(this.path),c.load(b,function(c){a.image=c;const e=b.search(/\.jpe?g($|\?)/i)>0||b.search(/^data\:image\/jpeg/)===0;a.format=e?av:N,a.needsUpdate=!0,d!==void 0&&d(a)},e,f),a}},J=class{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(a,b){const c=this.getUtoTmapping(a);return this.getPoint(c,b)}getPoints(a=5){const b=[];for(let c=0;c<=a;c++)b.push(this.getPoint(c/a));return b}getSpacedPoints(a=5){const b=[];for(let c=0;c<=a;c++)b.push(this.getPointAt(c/a));return b}getLength(){const a=this.getLengths();return a[a.length-1]}getLengths(b=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===b+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const a=[];let c,d=this.getPoint(0),e=0;a.push(0);for(let f=1;f<=b;f++)c=this.getPoint(f/b),e+=c.distanceTo(d),a.push(e),d=c;return this.cacheArcLengths=a,a}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(j,i){const b=this.getLengths();let a=0;const f=b.length;let d;i?d=i:d=j*b[f-1];let e=0,c=f-1,g;while(e<=c)if(a=Math.floor(e+(c-e)/2),g=b[a]-d,g<0)e=a+1;else if(g>0)c=a-1;else{c=a;break}if(a=c,b[a]===d)return a/(f-1);const h=b[a],k=b[a+1],l=k-h,m=(d-h)/l,n=(a+m)/(f-1);return n}getTangent(e,j){const g=1e-4;let c=e-g,d=e+g;c<0&&(c=0),d>1&&(d=1);const h=this.getPoint(c),i=this.getPoint(d),f=j||(h.isVector2?new b:new a);return f.copy(i).sub(h).normalize(),f}getTangentAt(a,b){const c=this.getUtoTmapping(a);return this.getTangent(c,b)}computeFrenetFrames(d,m){const i=new a,b=[],c=[],f=[],g=new a,j=new e;for(let c=0;c<=d;c++){const e=c/d;b[c]=this.getTangentAt(e,new a),b[c].normalize()}c[0]=new a,f[0]=new a;let h=Number.MAX_VALUE;const k=Math.abs(b[0].x),l=Math.abs(b[0].y),n=Math.abs(b[0].z);k<=h&&(h=k,i.set(1,0,0)),l<=h&&(h=l,i.set(0,1,0)),n<=h&&i.set(0,0,1),g.crossVectors(b[0],i).normalize(),c[0].crossVectors(b[0],g),f[0].crossVectors(b[0],c[0]);for(let a=1;a<=d;a++){if(c[a]=c[a-1].clone(),f[a]=f[a-1].clone(),g.crossVectors(b[a-1],b[a]),g.length()>Number.EPSILON){g.normalize();const d=Math.acos(E(b[a-1].dot(b[a]),-1,1));c[a].applyMatrix4(j.makeRotationAxis(g,d))}f[a].crossVectors(b[a],c[a])}if(m===!0){let a=Math.acos(E(c[0].dot(c[d]),-1,1));a/=d,b[0].dot(g.crossVectors(c[0],c[d]))>0&&(a=-a);for(let e=1;e<=d;e++)c[e].applyMatrix4(j.makeRotationAxis(b[e],a*e)),f[e].crossVectors(b[e],c[e])}return{tangents:b,normals:c,binormals:f}}clone(){return(new this.constructor).copy(this)}copy(a){return this.arcLengthDivisions=a.arcLengthDivisions,this}toJSON(){const a={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return a.arcLengthDivisions=this.arcLengthDivisions,a.type=this.type,a}fromJSON(a){return this.arcLengthDivisions=a.arcLengthDivisions,this}},cc=class extends J{constructor(a=0,b=0,c=1,d=1,e=0,f=Math.PI*2,g=!1,h=0){super(),this.type="EllipseCurve",this.aX=a,this.aY=b,this.xRadius=c,this.yRadius=d,this.aStartAngle=e,this.aEndAngle=f,this.aClockwise=g,this.aRotation=h}getPoint(h,i){const j=i||new b,c=Math.PI*2;let a=this.aEndAngle-this.aStartAngle;const g=Math.abs(a)<Number.EPSILON;while(a<0)a+=c;while(a>c)a-=c;a<Number.EPSILON&&(g?a=0:a=c),this.aClockwise===!0&&!g&&(a===c?a=-c:a=a-c);const f=this.aStartAngle+h*a;let d=this.aX+this.xRadius*Math.cos(f),e=this.aY+this.yRadius*Math.sin(f);if(this.aRotation!==0){const a=Math.cos(this.aRotation),b=Math.sin(this.aRotation),c=d-this.aX,f=e-this.aY;d=c*a-f*b+this.aX,e=c*b+f*a+this.aY}return j.set(d,e)}copy(a){return super.copy(a),this.aX=a.aX,this.aY=a.aY,this.xRadius=a.xRadius,this.yRadius=a.yRadius,this.aStartAngle=a.aStartAngle,this.aEndAngle=a.aEndAngle,this.aClockwise=a.aClockwise,this.aRotation=a.aRotation,this}toJSON(){const a=super.toJSON();return a.aX=this.aX,a.aY=this.aY,a.xRadius=this.xRadius,a.yRadius=this.yRadius,a.aStartAngle=this.aStartAngle,a.aEndAngle=this.aEndAngle,a.aClockwise=this.aClockwise,a.aRotation=this.aRotation,a}fromJSON(a){return super.fromJSON(a),this.aX=a.aX,this.aY=a.aY,this.xRadius=a.xRadius,this.yRadius=a.yRadius,this.aStartAngle=a.aStartAngle,this.aEndAngle=a.aEndAngle,this.aClockwise=a.aClockwise,this.aRotation=a.aRotation,this}},cc.prototype.isEllipseCurve=!0,eD=class extends cc{constructor(b,c,a,d,e,f){super(b,c,a,a,d,e,f),this.type="ArcCurve"}},eD.prototype.isArcCurve=!0;function ds(){let a=0,b=0,c=0,d=0;function e(e,g,f,h){a=e,b=f,c=-3*e+3*g-2*f-h,d=2*e-2*g+f+h}return{initCatmullRom:function(d,a,b,f,c){e(a,b,c*(b-d),c*(f-a))},initNonuniformCatmullRom:function(d,b,c,f,g,a,h){let i=(b-d)/g-(c-d)/(g+a)+(c-b)/a,j=(c-b)/a-(f-b)/(a+h)+(f-c)/h;i*=a,j*=a,e(b,c,i,j)},calc:function(e){const f=e*e,g=f*e;return a+b*e+c*f+d*g}}}cf=new a,du=new ds,dy=new ds,dA=new ds,eP=class extends J{constructor(a=[],b=!1,c="centripetal",d=.5){super(),this.type="CatmullRomCurve3",this.points=a,this.closed=b,this.curveType=c,this.tension=d}getPoint(l,m=new a){const j=m,d=this.points,b=d.length,k=(b-(this.closed?0:1))*l;let c=Math.floor(k),i=k-c;this.closed?c+=c>0?0:(Math.floor(Math.abs(c)/b)+1)*b:i===0&&c===b-1&&(c=b-2,i=1);let e,f;this.closed||c>0?e=d[(c-1)%b]:(cf.subVectors(d[0],d[1]).add(d[0]),e=cf);const h=d[c%b],g=d[(c+1)%b];if(this.closed||c+2<b?f=d[(c+2)%b]:(cf.subVectors(d[b-1],d[b-2]).add(d[b-1]),f=cf),this.curveType==="centripetal"||this.curveType==="chordal"){const d=this.curveType==="chordal"?.5:.25;let b=Math.pow(e.distanceToSquared(h),d),a=Math.pow(h.distanceToSquared(g),d),c=Math.pow(g.distanceToSquared(f),d);a<1e-4&&(a=1),b<1e-4&&(b=a),c<1e-4&&(c=a),du.initNonuniformCatmullRom(e.x,h.x,g.x,f.x,b,a,c),dy.initNonuniformCatmullRom(e.y,h.y,g.y,f.y,b,a,c),dA.initNonuniformCatmullRom(e.z,h.z,g.z,f.z,b,a,c)}else this.curveType==="catmullrom"&&(du.initCatmullRom(e.x,h.x,g.x,f.x,this.tension),dy.initCatmullRom(e.y,h.y,g.y,f.y,this.tension),dA.initCatmullRom(e.z,h.z,g.z,f.z,this.tension));return j.set(du.calc(i),dy.calc(i),dA.calc(i)),j}copy(a){super.copy(a),this.points=[];for(let b=0,c=a.points.length;b<c;b++){const d=a.points[b];this.points.push(d.clone())}return this.closed=a.closed,this.curveType=a.curveType,this.tension=a.tension,this}toJSON(){const a=super.toJSON();a.points=[];for(let b=0,c=this.points.length;b<c;b++){const d=this.points[b];a.points.push(d.toArray())}return a.closed=this.closed,a.curveType=this.curveType,a.tension=this.tension,a}fromJSON(b){super.fromJSON(b),this.points=[];for(let c=0,d=b.points.length;c<d;c++){const e=b.points[c];this.points.push((new a).fromArray(e))}return this.closed=b.closed,this.curveType=b.curveType,this.tension=b.tension,this}},eP.prototype.isCatmullRomCurve3=!0;function eQ(a,h,b,c,g){const d=(c-h)*.5,f=(g-b)*.5,e=a*a,i=a*e;return(2*b-2*c+d+f)*i+(-3*b+3*c-2*d-f)*e+d*a+b}function mH(b,c){const a=1-b;return a*a*c}function kM(a,b){return 2*(1-a)*a*b}function mJ(a,b){return a*a*b}function bu(a,b,c,d){return mH(a,b)+kM(a,c)+mJ(a,d)}function mL(b,c){const a=1-b;return a*a*a*c}function mM(a,c){const b=1-a;return 3*b*b*a*c}function mN(a,b){return 3*(1-a)*a*a*b}function mO(a,b){return a*a*a*b}function bw(a,b,c,d,e){return mL(a,b)+mM(a,c)+mN(a,d)+mO(a,e)}dO=class extends J{constructor(a=new b,c=new b,d=new b,e=new b){super(),this.type="CubicBezierCurve",this.v0=a,this.v1=c,this.v2=d,this.v3=e}getPoint(a,h=new b){const c=h,d=this.v0,e=this.v1,f=this.v2,g=this.v3;return c.set(bw(a,d.x,e.x,f.x,g.x),bw(a,d.y,e.y,f.y,g.y)),c}copy(a){return super.copy(a),this.v0.copy(a.v0),this.v1.copy(a.v1),this.v2.copy(a.v2),this.v3.copy(a.v3),this}toJSON(){const a=super.toJSON();return a.v0=this.v0.toArray(),a.v1=this.v1.toArray(),a.v2=this.v2.toArray(),a.v3=this.v3.toArray(),a}fromJSON(a){return super.fromJSON(a),this.v0.fromArray(a.v0),this.v1.fromArray(a.v1),this.v2.fromArray(a.v2),this.v3.fromArray(a.v3),this}},dO.prototype.isCubicBezierCurve=!0,eR=class extends J{constructor(b=new a,c=new a,d=new a,e=new a){super(),this.type="CubicBezierCurve3",this.v0=b,this.v1=c,this.v2=d,this.v3=e}getPoint(b,h=new a){const g=h,c=this.v0,d=this.v1,e=this.v2,f=this.v3;return g.set(bw(b,c.x,d.x,e.x,f.x),bw(b,c.y,d.y,e.y,f.y),bw(b,c.z,d.z,e.z,f.z)),g}copy(a){return super.copy(a),this.v0.copy(a.v0),this.v1.copy(a.v1),this.v2.copy(a.v2),this.v3.copy(a.v3),this}toJSON(){const a=super.toJSON();return a.v0=this.v0.toArray(),a.v1=this.v1.toArray(),a.v2=this.v2.toArray(),a.v3=this.v3.toArray(),a}fromJSON(a){return super.fromJSON(a),this.v0.fromArray(a.v0),this.v1.fromArray(a.v1),this.v2.fromArray(a.v2),this.v3.fromArray(a.v3),this}},eR.prototype.isCubicBezierCurve3=!0,cq=class extends J{constructor(a=new b,c=new b){super(),this.type="LineCurve",this.v1=a,this.v2=c}getPoint(c,d=new b){const a=d;return c===1?a.copy(this.v2):(a.copy(this.v2).sub(this.v1),a.multiplyScalar(c).add(this.v1)),a}getPointAt(a,b){return this.getPoint(a,b)}getTangent(d,c){const a=c||new b;return a.copy(this.v2).sub(this.v1).normalize(),a}copy(a){return super.copy(a),this.v1.copy(a.v1),this.v2.copy(a.v2),this}toJSON(){const a=super.toJSON();return a.v1=this.v1.toArray(),a.v2=this.v2.toArray(),a}fromJSON(a){return super.fromJSON(a),this.v1.fromArray(a.v1),this.v2.fromArray(a.v2),this}},cq.prototype.isLineCurve=!0,mT=class extends J{constructor(b=new a,c=new a){super(),this.type="LineCurve3",this.isLineCurve3=!0,this.v1=b,this.v2=c}getPoint(c,d=new a){const b=d;return c===1?b.copy(this.v2):(b.copy(this.v2).sub(this.v1),b.multiplyScalar(c).add(this.v1)),b}getPointAt(a,b){return this.getPoint(a,b)}copy(a){return super.copy(a),this.v1.copy(a.v1),this.v2.copy(a.v2),this}toJSON(){const a=super.toJSON();return a.v1=this.v1.toArray(),a.v2=this.v2.toArray(),a}fromJSON(a){return super.fromJSON(a),this.v1.fromArray(a.v1),this.v2.fromArray(a.v2),this}},dJ=class extends J{constructor(a=new b,c=new b,d=new b){super(),this.type="QuadraticBezierCurve",this.v0=a,this.v1=c,this.v2=d}getPoint(a,g=new b){const c=g,d=this.v0,e=this.v1,f=this.v2;return c.set(bu(a,d.x,e.x,f.x),bu(a,d.y,e.y,f.y)),c}copy(a){return super.copy(a),this.v0.copy(a.v0),this.v1.copy(a.v1),this.v2.copy(a.v2),this}toJSON(){const a=super.toJSON();return a.v0=this.v0.toArray(),a.v1=this.v1.toArray(),a.v2=this.v2.toArray(),a}fromJSON(a){return super.fromJSON(a),this.v0.fromArray(a.v0),this.v1.fromArray(a.v1),this.v2.fromArray(a.v2),this}},dJ.prototype.isQuadraticBezierCurve=!0,eS=class extends J{constructor(b=new a,c=new a,d=new a){super(),this.type="QuadraticBezierCurve3",this.v0=b,this.v1=c,this.v2=d}getPoint(b,g=new a){const f=g,c=this.v0,d=this.v1,e=this.v2;return f.set(bu(b,c.x,d.x,e.x),bu(b,c.y,d.y,e.y),bu(b,c.z,d.z,e.z)),f}copy(a){return super.copy(a),this.v0.copy(a.v0),this.v1.copy(a.v1),this.v2.copy(a.v2),this}toJSON(){const a=super.toJSON();return a.v0=this.v0.toArray(),a.v1=this.v1.toArray(),a.v2=this.v2.toArray(),a}fromJSON(a){return super.fromJSON(a),this.v0.fromArray(a.v0),this.v1.fromArray(a.v1),this.v2.fromArray(a.v2),this}},eS.prototype.isQuadraticBezierCurve3=!0,dN=class extends J{constructor(a=[]){super(),this.type="SplineCurve",this.points=a}getPoint(k,l=new b){const f=l,a=this.points,g=(a.length-1)*k,c=Math.floor(g),d=g-c,e=a[c===0?c:c-1],h=a[c],i=a[c>a.length-2?a.length-1:c+1],j=a[c>a.length-3?a.length-1:c+2];return f.set(eQ(d,e.x,h.x,i.x,j.x),eQ(d,e.y,h.y,i.y,j.y)),f}copy(a){super.copy(a),this.points=[];for(let b=0,c=a.points.length;b<c;b++){const d=a.points[b];this.points.push(d.clone())}return this}toJSON(){const a=super.toJSON();a.points=[];for(let b=0,c=this.points.length;b<c;b++){const d=this.points[b];a.points.push(d.toArray())}return a}fromJSON(a){super.fromJSON(a),this.points=[];for(let c=0,d=a.points.length;c<d;c++){const e=a.points[c];this.points.push((new b).fromArray(e))}return this}},dN.prototype.isSplineCurve=!0,mX=Object.freeze({__proto__:null,ArcCurve:eD,CatmullRomCurve3:eP,CubicBezierCurve:dO,CubicBezierCurve3:eR,EllipseCurve:cc,LineCurve:cq,LineCurve3:mT,QuadraticBezierCurve:dJ,QuadraticBezierCurve3:eS,SplineCurve:dN}),mY=class extends J{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(a){this.curves.push(a)}closePath(){const a=this.curves[0].getPoint(0),b=this.curves[this.curves.length-1].getPoint(1);a.equals(b)||this.curves.push(new cq(b,a))}getPoint(d){const c=d*this.getLength(),b=this.getCurveLengths();let a=0;while(a<b.length){if(b[a]>=c){const f=b[a]-c,d=this.curves[a],e=d.getLength(),g=e===0?0:1-f/e;return d.getPointAt(g)}a++}return null}getLength(){const a=this.getCurveLengths();return a[a.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const a=[];let b=0;for(let c=0,d=this.curves.length;c<d;c++)b+=this.curves[c].getLength(),a.push(b);return this.cacheLengths=a,a}getSpacedPoints(b=40){const a=[];for(let c=0;c<=b;c++)a.push(this.getPoint(c/b));return this.autoClose&&a.push(a[0]),a}getPoints(b=12){const a=[];let c;for(let e=0,f=this.curves;e<f.length;e++){const d=f[e],h=d&&d.isEllipseCurve?b*2:d&&(d.isLineCurve||d.isLineCurve3)?1:d&&d.isSplineCurve?b*d.points.length:b,g=d.getPoints(h);for(let b=0;b<g.length;b++){const d=g[b];if(c&&c.equals(d))continue;a.push(d),c=d}}return this.autoClose&&a.length>1&&!a[a.length-1].equals(a[0])&&a.push(a[0]),a}copy(a){super.copy(a),this.curves=[];for(let b=0,c=a.curves.length;b<c;b++){const d=a.curves[b];this.curves.push(d.clone())}return this.autoClose=a.autoClose,this}toJSON(){const a=super.toJSON();a.autoClose=this.autoClose,a.curves=[];for(let b=0,c=this.curves.length;b<c;b++){const d=this.curves[b];a.curves.push(d.toJSON())}return a}fromJSON(a){super.fromJSON(a),this.autoClose=a.autoClose,this.curves=[];for(let b=0,d=a.curves.length;b<d;b++){const c=a.curves[b];this.curves.push((new mX[c.type]).fromJSON(c))}return this}},cv=class extends mY{constructor(a){super(),this.type="Path",this.currentPoint=new b,a&&this.setFromPoints(a)}setFromPoints(a){this.moveTo(a[0].x,a[0].y);for(let b=1,c=a.length;b<c;b++)this.lineTo(a[b].x,a[b].y);return this}moveTo(a,b){return this.currentPoint.set(a,b),this}lineTo(a,c){const d=new cq(this.currentPoint.clone(),new b(a,c));return this.curves.push(d),this.currentPoint.set(a,c),this}quadraticCurveTo(d,e,a,c){const f=new dJ(this.currentPoint.clone(),new b(d,e),new b(a,c));return this.curves.push(f),this.currentPoint.set(a,c),this}bezierCurveTo(d,e,f,g,a,c){const h=new dO(this.currentPoint.clone(),new b(d,e),new b(f,g),new b(a,c));return this.curves.push(h),this.currentPoint.set(a,c),this}splineThru(a){const b=[this.currentPoint.clone()].concat(a),c=new dN(b);return this.curves.push(c),this.currentPoint.copy(a[a.length-1]),this}arc(a,b,c,d,e,f){const g=this.currentPoint.x,h=this.currentPoint.y;return this.absarc(a+g,b+h,c,d,e,f),this}absarc(b,c,a,d,e,f){return this.absellipse(b,c,a,a,d,e,f),this}ellipse(a,b,c,d,e,f,g,h){const i=this.currentPoint.x,j=this.currentPoint.y;return this.absellipse(a+i,b+j,c,d,e,f,g,h),this}absellipse(b,c,i,d,e,f,g,h){const a=new cc(b,c,i,d,e,f,g,h);if(this.curves.length>0){const b=a.getPoint(0);b.equals(this.currentPoint)||this.lineTo(b.x,b.y)}this.curves.push(a);const j=a.getPoint(1);return this.currentPoint.copy(j),this}copy(a){return super.copy(a),this.currentPoint.copy(a.currentPoint),this}toJSON(){const a=super.toJSON();return a.currentPoint=this.currentPoint.toArray(),a}fromJSON(a){return super.fromJSON(a),this.currentPoint.fromArray(a.currentPoint),this}},aQ=class extends cv{constructor(a){super(a),this.uuid=R(),this.type="Shape",this.holes=[]}getPointsHoles(b){const a=[];for(let c=0,d=this.holes.length;c<d;c++)a[c]=this.holes[c].getPoints(b);return a}extractPoints(a){return{shape:this.getPoints(a),holes:this.getPointsHoles(a)}}copy(a){super.copy(a),this.holes=[];for(let b=0,c=a.holes.length;b<c;b++){const d=a.holes[b];this.holes.push(d.clone())}return this}toJSON(){const a=super.toJSON();a.uuid=this.uuid,a.holes=[];for(let b=0,c=this.holes.length;b<c;b++){const d=this.holes[b];a.holes.push(d.toJSON())}return a}fromJSON(a){super.fromJSON(a),this.uuid=a.uuid,this.holes=[];for(let b=0,c=a.holes.length;b<c;b++){const d=a.holes[b];this.holes.push((new cv).fromJSON(d))}return this}},S=class extends h{constructor(a,b=1){super(),this.type="Light",this.color=new d(a),this.intensity=b}dispose(){}copy(a){return super.copy(a),this.color.copy(a.color),this.intensity=a.intensity,this}toJSON(b){const a=super.toJSON(b);return a.object.color=this.color.getHex(),a.object.intensity=this.intensity,this.groundColor!==void 0&&(a.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(a.object.distance=this.distance),this.angle!==void 0&&(a.object.angle=this.angle),this.decay!==void 0&&(a.object.decay=this.decay),this.penumbra!==void 0&&(a.object.penumbra=this.penumbra),this.shadow!==void 0&&(a.object.shadow=this.shadow.toJSON()),a}},S.prototype.isLight=!0,na=class extends S{constructor(a,b,c){super(a,c),this.type="HemisphereLight",this.position.copy(h.DefaultUp),this.updateMatrix(),this.groundColor=new d(b)}copy(a){return S.prototype.copy.call(this,a),this.groundColor.copy(a.groundColor),this}},na.prototype.isHemisphereLight=!0,eV=new e,eW=new a,fk=new a,cU=class{constructor(a){this.camera=a,this.bias=0,this.normalBias=0,this.radius=1,this.mapSize=new b(512,512),this.map=null,this.mapPass=null,this.matrix=new e,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new cm,this._frameExtents=new b(1,1),this._viewportCount=1,this._viewports=[new i(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(c){const a=this.camera,b=this.matrix;eW.setFromMatrixPosition(c.matrixWorld),a.position.copy(eW),fk.setFromMatrixPosition(c.target.matrixWorld),a.lookAt(fk),a.updateMatrixWorld(),eV.multiplyMatrices(a.projectionMatrix,a.matrixWorldInverse),this._frustum.setFromProjectionMatrix(eV),b.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),b.multiply(a.projectionMatrix),b.multiply(a.matrixWorldInverse)}getViewport(a){return this._viewports[a]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(a){return this.camera=a.camera.clone(),this.bias=a.bias,this.radius=a.radius,this.mapSize.copy(a.mapSize),this}clone(){return(new this.constructor).copy(this)}toJSON(){const a={};return this.bias!==0&&(a.bias=this.bias),this.normalBias!==0&&(a.normalBias=this.normalBias),this.radius!==1&&(a.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(a.mapSize=this.mapSize.toArray()),a.camera=this.camera.toJSON(!1).object,delete a.camera.matrix,a}},fm=class extends cU{constructor(){super(new D(50,1,.5,500)),this.focus=1}updateMatrices(b){const a=this.camera,c=cL*2*b.angle*this.focus,d=this.mapSize.width/this.mapSize.height,e=b.distance||a.far;(c!==a.fov||d!==a.aspect||e!==a.far)&&(a.fov=c,a.aspect=d,a.far=e,a.updateProjectionMatrix()),super.updateMatrices(b)}copy(a){return super.copy(a),this.focus=a.focus,this}},fm.prototype.isSpotLightShadow=!0,ng=class extends S{constructor(a,b,c=0,d=Math.PI/3,e=0,f=1){super(a,b),this.type="SpotLight",this.position.copy(h.DefaultUp),this.updateMatrix(),this.target=new h,this.distance=c,this.angle=d,this.penumbra=e,this.decay=f,this.shadow=new fm}get power(){return this.intensity*Math.PI}set power(a){this.intensity=a/Math.PI}dispose(){this.shadow.dispose()}copy(a){return super.copy(a),this.distance=a.distance,this.angle=a.angle,this.penumbra=a.penumbra,this.decay=a.decay,this.target=a.target.clone(),this.shadow=a.shadow.clone(),this}},ng.prototype.isSpotLight=!0,fn=new e,bm=new a,cK=new a,fo=class extends cU{constructor(){super(new D(90,1,.5,500)),this._frameExtents=new b(4,2),this._viewportCount=6,this._viewports=[new i(2,1,1,1),new i(0,1,1,1),new i(3,1,1,1),new i(1,1,1,1),new i(3,0,1,1),new i(1,0,1,1)],this._cubeDirections=[new a(1,0,0),new a(-1,0,0),new a(0,0,1),new a(0,0,-1),new a(0,1,0),new a(0,-1,0)],this._cubeUps=[new a(0,1,0),new a(0,1,0),new a(0,1,0),new a(0,1,0),new a(0,0,1),new a(0,0,-1)]}updateMatrices(b,c=0){const a=this.camera,e=this.matrix,d=b.distance||a.far;d!==a.far&&(a.far=d,a.updateProjectionMatrix()),bm.setFromMatrixPosition(b.matrixWorld),a.position.copy(bm),cK.copy(a.position),cK.add(this._cubeDirections[c]),a.up.copy(this._cubeUps[c]),a.lookAt(cK),a.updateMatrixWorld(),e.makeTranslation(-bm.x,-bm.y,-bm.z),fn.multiplyMatrices(a.projectionMatrix,a.matrixWorldInverse),this._frustum.setFromProjectionMatrix(fn)}},fo.prototype.isPointLightShadow=!0,nl=class extends S{constructor(a,b,c=0,d=1){super(a,b),this.type="PointLight",this.distance=c,this.decay=d,this.shadow=new fo}get power(){return this.intensity*4*Math.PI}set power(a){this.intensity=a/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(a){return super.copy(a),this.distance=a.distance,this.decay=a.decay,this.shadow=a.shadow.clone(),this}},nl.prototype.isPointLight=!0,fp=class extends dk{constructor(a=-1,b=1,c=1,d=-1,e=.1,f=2e3){super(),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=a,this.right=b,this.top=c,this.bottom=d,this.near=e,this.far=f,this.updateProjectionMatrix()}copy(a,b){return super.copy(a,b),this.left=a.left,this.right=a.right,this.top=a.top,this.bottom=a.bottom,this.near=a.near,this.far=a.far,this.zoom=a.zoom,this.view=a.view===null?null:Object.assign({},a.view),this}setViewOffset(a,b,c,d,e,f){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=a,this.view.fullHeight=b,this.view.offsetX=c,this.view.offsetY=d,this.view.width=e,this.view.height=f,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const g=(this.right-this.left)/(2*this.zoom),c=(this.top-this.bottom)/(2*this.zoom),d=(this.right+this.left)/2,e=(this.top+this.bottom)/2;let b=d-g,f=d+g,a=e+c,h=e-c;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,d=(this.top-this.bottom)/this.view.fullHeight/this.zoom;b+=c*this.view.offsetX,f=b+c*this.view.width,a-=d*this.view.offsetY,h=a-d*this.view.height}this.projectionMatrix.makeOrthographic(b,f,a,h,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(b){const a=super.toJSON(b);return a.object.zoom=this.zoom,a.object.left=this.left,a.object.right=this.right,a.object.top=this.top,a.object.bottom=this.bottom,a.object.near=this.near,a.object.far=this.far,this.view!==null&&(a.object.view=Object.assign({},this.view)),a}},fp.prototype.isOrthographicCamera=!0,fq=class extends cU{constructor(){super(new fp(-5,5,5,-5,.5,500))}},fq.prototype.isDirectionalLightShadow=!0,no=class extends S{constructor(a,b){super(a,b),this.type="DirectionalLight",this.position.copy(h.DefaultUp),this.updateMatrix(),this.target=new h,this.shadow=new fq}dispose(){this.shadow.dispose()}copy(a){return super.copy(a),this.target=a.target.clone(),this.shadow=a.shadow.clone(),this}},no.prototype.isDirectionalLight=!0,np=class extends S{constructor(a,b){super(a,b),this.type="AmbientLight"}},np.prototype.isAmbientLight=!0,nq=class extends S{constructor(a,b,c=10,d=10){super(a,b),this.type="RectAreaLight",this.width=c,this.height=d}copy(a){return super.copy(a),this.width=a.width,this.height=a.height,this}toJSON(b){const a=super.toJSON(b);return a.object.width=this.width,a.object.height=this.height,a}},nq.prototype.isRectAreaLight=!0,fr=class{constructor(){this.coefficients=[];for(let b=0;b<9;b++)this.coefficients.push(new a)}set(a){for(let b=0;b<9;b++)this.coefficients[b].copy(a[b]);return this}zero(){for(let a=0;a<9;a++)this.coefficients[a].set(0,0,0);return this}getAt(f,a){const c=f.x,d=f.y,e=f.z,b=this.coefficients;return a.copy(b[0]).multiplyScalar(.282095),a.addScaledVector(b[1],.488603*d),a.addScaledVector(b[2],.488603*e),a.addScaledVector(b[3],.488603*c),a.addScaledVector(b[4],1.092548*(c*d)),a.addScaledVector(b[5],1.092548*(d*e)),a.addScaledVector(b[6],.315392*(3*e*e-1)),a.addScaledVector(b[7],1.092548*(c*e)),a.addScaledVector(b[8],.546274*(c*c-d*d)),a}getIrradianceAt(f,a){const c=f.x,d=f.y,e=f.z,b=this.coefficients;return a.copy(b[0]).multiplyScalar(.886227),a.addScaledVector(b[1],2*.511664*d),a.addScaledVector(b[2],2*.511664*e),a.addScaledVector(b[3],2*.511664*c),a.addScaledVector(b[4],2*.429043*c*d),a.addScaledVector(b[5],2*.429043*d*e),a.addScaledVector(b[6],.743125*e*e-.247708),a.addScaledVector(b[7],2*.429043*c*e),a.addScaledVector(b[8],.429043*(c*c-d*d)),a}add(a){for(let b=0;b<9;b++)this.coefficients[b].add(a.coefficients[b]);return this}addScaledSH(a,b){for(let c=0;c<9;c++)this.coefficients[c].addScaledVector(a.coefficients[c],b);return this}scale(a){for(let b=0;b<9;b++)this.coefficients[b].multiplyScalar(a);return this}lerp(a,b){for(let c=0;c<9;c++)this.coefficients[c].lerp(a.coefficients[c],b);return this}equals(a){for(let b=0;b<9;b++)if(!this.coefficients[b].equals(a.coefficients[b]))return!1;return!0}copy(a){return this.set(a.coefficients)}clone(){return(new this.constructor).copy(this)}fromArray(a,b=0){const c=this.coefficients;for(let d=0;d<9;d++)c[d].fromArray(a,b+d*3);return this}toArray(a=[],b=0){const c=this.coefficients;for(let d=0;d<9;d++)c[d].toArray(a,b+d*3);return a}static getBasisAt(e,a){const b=e.x,c=e.y,d=e.z;a[0]=.282095,a[1]=.488603*c,a[2]=.488603*d,a[3]=.488603*b,a[4]=1.092548*b*c,a[5]=1.092548*c*d,a[6]=.315392*(3*d*d-1),a[7]=1.092548*b*d,a[8]=.546274*(b*b-c*c)}},fr.prototype.isSphericalHarmonics3=!0,cH=class extends S{constructor(a=new fr,b=1){super(void 0,b),this.sh=a}copy(a){return super.copy(a),this.sh.copy(a.sh),this}fromJSON(a){return this.intensity=a.intensity,this.sh.fromArray(a.sh),this}toJSON(b){const a=super.toJSON(b);return a.object.sh=this.sh.toArray(),a}},cH.prototype.isLightProbe=!0,nt=class{static decodeText(a){if(typeof TextDecoder!="undefined")return(new TextDecoder).decode(a);let b="";for(let c=0,d=a.length;c<d;c++)b+=String.fromCharCode(a[c]);try{return decodeURIComponent(escape(b))}catch(a){return b}}static extractUrlBase(a){const b=a.lastIndexOf("/");return b===-1?"./":a.substr(0,b+1)}},nu=class extends l{constructor(){super(),this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(a){return super.copy(a),this.instanceCount=a.instanceCount,this}clone(){return(new this.constructor).copy(this)}toJSON(){const a=super.toJSON(this);return a.instanceCount=this.instanceCount,a.isInstancedBufferGeometry=!0,a}},nu.prototype.isInstancedBufferGeometry=!0,nv=class extends u{constructor(c,d,a,b){typeof a=="number"&&(b=a,a=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(c,d,a),this.meshPerAttribute=b||1}copy(a){return super.copy(a),this.meshPerAttribute=a.meshPerAttribute,this}toJSON(){const a=super.toJSON();return a.meshPerAttribute=this.meshPerAttribute,a.isInstancedBufferAttribute=!0,a}},nv.prototype.isInstancedBufferAttribute=!0,nw=class extends ab{constructor(a){super(a),typeof createImageBitmap=="undefined"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch=="undefined"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(a){return this.options=a,this}load(a,c,g,f){a===void 0&&(a=""),this.path!==void 0&&(a=this.path+a),a=this.manager.resolveURL(a);const b=this,d=a$.get(a);if(d!==void 0)return b.manager.itemStart(a),setTimeout(function(){c&&c(d),b.manager.itemEnd(a)},0),d;const e={};e.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",e.headers=this.requestHeader,fetch(a,e).then(function(a){return a.blob()}).then(function(a){return createImageBitmap(a,Object.assign(b.options,{colorSpaceConversion:"none"}))}).then(function(d){a$.add(a,d),c&&c(d),b.manager.itemEnd(a)}).catch(function(c){f&&f(c),b.manager.itemError(a),b.manager.itemEnd(a)}),b.manager.itemStart(a)}},nw.prototype.isImageBitmapLoader=!0,nx=class{constructor(){this.type="ShapePath",this.color=new d,this.subPaths=[],this.currentPath=null}moveTo(a,b){return this.currentPath=new cv,this.subPaths.push(this.currentPath),this.currentPath.moveTo(a,b),this}lineTo(a,b){return this.currentPath.lineTo(a,b),this}quadraticCurveTo(a,b,c,d){return this.currentPath.quadraticCurveTo(a,b,c,d),this}bezierCurveTo(a,b,c,d,e,f){return this.currentPath.bezierCurveTo(a,b,c,d,e,f),this}splineThru(a){return this.currentPath.splineThru(a),this}toShapes(o,q){function n(a){const b=[];for(let c=0,e=a.length;c<e;c++){const f=a[c],d=new aQ;d.curves=f.curves,b.push(d)}return b}function p(a,b){const d=b.length;let c=!1;for(let i=d-1,h=0;h<d;i=h++){let e=b[i],f=b[h],j=f.x-e.x,g=f.y-e.y;if(Math.abs(g)>Number.EPSILON){if(g<0&&(e=b[h],j=-j,f=b[i],g=-g),a.y<e.y||a.y>f.y)continue;if(a.y===e.y){if(a.x===e.x)return!0}else{const b=g*(a.x-e.x)-j*(a.y-e.y);if(b===0)return!0;if(b<0)continue;c=!c}}else{if(a.y!==e.y)continue;if(f.x<=a.x&&a.x<=e.x||e.x<=a.x&&a.x<=f.x)return!0}}return c}const m=ad.isClockWise,c=this.subPaths;if(c.length===0)return[];if(q===!0)return n(c);let g,d,f;const k=[];if(c.length===1)return d=c[0],f=new aQ,f.curves=d.curves,k.push(f),k;let h=!m(c[0].getPoints());h=o?!h:h;const i=[],a=[];let e=[],b=0,j;a[b]=void 0,e[b]=[];for(let f=0,i=c.length;f<i;f++)d=c[f],j=d.getPoints(),g=m(j),g=o?!g:g,g?(!h&&a[b]&&b++,a[b]={s:new aQ,p:j},a[b].s.curves=d.curves,h&&b++,e[b]=[]):e[b].push({h:d,p:j[0]});if(!a[0])return n(c);if(a.length>1){let b=!1;const c=[];for(let b=0,c=a.length;b<c;b++)i[b]=[];for(let d=0,g=a.length;d<g;d++){const f=e[d];for(let e=0;e<f.length;e++){const g=f[e];let h=!0;for(let f=0;f<a.length;f++)p(g.p,a[f].p)&&(d!==f&&c.push({froms:d,tos:f,hole:e}),h?(h=!1,i[f].push(g)):b=!0);h&&i[d].push(g)}}c.length>0&&(b||(e=i))}let l;for(let b=0,c=a.length;b<c;b++){f=a[b].s,k.push(f),l=e[b];for(let a=0,b=l.length;a<b;a++)f.holes.push(l[a].h)}return k}},ny=class{constructor(a){this.type="Font",this.data=a}generateShapes(c,d=100){const a=[],b=nz(c,d,this.data);for(let c=0,d=b.length;c<d;c++)Array.prototype.push.apply(a,b[c].toShapes());return a}};function nz(h,i,a){const d=Array.from(h),e=i/a.resolution,g=(a.boundingBox.yMax-a.boundingBox.yMin+a.underlineThickness)*e,c=[];let b=0,f=0;for(let h=0;h<d.length;h++){const i=d[h];if(i==="\n")b=0,f-=g;else{const d=nA(i,e,b,f,a);b+=d.offsetX,c.push(d.path)}}return c}function nA(m,a,b,c,l){const d=l.glyphs[m]||l.glyphs["?"];if(!d){console.error('THREE.Font: character "'+m+'" does not exists in font family '+l.familyName+".");return}const e=new nx;let h,i,j,f,k,g,n,o;if(d.o){const l=d._cachedOutline||(d._cachedOutline=d.o.split(" "));for(let d=0,m=l.length;d<m;){const p=l[d++];switch(p){case"m":h=l[d++]*a+b,i=l[d++]*a+c,e.moveTo(h,i);break;case"l":h=l[d++]*a+b,i=l[d++]*a+c,e.lineTo(h,i);break;case"q":j=l[d++]*a+b,f=l[d++]*a+c,k=l[d++]*a+b,g=l[d++]*a+c,e.quadraticCurveTo(k,g,j,f);break;case"b":j=l[d++]*a+b,f=l[d++]*a+c,k=l[d++]*a+b,g=l[d++]*a+c,n=l[d++]*a+b,o=l[d++]*a+c,e.bezierCurveTo(k,g,n,o,j,f);break}}}return{offsetX:d.ha*a,path:e}}ny.prototype.isFont=!0,ov={getContext:function(){return cr===void 0&&(cr=new(window.AudioContext||window.webkitAudioContext)),cr},setContext:function(a){cr=a}},nD=class extends ab{constructor(a){super(a)}load(c,d,e,b){const f=this,a=new mt(this.manager);a.setResponseType("arraybuffer"),a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(c,function(a){try{const b=a.slice(0),c=ov.getContext();c.decodeAudioData(b,function(a){d(a)})}catch(a){b?b(a):console.error(a),f.manager.itemError(c)}},e,b)}},nE=class extends cH{constructor(i,j,h=1){super(void 0,h);const b=(new d).set(i),c=(new d).set(j),g=new a(b.r,b.g,b.b),e=new a(c.r,c.g,c.b),f=Math.sqrt(Math.PI),k=f*Math.sqrt(.75);this.sh.coefficients[0].copy(g).add(e).multiplyScalar(f),this.sh.coefficients[1].copy(g).sub(e).multiplyScalar(k)}},nE.prototype.isHemisphereLightProbe=!0,nF=class extends cH{constructor(b,c=1){super(void 0,c);const a=(new d).set(b);this.sh.coefficients[0].set(a.r,a.g,a.b).multiplyScalar(2*Math.sqrt(Math.PI))}},nF.prototype.isAmbientLightProbe=!0,nG=class{constructor(a=!0){this.autoStart=a,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=ft(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let a=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const b=ft();a=(b-this.oldTime)/1e3,this.oldTime=b,this.elapsedTime+=a}return a}};function ft(){return(typeof performance=="undefined"?Date:performance).now()}nI=class extends h{constructor(a){super(),this.type="Audio",this.listener=a,this.context=a.context,this.gain=this.context.createGain(),this.gain.connect(a.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(a){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=a,this.connect(),this}setMediaElementSource(a){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(a),this.connect(),this}setMediaStreamSource(a){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(a),this.connect(),this}setBuffer(a){return this.buffer=a,this.sourceType="buffer",this.autoplay&&this.play(),this}play(b=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+b;const a=this.context.createBufferSource();return a.buffer=this.buffer,a.loop=this.loop,a.loopStart=this.loopStart,a.loopEnd=this.loopEnd,a.onended=this.onEnded.bind(this),a.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=a,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let a=1,b=this.filters.length;a<b;a++)this.filters[a-1].connect(this.filters[a]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let a=1,b=this.filters.length;a<b;a++)this.filters[a-1].disconnect(this.filters[a]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(a){return a||(a=[]),this._connected===!0?(this.disconnect(),this.filters=a.slice(),this.connect()):this.filters=a.slice(),this}setDetune(a){if(this.detune=a,this.source.detune===void 0)return;return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(a){return this.setFilters(a?[a]:[])}setPlaybackRate(a){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=a,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(a){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=a,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(a){return this.loopStart=a,this}setLoopEnd(a){return this.loopEnd=a,this}getVolume(){return this.gain.gain.value}setVolume(a){return this.gain.gain.setTargetAtTime(a,this.context.currentTime,.01),this}},nJ=class{constructor(a,b=2048){this.analyser=a.context.createAnalyser(),this.analyser.fftSize=b,this.data=new Uint8Array(this.analyser.frequencyBinCount),a.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let b=0;const a=this.getFrequencyData();for(let c=0;c<a.length;c++)b+=a[c];return b/a.length}},nK=class{constructor(e,f,a){this.binding=e,this.valueSize=a;let b,c,d;switch(f){case"quaternion":b=this._slerp,c=this._slerpAdditive,d=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(a*6),this._workIndex=5;break;case"string":case"bool":b=this._select,c=this._select,d=this._setAdditiveIdentityOther,this.buffer=new Array(a*5);break;default:b=this._lerp,c=this._lerpAdditive,d=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(a*5)}this._mixBufferRegion=b,this._mixBufferRegionAdditive=c,this._setIdentity=d,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(f,c){const d=this.buffer,b=this.valueSize,e=f*b+b;let a=this.cumulativeWeight;if(a===0){for(let a=0;a!==b;++a)d[e+a]=d[a];a=c}else{a+=c;const f=c/a;this._mixBufferRegion(d,e,0,f,b)}this.cumulativeWeight=a}accumulateAdditive(a){const c=this.buffer,b=this.valueSize,d=b*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(c,d,0,a,b),this.cumulativeWeightAdditive+=a}apply(e){const a=this.valueSize,b=this.buffer,c=e*a+a,d=this.cumulativeWeight,f=this.cumulativeWeightAdditive,g=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,d<1){const e=a*this._origIndex;this._mixBufferRegion(b,c,e,1-d,a)}f>0&&this._mixBufferRegionAdditive(b,c,this._addIndex*a,1,a);for(let d=a,e=a+a;d!==e;++d)if(b[d]!==b[d+a]){g.setValue(b,c);break}}saveOriginalState(){const d=this.binding,a=this.buffer,b=this.valueSize,c=b*this._origIndex;d.getValue(a,c);for(let d=b,e=c;d!==e;++d)a[d]=a[c+d%b];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const a=this.valueSize*3;this.binding.setValue(this.buffer,a)}_setAdditiveIdentityNumeric(){const a=this._addIndex*this.valueSize,b=a+this.valueSize;for(let c=a;c<b;c++)this.buffer[c]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const a=this._origIndex*this.valueSize,b=this._addIndex*this.valueSize;for(let c=0;c<this.valueSize;c++)this.buffer[b+c]=this.buffer[a+c]}_select(a,b,c,d,e){if(d>=.5)for(let d=0;d!==e;++d)a[b+d]=a[c+d]}_slerp(a,b,c,d){B.slerpFlat(a,b,a,b,a,c,d)}_slerpAdditive(a,b,d,e,f){const c=this._workIndex*f;B.multiplyQuaternionsFlat(a,c,a,b,a,d),B.slerpFlat(a,b,a,b,a,c,e)}_lerp(a,c,d,b,e){const f=1-b;for(let g=0;g!==e;++g){const h=c+g;a[h]=a[h]*f+a[d+g]*b}}_lerpAdditive(a,b,c,d,e){for(let f=0;f!==e;++f){const g=b+f;a[g]=a[g]+a[c+f]*d}}},cE="\\[\\]\\.:\\/",nM=new RegExp("["+cE+"]","g"),cD="[^"+cE+"]",nO="[^"+cE.replace("\\.","")+"]",nP=/((?:WC+[\/:])*)/.source.replace("WC",cD),nQ=/(WCOD+)?/.source.replace("WCOD",nO),nR=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",cD),nS=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",cD),nT=new RegExp("^"+nP+nQ+nR+nS+"$"),nU=["material","materials","bones"],nV=class{constructor(a,b,c){const d=c||g.parseTrackName(b);this._targetGroup=a,this._bindings=a.subscribe_(b,d)}getValue(b,c){this.bind();const d=this._targetGroup.nCachedObjects_,a=this._bindings[d];a!==void 0&&a.getValue(b,c)}setValue(b,c){const a=this._bindings;for(let d=this._targetGroup.nCachedObjects_,e=a.length;d!==e;++d)a[d].setValue(b,c)}bind(){const a=this._bindings;for(let b=this._targetGroup.nCachedObjects_,c=a.length;b!==c;++b)a[b].bind()}unbind(){const a=this._bindings;for(let b=this._targetGroup.nCachedObjects_,c=a.length;b!==c;++b)a[b].unbind()}},g=class{constructor(a,b,c){this.path=b,this.parsedPath=c||g.parseTrackName(b),this.node=g.findNode(a,this.parsedPath.nodeName)||a,this.rootNode=a,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(a,b,c){return a&&a.isAnimationObjectGroup?new g.Composite(a,b,c):new g(a,b,c)}static sanitizeNodeName(a){return a.replace(/\s/g,"_").replace(nM,"")}static parseTrackName(d){const b=nT.exec(d);if(!b)throw new Error("PropertyBinding: Cannot parse trackName: "+d);const a={nodeName:b[2],objectName:b[3],objectIndex:b[4],propertyName:b[5],propertyIndex:b[6]},c=a.nodeName&&a.nodeName.lastIndexOf(".");if(c!==void 0&&c!==-1){const b=a.nodeName.substring(c+1);nU.indexOf(b)!==-1&&(a.nodeName=a.nodeName.substring(0,c),a.objectName=b)}if(a.propertyName===null||a.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+d);return a}static findNode(b,a){if(!a||a===""||a==="."||a===-1||a===b.name||a===b.uuid)return b;if(b.skeleton){const c=b.skeleton.getBoneByName(a);if(c!==void 0)return c}if(b.children){const c=function(b){for(let e=0;e<b.length;e++){const d=b[e];if(d.name===a||d.uuid===a)return d;const f=c(d.children);if(f)return f}return null},d=c(b.children);if(d)return d}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(a,b){a[b]=this.node[this.propertyName]}_getValue_array(b,c){const a=this.resolvedProperty;for(let d=0,e=a.length;d!==e;++d)b[c++]=a[d]}_getValue_arrayElement(a,b){a[b]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(a,b){this.resolvedProperty.toArray(a,b)}_setValue_direct(a,b){this.targetObject[this.propertyName]=a[b]}_setValue_direct_setNeedsUpdate(a,b){this.targetObject[this.propertyName]=a[b],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(a,b){this.targetObject[this.propertyName]=a[b],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(b,c){const a=this.resolvedProperty;for(let d=0,e=a.length;d!==e;++d)a[d]=b[c++]}_setValue_array_setNeedsUpdate(b,c){const a=this.resolvedProperty;for(let d=0,e=a.length;d!==e;++d)a[d]=b[c++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(b,c){const a=this.resolvedProperty;for(let d=0,e=a.length;d!==e;++d)a[d]=b[c++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(a,b){this.resolvedProperty[this.propertyIndex]=a[b]}_setValue_arrayElement_setNeedsUpdate(a,b){this.resolvedProperty[this.propertyIndex]=a[b],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(a,b){this.resolvedProperty[this.propertyIndex]=a[b],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(a,b){this.resolvedProperty.fromArray(a,b)}_setValue_fromArray_setNeedsUpdate(a,b){this.resolvedProperty.fromArray(a,b),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(a,b){this.resolvedProperty.fromArray(a,b),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(a,b){this.bind(),this.getValue(a,b)}_setValue_unbound(a,b){this.bind(),this.setValue(a,b)}bind(){let a=this.node;const c=this.parsedPath,f=c.objectName,h=c.propertyName;let d=c.propertyIndex;if(a||(a=g.findNode(this.rootNode,c.nodeName)||this.rootNode,this.node=a),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!a){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(f){let b=c.objectIndex;switch(f){case"materials":if(!a.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!a.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}a=a.material.materials;break;case"bones":if(!a.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}a=a.skeleton.bones;for(let c=0;c<a.length;c++)if(a[c].name===b){b=c;break}break;default:if(a[f]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}a=a[f]}if(b!==void 0){if(a[b]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,a);return}a=a[b]}}const b=a[h];if(b===void 0){const b=c.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+b+"."+h+" but it wasn't found.",a);return}let i=this.Versioning.None;this.targetObject=a,a.needsUpdate!==void 0?i=this.Versioning.NeedsUpdate:a.matrixWorldNeedsUpdate!==void 0&&(i=this.Versioning.MatrixWorldNeedsUpdate);let e=this.BindingType.Direct;if(d!==void 0){if(h==="morphTargetInfluences"){if(!a.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(a.geometry.isBufferGeometry){if(!a.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}a.morphTargetDictionary[d]!==void 0&&(d=a.morphTargetDictionary[d])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}e=this.BindingType.ArrayElement,this.resolvedProperty=b,this.propertyIndex=d}else b.fromArray!==void 0&&b.toArray!==void 0?(e=this.BindingType.HasFromToArray,this.resolvedProperty=b):Array.isArray(b)?(e=this.BindingType.EntireArray,this.resolvedProperty=b):this.propertyName=h;this.getValue=this.GetterByBindingType[e],this.setValue=this.SetterByBindingTypeAndVersioning[e][i]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}},g.Composite=nV,g.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},g.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},g.prototype.GetterByBindingType=[g.prototype._getValue_direct,g.prototype._getValue_array,g.prototype._getValue_arrayElement,g.prototype._getValue_toArray],g.prototype.SetterByBindingTypeAndVersioning=[[g.prototype._setValue_direct,g.prototype._setValue_direct_setNeedsUpdate,g.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[g.prototype._setValue_array,g.prototype._setValue_array_setNeedsUpdate,g.prototype._setValue_array_setMatrixWorldNeedsUpdate],[g.prototype._setValue_arrayElement,g.prototype._setValue_arrayElement_setNeedsUpdate,g.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[g.prototype._setValue_fromArray,g.prototype._setValue_fromArray_setNeedsUpdate,g.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]],nX=class{constructor(){this.uuid=R(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const b={};this._indicesByUUID=b;for(let a=0,c=arguments.length;a!==c;++a)b[arguments[a].uuid]=a;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const a=this;this.stats={objects:{get total(){return a._objects.length},get inUse(){return this.total-a.nCachedObjects_}},get bindingsPerObject(){return a._bindings.length}}}add(){const a=this._objects,b=this._indicesByUUID,i=this._paths,e=this._parsedPaths,d=this._bindings,f=d.length;let h=void 0,j=a.length,c=this.nCachedObjects_;for(let m=0,o=arguments.length;m!==o;++m){const l=arguments[m],n=l.uuid;let k=b[n];if(k===void 0){k=j++,b[n]=k,a.push(l);for(let a=0,b=f;a!==b;++a)d[a].push(new g(l,i[a],e[a]))}else if(k<c){h=a[k];const j=--c,m=a[j];b[m.uuid]=k,a[k]=m,b[n]=j,a[j]=l;for(let a=0,h=f;a!==h;++a){const b=d[a],m=b[j];let c=b[k];b[k]=m,c===void 0&&(c=new g(l,i[a],e[a])),b[j]=c}}else a[k]!==h&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=c}remove(){const a=this._objects,b=this._indicesByUUID,d=this._bindings,e=d.length;let c=this.nCachedObjects_;for(let g=0,j=arguments.length;g!==j;++g){const h=arguments[g],i=h.uuid,f=b[i];if(f!==void 0&&f>=c){const g=c++,j=a[g];b[j.uuid]=f,a[f]=j,b[i]=g,a[g]=h;for(let b=0,c=e;b!==c;++b){const a=d[b],h=a[g],i=a[f];a[f]=h,a[g]=i}}}this.nCachedObjects_=c}uncache(){const a=this._objects,b=this._indicesByUUID,c=this._bindings,e=c.length;let d=this.nCachedObjects_,f=a.length;for(let h=0,j=arguments.length;h!==j;++h){const k=arguments[h],i=k.uuid,g=b[i];if(g!==void 0)if(delete b[i],g<d){const h=--d,i=a[h],j=--f,k=a[j];b[i.uuid]=g,a[g]=i,b[k.uuid]=h,a[h]=k,a.pop();for(let b=0,d=e;b!==d;++b){const a=c[b],f=a[h],i=a[j];a[g]=f,a[h]=i,a.pop()}}else{const d=--f,h=a[d];d>0&&(b[h.uuid]=g),a[g]=h,a.pop();for(let a=0,f=e;a!==f;++a){const b=c[a];b[g]=b[d],b.pop()}}}this.nCachedObjects_=d}subscribe_(a,h){const f=this._bindingsIndicesByPath;let b=f[a];const d=this._bindings;if(b!==void 0)return d[b];const i=this._paths,j=this._parsedPaths,c=this._objects,k=c.length,l=this.nCachedObjects_,e=new Array(k);b=d.length,f[a]=b,i.push(a),j.push(h),d.push(e);for(let b=l,d=c.length;b!==d;++b){const f=c[b];e[b]=new g(f,a,h)}return e}unsubscribe_(b){const c=this._bindingsIndicesByPath,a=c[b];if(a!==void 0){const f=this._paths,g=this._parsedPaths,d=this._bindings,e=d.length-1,h=d[e],i=b[e];c[i]=a,d[a]=h,d.pop(),g[a]=g[e],g.pop(),f[a]=f[e],f.pop()}}},nX.prototype.isAnimationObjectGroup=!0,nY=class{constructor(h,a,f=null,g=a.blendMode){this._mixer=h,this._clip=a,this._localRoot=f,this.blendMode=g;const d=a.tracks,b=d.length,c=new Array(b),e={endingStart:aH,endingEnd:aH};for(let a=0;a!==b;++a){const f=d[a].createInterpolant(null);c[a]=f,f.settings=e}this._interpolantSettings=e,this._interpolants=c,this._propertyBindings=new Array(b),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=lE,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(a){return this._startTime=a,this}setLoop(a,b){return this.loop=a,this.repetitions=b,this}setEffectiveWeight(a){return this.weight=a,this._effectiveWeight=this.enabled?a:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(a){return this._scheduleFading(a,0,1)}fadeOut(a){return this._scheduleFading(a,1,0)}crossFadeFrom(b,a,c){if(b.fadeOut(a),this.fadeIn(a),c){const c=this._clip.duration,d=b._clip.duration,e=d/c,f=c/d;b.warp(1,e,a),this.warp(f,1,a)}return this}crossFadeTo(a,b,c){return a.crossFadeFrom(this,b,c)}stopFading(){const a=this._weightInterpolant;return a!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(a)),this}setEffectiveTimeScale(a){return this.timeScale=a,this._effectiveTimeScale=this.paused?0:a,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(a){return this.timeScale=this._clip.duration/a,this.stopWarping()}syncWith(a){return this.time=a.time,this.timeScale=a.timeScale,this.stopWarping()}halt(a){return this.warp(this._effectiveTimeScale,0,a)}warp(g,h,i){const d=this._mixer,e=d.time,f=this.timeScale;let a=this._timeScaleInterpolant;a===null&&(a=d._lendControlInterpolant(),this._timeScaleInterpolant=a);const b=a.parameterPositions,c=a.sampleValues;return b[0]=e,b[1]=e+i,c[0]=g/f,c[1]=h/f,this}stopWarping(){const a=this._timeScaleInterpolant;return a!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(a)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(a,b,c,g){if(!this.enabled){this._updateWeight(a);return}const e=this._startTime;if(e!==null){const d=(a-e)*c;if(d<0||c===0)return;this._startTime=null,b=c*d}b*=this._updateTimeScale(a);const f=this._updateTime(b),d=this._updateWeight(a);if(d>0){const a=this._interpolants,b=this._propertyBindings;switch(this.blendMode){case et:for(let c=0,e=a.length;c!==e;++c)a[c].evaluate(f),b[c].accumulateAdditive(d);break;case c$:default:for(let c=0,e=a.length;c!==e;++c)a[c].evaluate(f),b[c].accumulate(g,d)}}}_updateWeight(b){let a=0;if(this.enabled){a=this.weight;const c=this._weightInterpolant;if(c!==null){const d=c.evaluate(b)[0];a*=d,b>c.parameterPositions[1]&&(this.stopFading(),d===0&&(this.enabled=!1))}}return this._effectiveWeight=a,a}_updateTimeScale(b){let a=0;if(!this.paused){a=this.timeScale;const c=this._timeScaleInterpolant;if(c!==null){const d=c.evaluate(b)[0];a*=d,b>c.parameterPositions[1]&&(this.stopWarping(),a===0?this.paused=!0:this.timeScale=a)}}return this._effectiveTimeScale=a,a}_updateTime(d){const c=this._clip.duration,f=this.loop;let a=this.time+d,b=this._loopCount;const e=f===lD;if(d===0)return b===-1?a:e&&(b&1)===1?c-a:a;if(f===lF){b===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));handle_stop:{if(a>=c){a=c}else if(a<0){a=0}else{this.time=a;break handle_stop}if(this.clampWhenFinished)this.paused=!0;else this.enabled=!1;this.time=a;this._mixer.dispatchEvent({type:"finished",action:this,direction:d<0?-1:1})}}else{if(b===-1&&(d>=0?(b=0,this._setEndings(!0,this.repetitions===0,e)):this._setEndings(this.repetitions===0,!0,e)),a>=c||a<0){const f=Math.floor(a/c);a-=c*f,b+=Math.abs(f);const g=this.repetitions-b;if(g<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,a=d>0?c:0,this.time=a,this._mixer.dispatchEvent({type:"finished",action:this,direction:d>0?1:-1});else{if(g===1){const a=d<0;this._setEndings(a,!a,e)}else this._setEndings(!1,!1,e);this._loopCount=b,this.time=a,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:f})}}else this.time=a;if(e&&(b&1)===1)return c-a}return a}_setEndings(b,c,d){const a=this._interpolantSettings;d?(a.endingStart=ay,a.endingEnd=ay):(b?a.endingStart=this.zeroSlopeAtStart?ay:aH:a.endingStart=cb,c?a.endingEnd=this.zeroSlopeAtEnd?ay:aH:a.endingEnd=cb)}_scheduleFading(g,h,f){const d=this._mixer,e=d.time;let a=this._weightInterpolant;a===null&&(a=d._lendControlInterpolant(),this._weightInterpolant=a);const b=a.parameterPositions,c=a.sampleValues;return b[0]=e,c[0]=h,b[1]=e+g,c[1]=f,this}},nZ=class extends aq{constructor(a){super(),this._root=a,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(a,f){const e=a._localRoot||this._root,i=a._clip.tracks,j=i.length,d=a._propertyBindings,k=a._interpolants,b=e.uuid,h=this._bindingsByRootAndName;let c=h[b];c===void 0&&(c={},h[b]=c);for(let h=0;h!==j;++h){const m=i[h],l=m.name;let a=c[l];if(a!==void 0)d[h]=a;else{if(a=d[h],a!==void 0){a._cacheIndex===null&&(++a.referenceCount,this._addInactiveBinding(a,b,l));continue}const c=f&&f._propertyBindings[h].binding.parsedPath;a=new nK(g.create(e,l,c),m.ValueTypeName,m.getValueSize()),++a.referenceCount,this._addInactiveBinding(a,b,l),d[h]=a}k[h].resultBuffer=a.buffer}}_activateAction(a){if(!this._isActiveAction(a)){if(a._cacheIndex===null){const d=(a._localRoot||this._root).uuid,b=a._clip.uuid,c=this._actionsByClip[b];this._bindAction(a,c&&c.knownActions[0]),this._addInactiveAction(a,b,d)}const b=a._propertyBindings;for(let a=0,d=b.length;a!==d;++a){const c=b[a];c.useCount++===0&&(this._lendBinding(c),c.saveOriginalState())}this._lendAction(a)}}_deactivateAction(a){if(this._isActiveAction(a)){const b=a._propertyBindings;for(let a=0,d=b.length;a!==d;++a){const c=b[a];--c.useCount===0&&(c.restoreOriginalState(),this._takeBackBinding(c))}this._takeBackAction(a)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const a=this;this.stats={actions:{get total(){return a._actions.length},get inUse(){return a._nActiveActions}},bindings:{get total(){return a._bindings.length},get inUse(){return a._nActiveBindings}},controlInterpolants:{get total(){return a._controlInterpolants.length},get inUse(){return a._nActiveControlInterpolants}}}}_isActiveAction(b){const a=b._cacheIndex;return a!==null&&a<this._nActiveActions}_addInactiveAction(a,c,f){const d=this._actions,e=this._actionsByClip;let b=e[c];if(b===void 0)b={knownActions:[a],actionByRoot:{}},a._byClipCacheIndex=0,e[c]=b;else{const c=b.knownActions;a._byClipCacheIndex=c.length,c.push(a)}a._cacheIndex=d.length,d.push(a),b.actionByRoot[f]=a}_removeInactiveAction(a){const c=this._actions,d=c[c.length-1],e=a._cacheIndex;d._cacheIndex=e,c[e]=d,c.pop(),a._cacheIndex=null;const f=a._clip.uuid,g=this._actionsByClip,h=g[f],b=h.knownActions,i=b[b.length-1],j=a._byClipCacheIndex;i._byClipCacheIndex=j,b[j]=i,b.pop(),a._byClipCacheIndex=null;const k=h.actionByRoot,l=(a._localRoot||this._root).uuid;delete k[l],b.length===0&&delete g[f],this._removeInactiveBindingsForAction(a)}_removeInactiveBindingsForAction(b){const a=b._propertyBindings;for(let b=0,d=a.length;b!==d;++b){const c=a[b];--c.referenceCount===0&&this._removeInactiveBinding(c)}}_lendAction(a){const b=this._actions,d=a._cacheIndex,c=this._nActiveActions++,e=b[c];a._cacheIndex=c,b[c]=a,e._cacheIndex=d,b[d]=e}_takeBackAction(a){const b=this._actions,d=a._cacheIndex,c=--this._nActiveActions,e=b[c];a._cacheIndex=c,b[c]=a,e._cacheIndex=d,b[d]=e}_addInactiveBinding(b,c,f){const d=this._bindingsByRootAndName,e=this._bindings;let a=d[c];a===void 0&&(a={},d[c]=a),a[f]=b,b._cacheIndex=e.length,e.push(b)}_removeInactiveBinding(b){const a=this._bindings,c=b.binding,d=c.rootNode.uuid,i=c.path,e=this._bindingsByRootAndName,f=e[d],g=a[a.length-1],h=b._cacheIndex;g._cacheIndex=h,a[h]=g,a.pop(),delete f[i],Object.keys(f).length===0&&delete e[d]}_lendBinding(a){const b=this._bindings,d=a._cacheIndex,c=this._nActiveBindings++,e=b[c];a._cacheIndex=c,b[c]=a,e._cacheIndex=d,b[d]=e}_takeBackBinding(a){const b=this._bindings,d=a._cacheIndex,c=--this._nActiveBindings,e=b[c];a._cacheIndex=c,b[c]=a,e._cacheIndex=d,b[d]=e}_lendControlInterpolant(){const c=this._controlInterpolants,b=this._nActiveControlInterpolants++;let a=c[b];return a===void 0&&(a=new ez(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),a.__cacheIndex=b,c[b]=a),a}_takeBackControlInterpolant(a){const b=this._controlInterpolants,d=a.__cacheIndex,c=--this._nActiveControlInterpolants,e=b[c];a.__cacheIndex=c,b[c]=a,e.__cacheIndex=d,b[d]=e}clipAction(c,i,b){const j=i||this._root,g=j.uuid;let a=typeof c=="string"?eB.findByName(j,c):c;const h=a!==null?a.uuid:c,d=this._actionsByClip[h];let f=null;if(b===void 0&&(a!==null?b=a.blendMode:b=c$),d!==void 0){const c=d.actionByRoot[g];if(c!==void 0&&c.blendMode===b)return c;f=d.knownActions[0],a===null&&(a=f._clip)}if(a===null)return null;const e=new nY(this,a,i,b);return this._bindAction(e,f),this._addInactiveAction(e,h,g),e}existingAction(a,e){const b=e||this._root,f=b.uuid,c=typeof a=="string"?eB.findByName(b,a):a,g=c?c.uuid:a,d=this._actionsByClip[g];return d!==void 0?d.actionByRoot[f]||null:null}stopAllAction(){const a=this._actions,b=this._nActiveActions;for(let c=b-1;c>=0;--c)a[c].stop();return this}update(a){a*=this.timeScale;const c=this._actions,d=this._nActiveActions,e=this.time+=a,f=Math.sign(a),b=this._accuIndex^=1;for(let g=0;g!==d;++g){const h=c[g];h._update(e,a,f,b)}const g=this._bindings,h=this._nActiveBindings;for(let a=0;a!==h;++a)g[a].apply(b);return this}setTime(a){this.time=0;for(let a=0;a<this._actions.length;a++)this._actions[a].time=0;return this.update(a)}getRoot(){return this._root}uncacheClip(e){const a=this._actions,b=e.uuid,c=this._actionsByClip,d=c[b];if(d!==void 0){const e=d.knownActions;for(let c=0,g=e.length;c!==g;++c){const b=e[c];this._deactivateAction(b);const d=b._cacheIndex,f=a[a.length-1];b._cacheIndex=null,b._byClipCacheIndex=null,f._cacheIndex=d,a[d]=f,a.pop(),this._removeInactiveBindingsForAction(b)}delete c[b]}}uncacheRoot(d){const b=d.uuid,c=this._actionsByClip;for(const d in c){const e=c[d].actionByRoot,a=e[b];a!==void 0&&(this._deactivateAction(a),this._removeInactiveAction(a))}const e=this._bindingsByRootAndName,a=e[b];if(a!==void 0)for(const c in a){const b=a[c];b.restoreOriginalState(),this._removeInactiveBinding(b)}}uncacheAction(b,c){const a=this.existingAction(b,c);a!==null&&(this._deactivateAction(a),this._removeInactiveAction(a))}},nZ.prototype._controlInterpolantsResultBuffer=new Float32Array(1),fu=class{constructor(a){typeof a=="string"&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),a=arguments[1]),this.value=a}clone(){return new fu(this.value.clone===void 0?this.value:this.value.clone())}},n$=class extends aO{constructor(a,b,c=1){super(a,b),this.meshPerAttribute=c||1}copy(a){return super.copy(a),this.meshPerAttribute=a.meshPerAttribute,this}clone(b){const a=super.clone(b);return a.meshPerAttribute=this.meshPerAttribute,a}toJSON(b){const a=super.toJSON(b);return a.isInstancedInterleavedBuffer=!0,a.meshPerAttribute=this.meshPerAttribute,a}},n$.prototype.isInstancedInterleavedBuffer=!0,oa=class{constructor(a,b,c,d,e){this.buffer=a,this.type=b,this.itemSize=c,this.elementSize=d,this.count=e,this.version=0}set needsUpdate(a){a===!0&&this.version++}setBuffer(a){return this.buffer=a,this}setType(a,b){return this.type=a,this.elementSize=b,this}setItemSize(a){return this.itemSize=a,this}setCount(a){return this.count=a,this}},oa.prototype.isGLBufferAttribute=!0,fv=new b,bq=class{constructor(a=new b(1/0,1/0),c=new b(-(1/0),-(1/0))){this.min=a,this.max=c}set(a,b){return this.min.copy(a),this.max.copy(b),this}setFromPoints(a){this.makeEmpty();for(let b=0,c=a.length;b<c;b++)this.expandByPoint(a[b]);return this}setFromCenterAndSize(a,c){const b=fv.copy(c).multiplyScalar(.5);return this.min.copy(a).sub(b),this.max.copy(a).add(b),this}clone(){return(new this.constructor).copy(this)}copy(a){return this.min.copy(a.min),this.max.copy(a.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-(1/0),this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(a){return a===void 0&&(console.warn("THREE.Box2: .getCenter() target is now required"),a=new b),this.isEmpty()?a.set(0,0):a.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(a){return a===void 0&&(console.warn("THREE.Box2: .getSize() target is now required"),a=new b),this.isEmpty()?a.set(0,0):a.subVectors(this.max,this.min)}expandByPoint(a){return this.min.min(a),this.max.max(a),this}expandByVector(a){return this.min.sub(a),this.max.add(a),this}expandByScalar(a){return this.min.addScalar(-a),this.max.addScalar(a),this}containsPoint(a){return!(a.x<this.min.x||a.x>this.max.x||a.y<this.min.y||a.y>this.max.y)}containsBox(a){return this.min.x<=a.min.x&&a.max.x<=this.max.x&&this.min.y<=a.min.y&&a.max.y<=this.max.y}getParameter(c,a){return a===void 0&&(console.warn("THREE.Box2: .getParameter() target is now required"),a=new b),a.set((c.x-this.min.x)/(this.max.x-this.min.x),(c.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(a){return!(a.max.x<this.min.x||a.min.x>this.max.x||a.max.y<this.min.y||a.min.y>this.max.y)}clampPoint(c,a){return a===void 0&&(console.warn("THREE.Box2: .clampPoint() target is now required"),a=new b),a.copy(c).clamp(this.min,this.max)}distanceToPoint(a){const b=fv.copy(a).clamp(this.min,this.max);return b.sub(a).length()}intersect(a){return this.min.max(a.min),this.max.min(a.max),this}union(a){return this.min.min(a.min),this.max.max(a.max),this}translate(a){return this.min.add(a),this.max.add(a),this}equals(a){return a.min.equals(this.min)&&a.max.equals(this.max)}},bq.prototype.isBox2=!0,fA=new a,bI=new a,og=class{constructor(b=new a,c=new a){this.start=b,this.end=c}set(a,b){return this.start.copy(a),this.end.copy(b),this}copy(a){return this.start.copy(a.start),this.end.copy(a.end),this}getCenter(b){return b===void 0&&(console.warn("THREE.Line3: .getCenter() target is now required"),b=new a),b.addVectors(this.start,this.end).multiplyScalar(.5)}delta(b){return b===void 0&&(console.warn("THREE.Line3: .delta() target is now required"),b=new a),b.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(c,b){return b===void 0&&(console.warn("THREE.Line3: .at() target is now required"),b=new a),this.delta(b).multiplyScalar(c).add(this.start)}closestPointToPointParameter(b,c){fA.subVectors(b,this.start),bI.subVectors(this.end,this.start);const d=bI.dot(bI),e=bI.dot(fA);let a=e/d;return c&&(a=E(a,0,1)),a}closestPointToPoint(c,d,b){const e=this.closestPointToPointParameter(c,d);return b===void 0&&(console.warn("THREE.Line3: .closestPointToPoint() target is now required"),b=new a),this.delta(b).multiplyScalar(e).add(this.start)}applyMatrix4(a){return this.start.applyMatrix4(a),this.end.applyMatrix4(a),this}equals(a){return a.start.equals(this.start)&&a.end.equals(this.end)}clone(){return(new this.constructor).copy(this)}},oh=class extends h{constructor(a){super(),this.material=a,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}},oh.prototype.isImmediateRenderObject=!0,aj=new a,bG=new e,dh=new e,ol=class extends cV{constructor(a){const b=fO(a),c=new l,e=[],f=[],g=new d(0,0,1),h=new d(0,1,0);for(let a=0;a<b.length;a++){const c=b[a];c.parent&&c.parent.isBone&&(e.push(0,0,0),e.push(0,0,0),f.push(g.r,g.g,g.b),f.push(h.r,h.g,h.b))}c.setAttribute("position",new s(e,3)),c.setAttribute("color",new s(f,3));const i=new bn({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(c,i),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=a,this.bones=b,this.matrix=a.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(d){const a=this.bones,b=this.geometry,c=b.getAttribute("position");dh.copy(this.root.matrixWorld).invert();for(let d=0,e=0;d<a.length;d++){const b=a[d];b.parent&&b.parent.isBone&&(bG.multiplyMatrices(dh,b.matrixWorld),aj.setFromMatrixPosition(bG),c.setXYZ(e,aj.x,aj.y,aj.z),bG.multiplyMatrices(dh,b.parent.matrixWorld),aj.setFromMatrixPosition(bG),c.setXYZ(e+1,aj.x,aj.y,aj.z),e+=2)}b.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(d)}};function fO(a){const b=[];a&&a.isBone&&b.push(a);for(let c=0;c<a.children.length;c++)b.push.apply(b,fO(a.children[c]));return b}on=class extends cV{constructor(i=10,c=10,g=4473924,e=8947848){g=new d(g),e=new d(e);const j=c/2,k=i/c,a=i/2,f=[],b=[];for(let l=0,d=0,h=-a;l<=c;l++,h+=k){f.push(-a,0,h,a,0,h),f.push(h,0,-a,h,0,a);const i=l===j?g:e;i.toArray(b,d),d+=3,i.toArray(b,d),d+=3,i.toArray(b,d),d+=3,i.toArray(b,d),d+=3}const h=new l;h.setAttribute("position",new s(f,3)),h.setAttribute("color",new s(b,3));const m=new bn({vertexColors:!0,toneMapped:!1});super(h,m),this.type="GridHelper"}},oo=new Float32Array(1),oz=new Int32Array(oo.buffer),oq=4,fP=8,oy=Math.pow(2,fP),kx=[.125,.215,.35,.446,.526,.582],ow=fP-oq+1+kx.length,oF={[aF]:0,[cZ]:1,[es]:2,[er]:3,[eq]:4,[ep]:5,[dT]:6},ou=new dt({side:t,depthWrite:!1,depthTest:!1}),ox=new K(new dC,ou),au=(1+Math.sqrt(5))/2,az=1/au,oA=[new a(1,1,1),new a(-1,1,1),new a(1,1,-1),new a(-1,1,-1),new a(0,au,az),new a(0,au,-az),new a(az,0,au),new a(-az,0,au),new a(au,az,0),new a(-au,az,0)],J.create=function(a,b){return console.log("THREE.Curve.create() has been deprecated"),a.prototype=Object.create(J.prototype),a.prototype.constructor=a,a.prototype.getPoint=b,a},cv.prototype.fromPoints=function(a){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(a)},on.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")},ol.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")},ab.prototype.extractUrlBase=function(a){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),nt.extractUrlBase(a)},ab.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}},bq.prototype.center=function(a){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(a)},bq.prototype.empty=function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},bq.prototype.isIntersectionBox=function(a){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(a)},bq.prototype.size=function(a){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(a)},H.prototype.center=function(a){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(a)},H.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},H.prototype.isIntersectionBox=function(a){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(a)},H.prototype.isIntersectionSphere=function(a){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(a)},H.prototype.size=function(a){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(a)},aN.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()},cm.prototype.setFromMatrix=function(a){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(a)},og.prototype.center=function(a){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(a)},v.prototype.flattenToArrayOffset=function(a,b){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(a,b)},v.prototype.multiplyVector3=function(a){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),a.applyMatrix3(this)},v.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},v.prototype.applyToBufferAttribute=function(a){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),a.applyMatrix3(this)},v.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},v.prototype.getInverse=function(a){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(a).invert()},e.prototype.extractPosition=function(a){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(a)},e.prototype.flattenToArrayOffset=function(a,b){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(a,b)},e.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),(new a).setFromMatrixColumn(this,3)},e.prototype.setRotationFromQuaternion=function(a){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(a)},e.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},e.prototype.multiplyVector3=function(a){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),a.applyMatrix4(this)},e.prototype.multiplyVector4=function(a){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),a.applyMatrix4(this)},e.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},e.prototype.rotateAxis=function(a){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),a.transformDirection(this)},e.prototype.crossVector=function(a){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),a.applyMatrix4(this)},e.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")},e.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},e.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},e.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},e.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},e.prototype.applyToBufferAttribute=function(a){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),a.applyMatrix4(this)},e.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},e.prototype.makeFrustum=function(a,b,c,d,e,f){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(a,b,d,c,e,f)},e.prototype.getInverse=function(a){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(a).invert()},U.prototype.isIntersectionLine=function(a){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(a)},B.prototype.multiplyVector3=function(a){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),a.applyQuaternion(this)},B.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()},aG.prototype.isIntersectionBox=function(a){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(a)},aG.prototype.isIntersectionPlane=function(a){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(a)},aG.prototype.isIntersectionSphere=function(a){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(a)},p.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},p.prototype.barycoordFromPoint=function(a,b){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(a,b)},p.prototype.midpoint=function(a){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(a)},p.prototypenormal=function(a){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(a)},p.prototype.plane=function(a){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(a)},p.barycoordFromPoint=function(a,b,c,d,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),p.getBarycoord(a,b,c,d,e)},p.normal=function(a,b,c,d){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),p.getNormal(a,b,c,d)},aQ.prototype.extractAllPoints=function(a){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(a)},aQ.prototype.extrude=function(a){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new bR(this,a)},aQ.prototype.makeGeometry=function(a){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new lO(this,a)},b.prototype.fromAttribute=function(a,b,c){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(a,b,c)},b.prototype.distanceToManhattan=function(a){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(a)},b.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},a.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},a.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},a.prototype.getPositionFromMatrix=function(a){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(a)},a.prototype.getScaleFromMatrix=function(a){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(a)},a.prototype.getColumnFromMatrix=function(a,b){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(b,a)},a.prototype.applyProjection=function(a){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(a)},a.prototype.fromAttribute=function(a,b,c){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(a,b,c)},a.prototype.distanceToManhattan=function(a){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(a)},a.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},i.prototype.fromAttribute=function(a,b,c){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(a,b,c)},i.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},h.prototype.getChildByName=function(a){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(a)},h.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},h.prototype.translate=function(a,b){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(b,a)},h.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},h.prototype.applyMatrix=function(a){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(a)},Object.defineProperties(h.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(a){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=a}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}}),K.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")},Object.defineProperties(K.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),lB},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}}),e$.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")},D.prototype.setLens=function(b,a){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),a!==void 0&&(this.filmGauge=a),this.setFocalLength(b)},Object.defineProperties(S.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(a){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=a}},shadowCameraLeft:{set:function(a){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=a}},shadowCameraRight:{set:function(a){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=a}},shadowCameraTop:{set:function(a){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=a}},shadowCameraBottom:{set:function(a){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=a}},shadowCameraNear:{set:function(a){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=a}},shadowCameraFar:{set:function(a){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=a}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(a){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=a}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(a){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=a}},shadowMapHeight:{set:function(a){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=a}}}),Object.defineProperties(u.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===bZ},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(bZ)}}}),u.prototype.setDynamic=function(a){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(a===!0?bZ:bl),this},u.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},u.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},l.prototype.addIndex=function(a){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(a)},l.prototype.addAttribute=function(b,a){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),!(a&&a.isBufferAttribute)&&!(a&&a.isInterleavedBufferAttribute)?(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(b,new u(arguments[1],arguments[2]))):b==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(a),this):this.setAttribute(b,a)},l.prototype.addDrawCall=function(a,b,c){c!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(a,b)},l.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},l.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},l.prototype.removeAttribute=function(a){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(a)},l.prototype.applyMatrix=function(a){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(a)},Object.defineProperties(l.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}}),aO.prototype.setDynamic=function(a){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(a===!0?bZ:bl),this},aO.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},bR.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")},bR.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")},bR.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")},cN.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")},fu.prototype.onUpdate=function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this},Object.defineProperties(r.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new d}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(a){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=a===fZ}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(a){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=a}}}),Object.defineProperties(ak.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(a){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=a}}}),j.prototype.clearTarget=function(a,b,c,d){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(a),this.clear(b,c,d)},j.prototype.animate=function(a){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(a)},j.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},j.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},j.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},j.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},j.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},j.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},j.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},j.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},j.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},j.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},j.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},j.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},j.prototype.enableScissorTest=function(a){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(a)},j.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},j.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},j.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},j.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},j.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},j.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},j.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},j.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},j.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},j.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()},Object.defineProperties(j.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(a){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=a}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(a){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=a}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(a){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=a===!0?cZ:aF}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}}),Object.defineProperties(fD.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}}),Object.defineProperties(ap.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(a){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=a}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(a){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=a}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(a){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=a}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(a){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=a}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(a){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=a}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(a){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=a}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(a){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=a}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(a){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=a}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(a){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=a}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(a){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=a}}}),nI.prototype.load=function(a){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const b=this,c=new nD;return c.load(a,function(a){b.setBuffer(a)}),this},nJ.prototype.getData=function(){return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),this.getFrequencyData()},dH.prototype.updateCubeMap=function(a,b){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(a,b)},dH.prototype.clear=function(a,b,c,d){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(a,b,c,d)},aP.crossOrigin=void 0,aP.loadTexture=function(d,a,e,f){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const b=new mw;b.setCrossOrigin(this.crossOrigin);const c=b.load(d,e,void 0,f);return a&&(c.mapping=a),c},aP.loadTextureCube=function(d,a,e,f){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const b=new mv;b.setCrossOrigin(this.crossOrigin);const c=b.load(d,e,void 0,f);return a&&(c.mapping=a),c},aP.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},aP.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")},typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:gm}})),typeof window!="undefined"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=gm),lb=class{static isWebGLAvailable(){try{const a=document.createElement("canvas");return!!(window.WebGLRenderingContext&&(a.getContext("webgl")||a.getContext("experimental-webgl")))}catch(a){return!1}}static isWebGL2Available(){try{const a=document.createElement("canvas");return!!(window.WebGL2RenderingContext&&a.getContext("webgl2"))}catch(a){return!1}}static getWebGLErrorMessage(){return this.getErrorMessage(1)}static getWebGL2ErrorMessage(){return this.getErrorMessage(2)}static getErrorMessage(c){const d={1:"WebGL",2:"WebGL 2"},e={1:window.WebGLRenderingContext,2:window.WebGL2RenderingContext};let b='Your $0 does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">$1</a>';const a=document.createElement("div");return a.id="webglmessage",a.style.fontFamily="monospace",a.style.fontSize="13px",a.style.fontWeight="normal",a.style.textAlign="center",a.style.background="#fff",a.style.color="#000",a.style.padding="1.5em",a.style.width="400px",a.style.margin="5em auto 0",e[c]?b=b.replace("$0","graphics card"):b=b.replace("$0","browser"),b=b.replace("$1",d[c]),a.innerHTML=b,a}},la=class{constructor(){this.scene=new cN,this.camera=new D(90,window.innerWidth/window.innerHeight,.1,1e3);try{this.renderer=new j({antialias:!1,failIfMajorPerformanceCaveat:!0})}catch(a){console.log(a),this.rendererFailure=!0;return}this.renderer.setSize(window.innerWidth,window.innerHeight),this.renderer.domElement.className="backdrop",document.body.appendChild(this.renderer.domElement),this.uniforms={iTime:{type:"f",value:.1},iResolution:{type:"v2",value:new b},iMouse:{type:"v2",value:new b}},this.uniforms.iResolution.value.x=window.innerWidth,this.uniforms.iResolution.value.y=window.innerHeight,this.uniforms.iMouse.value.x=window.innerWidth/2,this.uniforms.iMouse.value.y=window.innerHeight/2;const a=`
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
    `,c=`
    uniform float iTime;
    uniform vec2 iResolution;
    uniform vec2 iMouse;

    void main() {
      vec2 coord = gl_FragCoord.xy / iResolution.xy;
      vec2 ndc = -1.0 + 2.0 * coord;
      // Fix aspect ratio.
      ndc.x *= iResolution.x / iResolution.y;

      // Mouse input.
      vec2 mouseCoords = iMouse.xy / iResolution.xy;
      vec2 ndcMouse = -1.0 + 2.0 * mouseCoords;
      vec2 mouseOffset = ndcMouse * 0.8;

      // Camera.
      vec3 rho = vec3(sin(iTime * 0.16), 0, cos(iTime * 0.1));
      vec3 tau = rho + vec3(sin(iTime * 0.15), sin(iTime * 0.18), cos(iTime * 0.24));
      float roll = 0.0;

      // Camera translation.
      vec3 cw = normalize(tau - rho);
      vec3 cp = vec3(sin(roll), cos(roll), 0);
      vec3 cu = normalize(cross(cp, cw));
      vec3 rd = normalize((ndc.x + mouseOffset.x) * cu + (ndc.y - mouseOffset.y) * cp + cw * 2.0);

      // Volumetric rendering.
      vec3 v = vec3(0);
      for (float s = 0.1; s <= 5.0; s += 0.25) {
        vec3 p = rho + rd * s;
        for (float i = 0.1; i < 1.0; i += 0.12) {
          // Magic
          p = abs(p) / dot(p + sin(iTime * 0.09) * 0.1, p) - 0.5;
          float a = length(p);
          v += vec3(pow(i, 2.0), pow(i, 1.2), pow(i, 1.0)) * a * 0.12;
        }
      }

      gl_FragColor = vec4(v * 0.01, 1.0);
    }
    `,d=new ak({uniforms:this.uniforms,vertexShader:a,fragmentShader:c,side:bj}),e=new e_(100,100),f=new K(e,d);this.scene.add(f),this.camera.position.z=5,this.clock=new nG,window.addEventListener("resize",()=>{this.camera.aspect=window.innerWidth/window.innerHeight,this.camera.updateProjectionMatrix(),this.uniforms.iResolution.value.x=window.innerWidth,this.uniforms.iResolution.value.y=window.innerHeight,this.renderer.setSize(window.innerWidth,window.innerHeight)}),this.targetMousePos=new b(window.innerWidth/2,window.innerHeight/2),window.addEventListener("mousemove",a=>{this.targetMousePos.x=a.clientX,this.targetMousePos.y=a.clientY})}enable(){if(this.rendererFailure)return;if(this.isRunning)return;this.isRunning=!0,this.isFading=!1,this.animate()}fadeIn(){if(this.rendererFailure)return;if(this.isRunning)return;this.isRunning=!0,this.isFading=!0,this.currentOpacity=0,this.targetOpacity=1,this.fadeOffset=.02,this.animate()}disable(){this.isRunning=!1}fadeOut(){this.isFading=!0,this.currentOpacity=1,this.targetOpacity=0,this.fadeOffset=-.03}animate(){if(this.rendererFailure)return;if(!this.isRunning)return;requestAnimationFrame(()=>this.animate()),this.isFading&&(this.currentOpacity=Math.max(Math.min(this.currentOpacity+this.fadeOffset,1),0),this.currentOpacity===this.targetOpacity&&(this.isFading=!1,this.currentOpacity===0&&(this.isRunning=!1)),this.renderer.domElement.style.opacity=this.currentOpacity.toString()),this.uniforms.iTime.value+=this.clock.getDelta(),this.uniforms.iMouse.value.lerp(this.targetMousePos,.02),this.renderer.render(this.scene,this.camera)}};function gk(){const a=window.location.pathname;return a===""||a==="/"}function k_(a){const b=jQuery;let c;const d={debug:!0,scroll:!1,prefetch:!0,cacheLength:2,onStart:{duration:300,render:a=>{b("html, body").animate({scrollTop:0}),a.addClass("is-exiting"),c.restartCSSAnimations()}},onReady:{duration:0,render:(a,b)=>{a.removeClass("is-exiting"),a.html(b)}},onAfter:()=>{a&&(gk()?a.fadeIn():a.fadeOut()),typeof ga!="undefined"&&(ga("set","page",window.location.pathname),ga("send","pageview"))}};c=b("#main").smoothState(d).data("smoothState")}dE=null,lb.isWebGLAvailable()?(dE=new la,gk()&&dE.enable()):console.warn("Browser does not support WebGL; defaulting to static background"),typeof jQuery!="undefined"&&k_(dE)})()